# $Id$
## @file
# The Recompiler Sub-Makefile.
#
# There are a few of complicating factors here, esp. on AMD64 systems:
#
#   * op.c doesn't compile work correctly with gcc 4. For this we've
#     checked in op.S, which is the reason why we don't compile op.c
#     directly but always compile via the assembly file.s
#   * On 64-bit Windows we lack a compiler and have to resort to a
#     linux cross compiler building an ELF relocatable module which
#     we then load using a wrapper module. Thus the REM_MOD mess.
#   * On platforms using the 64-bit GCC ABI, we're not allowed to
#     generate non-PIC shared objects, and op.c requires the code
#     to be non-PIC. We apply the same trick as we developed for
#     64-bit windows.
#

#
# Copyright (C) 2006-2007 Sun Microsystems, Inc.
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
# Clara, CA 95054 USA or visit http://www.sun.com if you need
# additional information or have any questions.
#


SUB_DEPTH = ../..
include $(KBUILD_PATH)/subheader.kmk


BLDPROGS             += dyngen
ifneq ($(or $(eq $(KBUILD_TARGET_ARCH),amd64) , $(VBOX_TARGET_MAC_OS_X_VERSION_10_5)),)
 SYSMODS             += VBoxREM2
 REM_MOD             += VBoxREM2
else
 REM_MOD             += VBoxREM
endif
DLLS                 += VBoxREM
IMPORT_LIBS          += VBoxREMImp

OTHER_CLEAN          += \
	$(PATH_$(REM_MOD))/op.h \
	$(PATH_$(REM_MOD))/opc.h \
	$(PATH_$(REM_MOD))/gen-op.h \
	$(PATH_$(REM_MOD))/opc.h

#
# Globals
#
VBOX_PATH_RECOMPILER_SRC := $(PATH_SUB_CURRENT)


#
# L4 must use the no-crt path because it's lacking math stuff it seems...
# Darwin must use the non-crt path because it can't compile op.c nativly.
# All the AMD64 target must use the no-crt path because ELF doesn't like op.c
# when stuffed into a shared library and windows doesn't have 64-bit gcc (yet).
#
ifeq ($(filter-out l4 darwin freebsd,$(KBUILD_TARGET)),)
 REM_USE_NOCRT := 1
endif
ifeq ($(REM_MOD),VBoxREM2)
 REM_USE_NOCRT := 1
endif


#
# The dyngen build tool.
#
ifeq ($(KBUILD_HOST),win)
 dyngen_TOOL          = MINGW32
 dyngen_SDKS          = W32API
 # On 64-bit Windows we pretend to be 32-bit.
 dyngen_BLD_TRG_ARCH  = x86
 dyngen_BLD_TRG_CPU   = i386
 dyngen_CFLAGS        = -Wall -g -fno-strict-aliasing
else
 dyngen_TEMPLATE      = VBOXBLDPROG
endif
dyngen_DEFS          += REM_PHYS_ADDR_IN_TLB
ifeq ($(KBUILD_TARGET_ARCH),amd64)
 dyngen_DEFS         += HOST_X86_64=1
endif
dyngen_CFLAGS        += -Wno-missing-prototypes -Wno-missing-declarations
dyngen_INCS           = \
	Sun \
	target-i386 \
	fpu \
	.
dyngen_SOURCES        = dyngen.c


#
# The VBoxREM.[dll|so|..] or VBoxREM2.rel.
#
$(REM_MOD)_DEFS             = IN_REM_R3 REM_INCLUDE_CPU_H
$(REM_MOD)_DEFS            += REM_PHYS_ADDR_IN_TLB
#$(REM_MOD)_DEFS          += DEBUG_ALL_LOGGING DEBUG_DISAS DEBUG_PCALL DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.

$(REM_MOD)_INCS             = \
	Sun \
	Sun/crt\
	target-i386 \
	fpu \
	$(PATH_$(REM_MOD)) \
	$(PATH_ROOT)/src/VBox/VMM \
	.

$(REM_MOD)_SOURCES          = \
	VBoxRecompiler.c \
	cpu-exec.c \
	exec.c \
	translate-all.c \
	translate-op.c \
	fpu/softfloat-native.c \
	target-i386/helper.c \
	target-i386/helper2.c \
	target-i386/translate.c
$(REM_MOD)_SOURCES.debug = \
	Sun/testmath.c
ifeq ($(filter-out win os2,$(KBUILD_TARGET)),)
 $(REM_MOD)_SOURCES        += target-i386/op.c
 FILE_OP_OBJ                = $(PATH_$(REM_MOD))/target-i386/op.o
else # The remaining targets can be using gcc-4 and needs checking.
 $(REM_MOD)_SOURCES        += $(PATH_$(REM_MOD))/op.S
 FILE_OP_OBJ                = $(PATH_$(REM_MOD))/gen/op.o
 $(REM_MOD)_CLEAN           = $(FILE_OP_OBJ) $(PATH_$(REM_MOD))/op.S.dep
endif
$(REM_MOD)_SOURCES.win.x86  = $(REM_MOD).def
ifneq ($(REM_MOD),VBoxREM2)
 $(REM_MOD)_POST_CMDS       = $(VBOX_SIGN_IMAGE_CMDS)
endif


ifdef REM_USE_NOCRT
 $(REM_MOD)_TEMPLATE        = VBOXNOCRTGAS
 $(REM_MOD)_DEFS           += LOG_USE_C99 $(ARCH_BITS_DEFS)
 $(REM_MOD)_CFLAGS.amd64    = -O2
 $(REM_MOD)_CFLAGS.debug    = -O0
 ifdef ($(KBUILD_TARGET_ARCH),x86)
  $(REM_MOD)_CFLAGS.release+= -fomit-frame-pointer -fno-gcse
 endif

 # This doesn't fit in IPRT because it requires GAS and is LGPL.
 $(REM_MOD)_SOURCES        += \
	Sun/e_powl-$(KBUILD_TARGET_ARCH).S

 ifeq ($(REM_MOD),VBoxREM)
  $(REM_MOD)_LIBS           = \
	$(PATH_LIB)/RuntimeR3NoCRTGCC$(VBOX_SUFF_LIB) \
 	$(LIB_VMM) \
 	$(LIB_RUNTIME)
  ifeq ($(KBUILD_TARGET),l4)
   $(REM_MOD)_LIBS          += \
	$(L4_LIBDIR)/libuc.0.s.so
  endif
  $(REM_MOD)_LIBS.darwin    = \
  	$(TARGET_VBoxREMImp)
  $(REM_MOD)_LDFLAGS.darwin  = -read_only_relocs suppress -multiply_defined warning  #-install_name @executable_path/$(REM_MOD).dylib#
  $(REM_MOD)_CFLAGS.darwin   = -fno-common -mdynamic-no-pic
 else
  $(REM_MOD)_LIBS           = \
	$(PATH_LIB)/RuntimeR3NoCRTGCC$(VBOX_SUFF_LIB)
  $(REM_MOD)_SYSSUFF        = .rel
  $(REM_MOD)_LDFLAGS.darwin = -nostdlib -static
  $(REM_MOD)_CFLAGS.darwin  = -fno-common -static -mno-dynamic-no-pic
 endif

else # !REM_USE_NOCRT

 $(REM_MOD)_TOOL            = GXX3
 $(REM_MOD)_TOOL.solaris    = GXX3PLAIN
 $(REM_MOD)_TOOL.win.x86    = MINGW32
 $(REM_MOD)_TOOL.win.amd64  = XGCCAMD64LINUX
 $(REM_MOD)_SDKS.win.x86    = W32API  							## @todo do we really need this now?
 $(REM_MOD)_ASFLAGS         = -x assembler-with-cpp 			## @todo didn't I make this default already?
 $(REM_MOD)_CFLAGS          = -Wall -g
 $(REM_MOD)_CFLAGS.debug    = -O0
 $(REM_MOD)_CFLAGS.release += -fomit-frame-pointer -fno-gcse
 $(REM_MOD)_CFLAGS.profile  = $($(REM_MOD)_CFLAGS.release)
 $(REM_MOD)_CFLAGS.kprofile = $($(REM_MOD)_CFLAGS.release)
 $(REM_MOD)_CFLAGS.l4       = -nostdinc
 ifeq ($(KBUILD_TARGET),l4)
  $(REM_MOD)_INCS          += $(VBOX_L4_GCC3_INCS) $(L4_INCDIR)
 endif

 $(REM_MOD)_DEFS           += IN_RING3 LOG_USE_C99 $(ARCH_BITS_DEFS)
 #$(REM_MOD)_DEFS          += DEBUG_DISAS DEBUG_PCALL DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.
 # these defines are probably all irrelevant now:
 $(REM_MOD)_DEFS           += _GNU_SOURCE _FILE_OFFSET_BITS=64 _LARGEFILE_SOURCE _REENTRANT

 $(REM_MOD)_LDFLAGS.darwin  = -read_only_relocs suppress -install_name @executable_path/$(REM_MOD).dylib -multiple_defined warning
 $(REM_MOD)_LDFLAGS.l4      = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib -Wl,--no-undefined
 $(REM_MOD)_LDFLAGS.linux   = $(VBOX_LD_as_needed)
 $(REM_MOD)_LDFLAGS.os2     = -Zomf
 $(REM_MOD)_LDFLAGS.debug   = -g
 $(REM_MOD)_LDFLAGS.solaris = -mimpure-text
 ifdef VBOX_SOLARIS_10
  $(REM_MOD)_DEFS.solaris    += HOST_SOLARIS=10
 else # solaris 11
  $(REM_MOD)_DEFS.solaris    += HOST_SOLARIS=11
 endif
 ifeq ($(KBUILD_TARGET_ARCH),amd64)
  $(REM_MOD)_LIBS           = $(FILE_TOOL_GCC3_LIBGCC)
 else # x86
  $(REM_MOD)_LIBS           = \
 	$(LIB_VMM) \
 	$(LIB_RUNTIME)
  $(REM_MOD)_LIBS.win.x86   = \
 	mingw32 \
 	user32 gdi32 winmm ws2_32 iphlpapi dxguid
  $(REM_MOD)_LIBS.linux     = \
 	$(LIB_UUID) \
 	m \
 	util \
 	rt \
 	$(LIB_PTHREAD)
  $(REM_MOD)_LIBS.l4        = \
 	gcc \
 	$(L4_LIBDIR)/libvboxserver.s.so \
 	$(L4_LIBDIR)/libdl.s.so \
 	$(L4_LIBDIR)/libuc.0.s.so
 endif # x86

endif # !REM_USE_NOCRT

# Extra flags for these source modules.
target-i386/op.c_CFLAGS         = -O2 -fno-strict-aliasing -fomit-frame-pointer -falign-functions=0 -fno-reorder-blocks -fno-optimize-sibling-calls
target-i386/op.c_CFLAGS.x86     = -fno-gcse -fno-instrument-functions -mpreferred-stack-boundary=2
target-i386/op.c_CFLAGS.darwin.x86 = -m128bit-long-double -mpreferred-stack-boundary=4
target-i386/helper.c_CFLAGS.x86 = -O2 -fomit-frame-pointer -fno-strict-aliasing -fno-gcse
cpu-exec.c_CFLAGS.x86           = -O2 -fomit-frame-pointer -fno-strict-aliasing -fno-gcse
cpu-exec.c_CFLAGS.solaris.amd64 = -O2 -fomit-frame-pointer -fno-strict-aliasing


translate-all.c_DEPS = \
	$(PATH_$(REM_MOD))/op.h \
	$(PATH_$(REM_MOD))/opc.h \
	$(PATH_$(REM_MOD))/gen-op.h
translate-op.c_DEPS = $(translate-all.c_DEPS)
target-i386/translate.c_DEPS = $(translate-all.c_DEPS)


#
# The math testcase as a standalone program for testing and debugging purposes.
#
## @todo This is a bit messy because of MINGW32.
#BLDPROGS += testmath
testmath_TOOL           = GXX3
testmath_TOOL.win.x86   = MINGW32
testmath_SDKS.win.x86   = W32API
ifeq ($(KBUILD_HOST).$(KBUILD_HOST_ARCH),win.amd64)
 # 64-bit windows: Pretend to be 32-bit.
 testmath_BLD_TRG       = win32
 testmath_BLD_TRG_ARCH  = x86
 testmath_BLD_TRG_CPU   = i386
endif
testmath_ASTOOL         = $(VBOX_ASTOOL)
ifeq ($(filter-out win32 win64,$(KBUILD_HOST)),)
 testmath_ASFLAGS        = -f win32 -DNASM_FORMAT_PE $(VBOX_ASFLAGS) -w+orphan-labels
else
 testmath_ASFLAGS        = -f elf -DNASM_FORMAT_ELF $(VBOX_ASFLAGS) -w+orphan-labels
endif
testmath_ASFLAGS.amd64  = -m amd64
testmath_CFLAGS         = -Wall -g
testmath_CFLAGS.release = -O3
testmath_LDFLAGS        = -g
testmath_DEFS           = MATHTEST_STANDALONE
testmath_SOURCES        = Sun/testmath.c
#testmath_SOURCES        += $(PATH_LIB)/RuntimeR3NoCRTGCC$(VBOX_SUFF_LIB)


ifeq ($(REM_MOD),VBoxREM2)
#
# The VBoxREM2 wrapper.
#
VBoxREM_TEMPLATE       = VBOXR3
VBoxREM_DEFS           = IN_REM_R3
VBoxREM_SOURCES        = \
	VBoxREMWrapper.cpp \
	VBoxREMWrapperA.asm
VBoxREM_LDFLAGS.darwin = -install_name @executable_path/VBoxREM.dylib
VBoxREM_LIBS           = \
	$(LIB_VMM) \
	$(LIB_RUNTIME)
endif


#
# The VBoxREM import library.
#
VBoxREMImp_TEMPLATE         = VBOXR3
ifeq ($(KBUILD_TARGET),darwin)
VBoxREMImp_INST             = $(INST_LIB)
endif
VBoxREMImp_SOURCES.win      = VBoxREM.def
VBoxREMImp_SOURCES.os2      = $(PATH_TARGET)/VBoxREMOS2.def
ifeq ($(filter win os2,$(KBUILD_TARGET)),)
VBoxREMImp_SOURCES          = $(PATH_TARGET)/VBoxREMImp.c
VBoxREMImp_CLEAN            = $(PATH_TARGET)/VBoxREMImp.c
endif
ifneq ($(filter-out darwin os2 win,$(KBUILD_TARGET)),)
VBoxREMImp_SONAME           = VBoxREM$(SUFF_DLL)
endif
VBoxREMImp_LDFLAGS.darwin   = -install_name @executable_path/VBoxREM.dylib
#VBoxREMImp_LDFLAGS.darwin   = -install_name VBoxREM.dylib
VBoxREMImp_LDFLAGS.l4       = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib

$(PATH_TARGET)/VBoxREMImp.c: $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(VBOX_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed Makefile.kmk | $(call DIRDEP,$(PATH_TARGET))
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(PATH_TARGET)
	$(QUIET)$(APPEND) $@.tmp '#ifdef VBOX_HAVE_VISIBILITY_HIDDEN'
	$(QUIET)$(APPEND) $@.tmp '# define EXPORT __attribute__((visibility("default")))'
	$(QUIET)$(APPEND) $@.tmp '#else'
	$(QUIET)$(APPEND) $@.tmp '# define EXPORT'
	$(QUIET)$(APPEND) $@.tmp '#endif'
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(SED) -f $(VBOX_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed $< >> $@.tmp
	$(QUIET)$(MV) -f $@.tmp $@

$(VBoxREMImp_SOURCES.os2): $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(MAKEFILE) | $(call DIRDEP,$(PATH_TARGET))
	$(SED) \
		-e 's/^[ \t][ \t]*REMR3/    _REMR3/' \
		-e 's/\.[Dd][Ll][Ll]//' \
		-e 's/^LIBRARY .*/LIBRARY VBoxREM INITINSTANCE TERMINSTANCE\nDATA MULTIPLE\n/' \
		$< > $@.tmp
	$(MV) -f $@.tmp $@



include $(KBUILD_PATH)/subfooter.kmk


#
# Generate the op.S file somehow...
#
# Gathering the flags, defines and include dirs for the command is a lot
# of work. Unfortunately, there is only a highly specialized kBuild function
# for doing this, so we're currently left to our own devices here.
#
# Add something like VBOX_RECOMPILER_OP_GCC = gcc-3.4.6 to LocalConfig.kmk
# to be 100% sure that you get a working op.S. My gcc 4.1.1 seems to work
# fine, so feel free to try VBOX_RECOMPILER_OP_GCC = gcc.
#
# The op-undefined.lst is generated by finding all the undefined symbols
# in one (or more) ELF op.o files using nm.
#
ifndef VBOX_RECOMPILER_OP_GCC
 ifeq ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH),darwin.x86)
  VBOX_RECOMPILER_OP_GCC ?= $(notdir $(firstword $(which i386-elf-gcc-3.4 i386-elf-gcc-3.4.6 i386-elf-gcc-3.4.3 i386-elf-gcc) i386-elf-gcc)) # (port install i386-gcc-elf)
  VBOX_RECOMPILER_OP_GCC_OK := yes
  VBOX_RECOMPILER_OP_GCC_INCS ?= $(abspath $(dir $(shell LC_ALL=C $(VBOX_RECOMPILER_OP_GCC) -print-libgcc-file-name)))/include
 endif
 ifndef VBOX_RECOMPILER_OP_GCC
  VBOX_RECOMPILER_OP_GCC := $(TOOL_$(VBOX_GCC_TOOL)_CC)
  VBOX_RECOMPILER_OP_GCC_OK := dunno
 endif
else
 # If set, assume it's an OK compiler.
 VBOX_RECOMPILER_OP_GCC_OK := yes
endif


# The command sans -o op.S.tmp.
COMPILE_OP_CMDS_3 = $(VBOX_RECOMPILER_OP_GCC) \
	-S -s \
	$(filter-out -g -O0, \
		$($(REM_MOD)_CFLAGS) $($(REM_MOD)_CFLAGS.$(KBUILD_TYPE)) $($(REM_MOD)_CFLAGS.$(KBUILD_TARGET)) $($(REM_MOD)_CFLAGS.$(KBUILD_TARGET_ARCH)) $($(REM_MOD)_CFLAGS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
		$(target-i386/op.c_CFLAGS) $(target-i386/op.c_CFLAGS.$(KBUILD_TARGET)) $(target-i386/op.c_CFLAGS.$(KBUILD_TARGET_ARCH)) $(target-i386/op.c_CFLAGS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
		) \
	$(addprefix -I, $(abspathex \
		$($(REM_MOD)_CINCS.$(KBUILD_TARGET_ARCH)) $($(REM_MOD)_CINCS.$(KBUILD_TARGET)) $($(REM_MOD)_CINCS) $(CINCS) \
		$($(REM_MOD)_INCS.$(KBUILD_TARGET_ARCH))  $($(REM_MOD)_INCS.$(KBUILD_TARGET))  $($(REM_MOD)_INCS) $(INCS) \
		, $($(REM_MOD)_PATH))) \
	$(addprefix -D, \
		$($(REM_MOD)_CDEFS.$(KBUILD_TARGET_ARCH)) $($(REM_MOD)_CDEFS.$(KBUILD_TARGET)) $($(REM_MOD)_CDEFS) $(CDEFS.$(KBUILD_TARGET)) $(CDEFS.$(KBUILD_TARGET_ARCH)) $(CDEFS.$(KBUILD_TYPE)) $(CDEFS) \
		$($(REM_MOD)_DEFS.$(KBUILD_TARGET_ARCH))  $($(REM_MOD)_DEFS.$(KBUILD_TARGET))  $($(REM_MOD)_DEFS)  $(DEFS.$(KBUILD_TARGET))  $(DEFS.$(KBUILD_TARGET_ARCH))  $(DEFS.$(KBUILD_TYPE))  $(DEFS) \
		) \
	-Wp,-MD,$(PATH_$(REM_MOD))/op.S.dep \
        -Wp,-MT,$(PATH_$(REM_MOD))/op.S \
        -Wp,-MP \
	$(VBOX_PATH_RECOMPILER_SRC)/target-i386/op.c

# Use the right GCC includes.
ifdef VBOX_RECOMPILER_OP_GCC_INCS
COMPILE_OP_CMDS_2 = $(subst $(VBOX_PATH_GCC_INCS),$(VBOX_RECOMPILER_OP_GCC_INCS),$(COMPILE_OP_CMDS_3))
else
COMPILE_OP_CMDS_2 = $(COMPILE_OP_CMDS_3)
endif

# Drop incompatible options when using the cross-compiler on darwin.
ifeq ($(KBUILD_TARGET),darwin)
 ifeq ($(filter-out i386-elf-gcc%, $(VBOX_RECOMPILER_OP_GCC)),)
  COMPILE_OP_CMDS = $(filter-out -mdynamic-no-pic -mno-dynamic-no-pic -fno-stack-protector, $(COMPILE_OP_CMDS_2))
 endif
else if1of ($(KBUILD_TARGET),linux)
 ifneq ($(TOOL_$(VBOX_GCC_TOOL)_CC),$(VBOX_RECOMPILER_OP_GCC))
  VBOX_RECOMPILER_OP_CHECK_CC_GCC = $(shell \
    if $(VBOX_RECOMPILER_OP_GCC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
    then echo "$(1)"; \
    else echo "$(2)"; fi; )
  COMPILE_OP_CMDS = \
    $(filter-out -fno-stack-protector, $(COMPILE_OP_CMDS_2)) \
    $(call VBOX_RECOMPILER_OP_CHECK_CC_GCC,-fno-stack-protector)
 endif
endif
COMPILE_OP_CMDS ?= $(COMPILE_OP_CMDS_2)

# include the dependencies
-include $(PATH_$(REM_MOD))/op.S.dep

# The rule.
$(PATH_$(REM_MOD))/op.S: \
		$(VBOX_PATH_RECOMPILER_SRC)/target-i386/op.c \
		$(VBOX_PATH_RECOMPILER_SRC)/Sun/staged-op-elf-$(KBUILD_TARGET_ARCH).S \
		$(VBOX_PATH_RECOMPILER_SRC)/Sun/op-validate.sed \
		$(VBOX_PATH_RECOMPILER_SRC)/Sun/op-darwin.sed \
		$(VBOX_PATH_RECOMPILER_SRC)/Sun/op-undefined.lst \
		$(VBOX_PATH_RECOMPILER_SRC)/Makefile.kmk \
		$$(comp-cmds COMPILE_OP_CMDS,COMPILE_OP_CMDS_PREV,FORCE) \
		| $(call DIRDEP,$(PATH_$(REM_MOD)))
	$(RM) -f $@ $@.tmp $@.tmp2 $@.dep
ifeq ($(VBOX_RECOMPILER_OP_GCC_OK),yes)
	$(call MSG_COMPILE,VBoxREM,$<,$@,AS)
	$(addsuffix $(SP)\$(NL)$(TAB)  ,$(COMPILE_OP_CMDS)) -o $@.tmp
else ifeq ($(VBOX_RECOMPILER_OP_GCC_OK),dunno) # (permit 3.x.x and 4.1.x+ for now)
	major_ver=`$(VBOX_RECOMPILER_OP_GCC) -dumpversion | $(SED) -e 's/^\([2-9]\)\..*$$/\1/'`; \
	minor_ver=`$(VBOX_RECOMPILER_OP_GCC) -dumpversion | $(SED) -e 's/^[2-9]\.\([0-9]\)\..*$$/\1/'`; \
	bugfix_ver=`$(VBOX_RECOMPILER_OP_GCC) -dumpversion | $(SED) -e 's/^[2-9]\.[0-9]\.\([0-9]\).*$$/\1/'`; \
	if test "$$major_ver" = "3" -o "(" "$$major_ver" = "4" -a "$$minor_ver" != "0" ")"; then \
		$(ECHO_EXT) "Compiling $< => $@ [gcc v$${major_ver}.$${minor_ver}.$${bugfix_ver}]" && \
		$(addsuffix $(SP)\$(NL)$(TAB)$(TAB)  ,$(COMPILE_OP_CMDS)) -o $@.tmp; \
	else \
		$(ECHO_EXT) "Using staged op.S [gcc v$${major_ver}.$${minor_ver}.$${bugfix_ver}]" && \
		$(CP_EXT) -f $(VBOX_PATH_RECOMPILER_SRC)/Sun/staged-op-elf-$(KBUILD_TARGET_ARCH).S $@.tmp; \
	fi
else
	$(CP) $(VBOX_PATH_RECOMPILER_SRC)/Sun/staged-op-elf-$(KBUILD_TARGET_ARCH).S $@.tmp
endif
	$(SED) -f $(VBOX_PATH_RECOMPILER_SRC)/Sun/op-validate.sed $@.tmp
ifeq ($(KBUILD_TARGET),darwin)
	$(SED) -f $(VBOX_PATH_RECOMPILER_SRC)/Sun/op-darwin.sed $@.tmp > $@.tmp2
	$(SED) -e 's/^\(.*\)$$/#define \1 _\1/' $(VBOX_PATH_RECOMPILER_SRC)/Sun/op-undefined.lst > $@.tmp
	$(CAT_EXT) $@.tmp2 >> $@.tmp
endif
	$(MV) -f $@.tmp $@
	$(QUIET2)$(APPEND) "$@.dep"
	$(QUIET2)$(APPEND) "$@.dep" 'define COMPILE_OP_CMDS_PREV'
	$(QUIET2)$(APPEND) "$@.dep" '$(subst $(NL),'$(NL)$(TAB)@$(APPEND) "$@.dep" ',$(COMPILE_OP_CMDS))'
	$(QUIET2)$(APPEND) "$@.dep" 'endef'


# Hack for crosscompiling.
DYNGEN = $(PATH_dyngen)/dyngen$(HOSTSUFF_EXE)
DYNGEN_EXEC = $(DYNGEN)
ifneq ($(KBUILD_HOST),$(KBUILD_TARGET)) # hack for crosscompiling.
 ifeq ($(KBUILD_TARGET),win)
  DYNGEN       = $(PATH_dyngen)/dyngen.exe
  DYNGEN_EXEC := $(EXEC_X86_WIN32) $(DYNGEN_EXEC)
 endif
endif

# The dyngen rules.
$(PATH_$(REM_MOD))/op.h:     $(FILE_OP_OBJ) $(DYNGEN)
	$(call MSG_TOOL,dyngen,VBoxREM,$<,$@)
	$(QUIET)$(DYNGEN_EXEC) -o $@ $<

$(PATH_$(REM_MOD))/opc.h:    $(FILE_OP_OBJ) $(DYNGEN)
	$(call MSG_TOOL,dyngen,VBoxREM,$<,$@)
	$(QUIET)$(DYNGEN_EXEC) -c -o $@ $<

$(PATH_$(REM_MOD))/gen-op.h: $(FILE_OP_OBJ) $(DYNGEN)
	$(call MSG_TOOL,dyngen,VBoxREM,$<,$@)
	$(QUIET)$(DYNGEN_EXEC) -g -o $@ $<


# Some aliases
do_dyngen: $(PATH_$(REM_MOD))/gen-op.h $(PATH_$(REM_MOD))/opc.h $(PATH_$(REM_MOD))/op.h
importlib: $(LIB_REM)
op.S: $(PATH_$(REM_MOD))/op.S

