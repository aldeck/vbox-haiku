<?xml version="1.0" ?>

<!--
 * $Id$ *
 *
 * :tabSize=2:indentSize=2:noTabs=true:
 * :folding=explicit:collapseFolds=1:
 *
 * Master declaration for VirtualBox's Main API, represented
 * by COM/XPCOM and web service interfaces.
 *
 * From this document, the build system generates several files
 * via XSLT that are then used during the build process.
 *
 * Below is the list of XSL templates that operate on this file and
 * output files they generate. These XSL templates must be updated
 * whenever the schema of this file changes:
 *
 * 1. src/VBox/Main/idl/midl.xsl =>
 *    out/<platform>/bin/sdk/idl/VirtualBox.idl
 *    (MS COM interface definition file for Main API)
 *
 * 2. src/VBox/Main/idl/xpidl.xsl =>
 *    out/<platform>/bin/sdk/idl/VirtualBox_XPCOM.idl
 *    (XPCOM interface definition file for Main API)
 *
 * 3. src/VBox/Main/idl/doxygen.xsl =>
 *    out/<platform>/obj/src/VBox/Main/VirtualBox.idl
 *    (pseudo-IDL for Doxygen to generate the official Main API
 *     documentation)
 *
 * 4. src/VBox/Main/webservice/*.xsl =>
 *    a bunch of WSDL and C++ files
 *    (VirtualBox web service sources and SOAP mappers;
 *     see src/VBox/Main/webservice/Makefile.kmk for details)
 *
 * 5. src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl =>
 *    out/<platform>/obj/src/VBox/Frontends/VirtualBox/VirtualBox/include/COMWrappers.h
 *    (smart Qt-based C++ wrapper classes for COM interfaces
 *     of the Main API)
 *
 * 6. src/VBox/Frontends/VirtualBox4/include/COMWrappers.xsl =>
 *    out/<platform>/obj/src/VBox/Frontends/VirtualBox4/VirtualBox/include/COMWrappers.h
 *    (smart Qt-based C++ wrapper classes for COM interfaces
 *     of the Main API)
 *
 * 7. src/VBox/Installer/win32/VirtualBox_TypeLib.xsl =>
 *    out/<platform>/obj/src/VBox/Installer/win32/VirtualBox_TypeLib.wxi
 *    (Main API TypeLib block for the WiX installer)
 *
 * 8. src/VBox/Runtime/common/err/errmsgvboxcom.xsl =>
 *    out/<platform>/obj/Runtime/errmsgvboxcomdata.h
 *    (<result> extraction for the %Rhrc format specifier)
 *
     Copyright (C) 2006-2008 Sun Microsystems, Inc.

     This file is part of VirtualBox Open Source Edition (OSE), as
     available from http://www.virtualbox.org. This file is free software;
     you can redistribute it and/or modify it under the terms of the GNU
     General Public License (GPL) as published by the Free Software
     Foundation, in version 2 as it comes in the "COPYING" file of the
     VirtualBox OSE distribution. VirtualBox OSE is distributed in the
     hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

     Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
     Clara, CA 95054 USA or visit http://www.sun.com if you need
     additional information or have any questions.
-->

<idl>

<desc>
  Welcome to the <b>VirtualBox Main API documentation</b>. This documentation
  describes the so-called <i>VirtualBox Main API</i> which comprises all public
  COM interfaces and components provided by the VirtualBox server and by the
  VirtualBox client library.

  VirtualBox employs a client-server design, meaning that whenever any part of
  VirtualBox is running -- be it the Qt GUI, the VBoxManage command-line
  interface or any virtual machine --, a dedicated server process named
  VBoxSVC runs in the background. This allows multiple processes working with
  VirtualBox to cooperate without conflicts. These processes communicate to each
  other using inter-process communication facilities provided by the COM
  implementation of the host computer.

  On Windows platforms, the VirtualBox Main API uses Microsoft COM, a native COM
  implementation. On all other platforms, Mozilla XPCOM, an open-source COM
  implementation, is used.

  All the parts that a typical VirtualBox user interacts with (the Qt GUI,
  the VBoxManage command-line interface and the VBoxVRDP server) are technically
  front-ends to the Main API and only use the interfaces that are documented
  in this Main API documentation. This ensures that, with any given release
  version of VirtualBox, all capabilities of the product that could be useful
  to an external client program are always exposed by way of this API.

  The VirtualBox Main API (also called the <i>VirtualBox COM library</i>)
  contains two public component classes:
  <tt>%VirtualBox.VirtualBox</tt> and <tt>%VirtualBox.Session</tt>, which
  implement IVirtualBox and ISession interfaces respectively. These two classes
  are of supreme importance and will be needed in order for any front-end
  program to do anything useful. It is recommended to read the documentation of
  the mentioned interfaces first.

  The <tt>%VirtualBox.VirtualBox</tt> class is a singleton. This means that
  there can be only one object of this class on the local machine at any given
  time. This object is a parent of many other objects in the VirtualBox COM
  library and lives in the VBoxSVC process. In fact, when you create an instance
  of the <tt>VirtualBox.VirtualBox</tt>, the COM subsystem checks if the VBoxSVC
  process is already running, starts it if not, and returns you a reference to
  the<tt>VirtualBox</tt> object created in this process. When the last reference
  to this object is released, the VBoxSVC process ends (with a 5 second delay to
  protect from too frequent restarts).

  The <tt>%VirtualBox.Session</tt> class is a regular component. You can create
  as many <tt>Session</tt> objects as you need but all of them will live in a
  process which issues the object instantiation call. <tt>Session</tt> objects
  represent virtual machine sessions which are used to configure virtual
  machines and control their execution.
</desc>

<if target="midl">
  <cpp line="enum {"/>
  <cpp line="    kTypeLibraryMajorVersion = 1,"/>
  <cpp line="    kTypeLibraryMinorVersion = 0"/>
  <cpp line="};"/>
</if>

<if target="xpidl">
  <!-- NS_IMPL_THREADSAFE_ISUPPORTSxx_CI macros are placed here, for convenience -->
  <cpp>
/* currently, nsISupportsImpl.h lacks the below-like macros */

#define NS_IMPL_THREADSAFE_QUERY_INTERFACE1_CI  NS_IMPL_QUERY_INTERFACE1_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE2_CI  NS_IMPL_QUERY_INTERFACE2_CI

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS1_CI(_class, _interface)                 \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE1_CI(_class, _interface)                 \
   NS_IMPL_CI_INTERFACE_GETTER1(_class, _interface)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS2_CI(_class, _i1, _i2)                   \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE2_CI(_class, _i1, _i2)                   \
   NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif

#ifndef NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI(_class, _i1, _ic1)             \
   NS_INTERFACE_MAP_BEGIN(_class)                                             \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
   NS_INTERFACE_MAP_END
#endif

#ifndef NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI(_class, _i1, _ic1,             \
                                               _i2, _ic2)                     \
   NS_INTERFACE_MAP_BEGIN(_class)                                             \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i2, _ic2)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
   NS_INTERFACE_MAP_END
#endif

#define NS_IMPL_THREADSAFE_QUERY_INTERFACE1_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE2_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS1_AMBIGUOUS_CI(_class, _i1, _ic1)        \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE1_AMBIGUOUS_CI(_class, _i1, _ic1)        \
   NS_IMPL_CI_INTERFACE_GETTER1(_class, _i1)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS2_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                     _i2, _ic2)               \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE2_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                    _i2, _ic2)                \
   NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif
  </cpp>
</if>

<library
   name="VirtualBox"
   uuid="46137EEC-703B-4fe5-AFD4-7C9BBBBA0259"
   version="1.3"
   desc="VirtualBox Type Library"
   appUuid="819B4D85-9CEE-493C-B6FC-64FFE759B3C9"
   supportsErrorInfo="yes"
>


  <!--
  // COM result codes for VirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <descGroup id="VirtualBox_COM_result_codes" title="VirtualBox COM result codes">
    <desc>
      This section describes all VirtualBox-specific COM result codes that may
      be returned by methods of VirtualBox COM interfaces in addition to
      standard COM result codes.

      Note that along with the result code, every VirtualBox method returns
      extended error information through the IVirtualBoxErrorInfo interface on
      failure. This interface is a preferred way to present the error to the end
      user because it contains a human readable description of the error. Raw
      result codes, both standard and described in this section, are intended to
      be used by programs to analyze the reason of a failure and select an
      appropriate course of action without involving the end user (for example,
      retry the operation later or make a different call).

      The standard COM result codes that may originate from our methods include:

      <table>
      <tr><td>E_INVALIDARG</td>
      <td>
        Returned when the value of the method's argument is not within the range
        of valid values. This should not be confused with situations when the
        value is within the range but simply doesn't suit the current object
        state and there is a possibility that it will be accepted later (in such
        cases VirtualBox-specific codes are returned, for example,
        <link to="VBOX_E_OBJECT_NOT_FOUND"/>).
      </td>
      </tr>
      <tr><td>E_POINTER</td>
      <td>
        Returned if a memory pointer for the output argument is invalid (for
        example, <tt>NULL</tt>). Note that when pointers representing input
        arguments (such as strings) are invalid, E_INVALIDARG is returned.
      </td>
      </tr>
      <tr><td>E_ACCESSDENIED</td>
      <td>
        Returned when the called object is not ready. Since the lifetime of a
        public COM object cannot be fully controlled by the implementation,
        VirtualBox maintains the readiness state for all objects it creates and
        returns this code in response to any method call on the object that was
        deactivated by VirtualBox and is not functioning any more.
      </td>
      </tr>
      <tr><td>E_OUTOFMEMORY</td>
      <td>
        Returned when a memory allocation operation fails.
      </td>
      </tr>
      </table>
    </desc>
  </descGroup>

  <!--
    Note that src/VBox/Runtime/common/err/errmsgvboxcom.xsl will ignore
    everything in <result>/<desc> after (and including) the first dot, so express
    the matter of the error code in the first sentence and keep it short.
  -->

  <result name="VBOX_E_OBJECT_NOT_FOUND" value="0x80BB0001">
    <desc>
      Object corresponding to the supplied arguments does not exist.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_VM_STATE" value="0x80BB0002">
    <desc>
      Current virtual machine state prevents the operation.
    </desc>
  </result>

  <result name="VBOX_E_VM_ERROR" value="0x80BB0003">
    <desc>
      Virtual machine error occurred attempting the operation.
    </desc>
  </result>

  <result name="VBOX_E_FILE_ERROR" value="0x80BB0004">
    <desc>
      File not accessible or erroneous file contents.
    </desc>
  </result>

  <result name="VBOX_E_IPRT_ERROR" value="0x80BB0005">
    <desc>
      Runtime subsystem error.
    </desc>
  </result>

  <result name="VBOX_E_PDM_ERROR" value="0x80BB0006">
    <desc>
      Pluggable Device Manager error.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_OBJECT_STATE" value="0x80BB0007">
    <desc>
      Current object state prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_HOST_ERROR" value="0x80BB0008">
    <desc>
      Host operating system related error.
    </desc>
  </result>

  <result name="VBOX_E_NOT_SUPPORTED" value="0x80BB0009">
    <desc>
      Requested operation is not supported.
    </desc>
  </result>

  <result name="VBOX_E_XML_ERROR" value="0x80BB000A">
    <desc>
      Invalid XML found.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_SESSION_STATE" value="0x80BB000B">
    <desc>
      Current session state prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_OBJECT_IN_USE" value="0x80BB000C">
    <desc>
      Object being in use prohibits operation.
    </desc>
  </result>

  <!--
    Note that src/VBox/Runtime/common/err/errmsgvboxcom.xsl will ignore
    everything in <result>/<desc> after (and including) the first dot, so express
    the matter of the error code in the first sentence and keep it short.
  -->

  <descGroup/>

  <!--
  // all common enums
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="TSBool"
    uuid="523ff64d-842a-4b1a-80e7-c311b028cb3a"
  >
    <desc>
      Boolean variable having a third state, default.
    </desc>

    <const name="False"   value="0"/>
    <const name="True"    value="1"/>
    <const name="Default" value="2"/>
  </enum>

  <enum
    name="MachineState"
    uuid="73bf04d0-7c4f-4684-9abf-d65a9ad74343"
  >
    <desc>
      Virtual machine execution state.

      This enumeration represents possible values of the <link
      to="IMachine::state"/> attribute.

      Below is the basic virtual machine state diagram. It shows how the state
      changes during virtual machine execution. The text in square braces shows
      a method of the IConsole interface that performs the given state
      transition.

      <pre>
            +---------[powerDown()] &lt;- Stuck &lt;--[failure]-+
            V                                             |
    +-&gt; PoweredOff --+--&gt;[powerUp()]--&gt; Starting --+      | +-----[resume()]-----+
    |                |                             |      | V                    |
    |   Aborted -----+                             +--&gt; Running --[pause()]--&gt; Paused
    |                                              |      ^ |                   ^ |
    |   Saved -----------[powerUp()]--&gt; Restoring -+      | |                   | |
    |     ^                                               | |                   | |
    |     |     +-----------------------------------------+-|-------------------+ +
    |     |     |                                           |                     |
    |     |     +-- Saving &lt;--------[takeSnapshot()]&lt;-------+---------------------+
    |     |                                                 |                     |
    |     +-------- Saving &lt;--------[saveState()]&lt;----------+---------------------+
    |                                                       |                     |
    +-------------- Stopping -------[powerDown()]&lt;----------+---------------------+
      </pre>

      Note that states to the right from PoweredOff, Aborted and Saved in the
      above diagram are called <i>online VM states</i>. These states
      represent the virtual machine which is being executed in a dedicated
      process (usually with a GUI window attached to it where you can see the
      activity of the virtual machine and interact with it). There are two
      special pseudo-states, FirstOnline and LastOnline, that can be used in
      relational expressions to detect if the given machine state is online or
      not:

      <pre>
        if (machine.GetState() &gt;= MachineState_FirstOnline &amp;&amp;
            machine.GetState() &lt;= MachineState_LastOnline)
        {
            ...the machine is being executed...
        }
      </pre>

      When the virtual machine is in one of the online VM states (that is, being
      executed), only a few machine settings can be modified. Methods working
      with such settings contain an explicit note about that. An attempt to
      change any oter setting or perform a modifying operation during this time
      will result in the <link to="VBOX_E_INVALID_VM_STATE"/> error.

      All online states except Running, Paused and Stuck are transitional: they
      represent temporary conditions of the virtual machine that will last as
      long as the operation that initiated such a condition.

      The Stuck state is a special case. It means that execution of the machine
      has reached the "Guru Meditation" condition. This condition indicates an
      internal VMM (virtual machine manager) failure which may happen as a
      result of either an unhandled low-level virtual hardware exception or one
      of the recompiler exceptions (such as the <i>too-many-traps</i>
      condition).

      Note also that any online VM state may transit to the Aborted state. This
      happens if the process that is executing the virtual machine terminates
      unexpectedly (for example, crashes). Other than that, the Aborted state is
      equivalent to PoweredOff.

      There are also a few additional state diagrams that do not deal with
      virtual machine execution and therefore are shown separately. The states
      shown on these diagrams are called <i>offline VM states</i> (this includes
      PoweredOff, Aborted and Saved too).

      The first diagram shows what happens when a lengthy setup operation is
      being executed (such as <link to="IMachine::attachHardDisk2()"/>).

      <pre>
    +-----------------------------------(same sate as before the call)------+
    |                                                                       |
    +-&gt; PoweredOff --+                                                      |
    |                |                                                      |
    |-&gt; Aborted -----+--&gt;[lengthy VM configuration call] --&gt; SettingUp -----+
    |                |
    +-&gt; Saved -------+
      </pre>

      The next two diagrams demonstrate the process of taking a snapshot of a
      powered off virtual machine and performing one of the "discard..."
      operations, respectively.

      <pre>
    +-----------------------------------(same sate as before the call)------+
    |                                                                       |
    +-&gt; PoweredOff --+                                                      |
    |                +--&gt;[takeSnapshot()] -------------------&gt; Saving ------+
    +-&gt; Aborted -----+

    +-&gt; PoweredOff --+
    |                |
    |   Aborted -----+--&gt;[discardSnapshot()    ]-------------&gt; Discarding --+
    |                |   [discardCurrentState()]                            |
    +-&gt; Saved -------+   [discardCurrentSnapshotAndState()]                 |
    |                                                                       |
    +---(Saved if restored from an online snapshot, PoweredOff otherwise)---+
      </pre>

      Note that the Saving state is present in both the offline state group and
      online state group. Currently, the only way to determine what group is
      assumed in a particular case is to remember the previous machine state: if
      it was Running or Paused, then Saving is an online state, otherwise it is
      an offline state. This inconsistency may be removed in one of the future
      versions of VirtualBox by adding a new state.

      <note internal="yes">
        For whoever decides to touch this enum: In order to keep the
        comparisons involving FirstOnline and LastOnline pseudo-states valid,
        the numeric values of these states must be correspondingly updated if
        needed: for any online VM state, the condition
        <tt>FirstOnline &lt;= state &lt;= LastOnline</tt> must be
        <tt>true</tt>. The same relates to transient states for which
        the condition <tt>FirstOnline &lt;= state &lt;= LastOnline</tt> must be
        <tt>true</tt>.
      </note>
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (nver used by the API).</desc>
    </const>
    <const name="PoweredOff"            value="1">
      <desc>
        The machine is not running.
      </desc>
    </const>
    <const name="Saved"                 value="2">
      <desc>
        The machine is not currently running, but the execution state of the machine
        has been saved to an external file when it was running.
      </desc>
    </const>
    <const name="Aborted"               value="3">
      <desc>
        The process running the machine has terminated abnormally.
      </desc>
    </const>
    <const name="Running"               value="4">
      <desc>
        The machine is currently being executed.
        <note internal="yes">
          For whoever decides to touch this enum: In order to keep the
          comparisons in the old source code valid, this state must immediately
          precede the Paused state.
        </note>
      </desc>
    </const>
    <const name="Paused"                value="5">
      <desc>
        Execution of the machine has been paused.
        <note internal="yes">
          For whoever decides to touch this enum: In order to keep the
          comparisons in the old source code valid, this state must immediately
          follow the Running state.
        </note>
      </desc>
    </const>
    <const name="Stuck"                 value="6">
      <desc>
        Execution of the machine has reached the "Guru Meditation"
        condition.
      </desc>
    </const>
    <const name="Starting"              value="7">
      <desc>
        Machine is being started after powering it on from a
        zero execution state.
      </desc>
    </const>
    <const name="Stopping"              value="8">
      <desc>
        Machine is being normally stopped powering it off, or after the guest OS
        has initiated a shutdown sequence.
      </desc>
    </const>
    <const name="Saving"                value="9">
      <desc>
        Machine is saving its execution state to a file or an online
        snapshot of the machine is being taken.
      </desc>
    </const>
    <const name="Restoring"             value="10">
      <desc>
        Execution state of the machine is being restored from a file
        after powering it on from the saved execution state.
      </desc>
    </const>
    <const name="Discarding"            value="11">
      <desc>
        Snapshot of the machine is being discarded.
      </desc>
    </const>
    <const name="SettingUp"             value="12">
      <desc>
        Lengthy setup operation is in progress.
      </desc>
    </const>

    <const name="FirstOnline" value="4" wsmap="suppress"> <!-- Running -->
      <desc>
        Pseudo-state: first online state (for use in relational expressions).
      </desc>
    </const>
    <const name="LastOnline"  value="10" wsmap="suppress"> <!-- Restoring -->
      <desc>
        Pseudo-state: last online state (for use in relational expressions).
      </desc>
    </const>

    <const name="FirstTransient" value="7" wsmap="suppress"> <!-- Starting -->
      <desc>
        Pseudo-state: first transient state (for use in relational expressions).
      </desc>
    </const>
    <const name="LastTransient"  value="12" wsmap="suppress"> <!-- SettingUp -->
      <desc>
        Pseudo-state: last transient state (for use in relational expressions).
      </desc>
    </const>

  </enum>

  <enum
    name="SessionState"
    uuid="CF2700C0-EA4B-47ae-9725-7810114B94D8"
  >
    <desc>
      Session state. This enumeration represents possible values of
      <link to="IMachine::sessionState"/> and <link to="ISession::state"/>
      attributes. See individual enumerator descriptions for the meaning for
      every value.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Closed"                value="1">
      <desc>
        The machine has no open sessions (<link to="IMachine::sessionState"/>);
        the session is closed (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Open"                  value="2">
      <desc>
        The machine has an open direct session (<link to="IMachine::sessionState"/>);
        the session is open (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Spawning"              value="3">
      <desc>
        A new (direct) session is being opened for the machine
        as a result of <link to="IVirtualBox::openRemoteSession()"/>
        call (<link to="IMachine::sessionState"/>);
        the session is currently being opened
        as a result of <link to="IVirtualBox::openRemoteSession()"/>
        call (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Closing"               value="4">
      <desc>
        The direct session is being closed (<link to="IMachine::sessionState"/>);
        the session is being closed (<link to="ISession::state"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="SessionType"
    uuid="A13C02CB-0C2C-421E-8317-AC0E8AAA153A"
  >
    <desc>
      Session type. This enumeration represents possible values of the
      <link to="ISession::type"/> attribute.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Direct"                value="1">
      <desc>
        Direct session
        (opened by <link to="IVirtualBox::openSession()"/>)
      </desc>
    </const>
    <const name="Remote"                value="2">
      <desc>
        Remote session
        (opened by <link to="IVirtualBox::openRemoteSession()"/>)
      </desc>
    </const>
    <const name="Existing"              value="3">
      <desc>
        Existing session
        (opened by <link to="IVirtualBox::openExistingSession()"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="DeviceType"
    uuid="6d9420f7-0b56-4636-99f9-7346f1b01e57"
  >
    <desc>
      Device type.
    </desc>
    <const name="Null"              value="0">
      <desc>
        Null value, may also mean "no device" (not allowed for
        <link to="IConsole::getDeviceActivity"/>).
      </desc>
    </const>
    <const name="Floppy"            value="1">
      <desc>Floppy device.</desc>
    </const>
    <const name="DVD"               value="2">
      <desc>CD/DVD-ROM device.</desc>
    </const>
    <const name="HardDisk"          value="3">
      <desc>Hard disk device.</desc>
    </const>
    <const name="Network"           value="4">
      <desc>Network device.</desc>
    </const>
    <const name="USB"               value="5">
      <desc>USB device.</desc>
    </const>
    <const name="SharedFolder"      value="6">
      <desc>Shared folder device.</desc>
    </const>
  </enum>

  <enum
    name="DeviceActivity"
    uuid="6FC8AEAA-130A-4eb5-8954-3F921422D707"
  >
    <desc>
      Device activity for <link to="IConsole::getDeviceActivity"/>.
    </desc>

    <const name="Null"              value="0"/>
    <const name="Idle"              value="1"/>
    <const name="Reading"           value="2"/>
    <const name="Writing"           value="3"/>
  </enum>

  <enum
    name="StorageBus"
    uuid="715984a5-093c-43bb-aa42-a16ed16828dd"
  >
    <desc>Interface bus type for storage devices.</desc>

    <const name="Null"              value="0">
      <desc>Null value (never used by the API).</desc>
    </const>

    <const name="IDE"      value="1"/>
    <const name="SATA"     value="2"/>
  </enum>

  <enum
    name="ClipboardMode"
    uuid="33364716-4008-4701-8f14-be0fa3d62950"
  >
    <desc>
     Host-Guest clipboard interchange mode.
    </desc>

    <const name="Disabled"          value="0"/>
    <const name="HostToGuest"       value="1"/>
    <const name="GuestToHost"       value="2"/>
    <const name="Bidirectional"     value="3"/>
  </enum>

  <enum
    name="Scope"
    uuid="7c91096e-499e-4eca-9f9b-9001438d7855"
  >
    <desc>
      Scope of the operation.

      A generic enumeration used in various methods to define the action or
      argument scope.
    </desc>

    <const name="Global"          value="0"/>
    <const name="Machine"         value="1"/>
    <const name="Session"         value="2"/>
  </enum>

  <enum
    name="GuestStatisticType"
    uuid="aa7c1d71-aafe-47a8-9608-27d2d337cf55"
  >
    <desc>
      Statistics type for <link to="IGuest::getStatistic"/>.
    </desc>

    <const name="CPULoad_Idle"         value="0">
      <desc>
        Idle CPU load (0-100%) for last interval.
      </desc>
    </const>
    <const name="CPULoad_Kernel"       value="1">
      <desc>
        Kernel CPU load (0-100%) for last interval.
      </desc>
    </const>
    <const name="CPULoad_User"         value="2">
      <desc>
        User CPU load (0-100%) for last interval.
      </desc>
    </const>
    <const name="Threads"              value="3">
      <desc>
        Total number of threads in the system.
      </desc>
    </const>
    <const name="Processes"            value="4">
      <desc>
        Total number of processes in the system.
      </desc>
    </const>
    <const name="Handles"              value="5">
      <desc>
        Total number of handles in the system.
      </desc>
    </const>
    <const name="MemoryLoad"           value="6">
      <desc>
        Memory load (0-100%).
      </desc>
    </const>
    <const name="PhysMemTotal"         value="7">
      <desc>
        Total physical memory in megabytes.
      </desc>
    </const>
    <const name="PhysMemAvailable"     value="8">
      <desc>
        Free physical memory in megabytes.
      </desc>
    </const>
    <const name="PhysMemBalloon"       value="9">
      <desc>
        Ballooned physical memory in megabytes.
      </desc>
    </const>
    <const name="MemCommitTotal"       value="10">
      <desc>
        Total amount of memory in the committed state in megabytes.
      </desc>
    </const>
    <const name="MemKernelTotal"       value="11">
      <desc>
        Total amount of memory used by the guest OS's kernel in megabytes.
      </desc>
    </const>
    <const name="MemKernelPaged"       value="12">
      <desc>
        Total amount of paged memory used by the guest OS's kernel in megabytes.
      </desc>
    </const>
    <const name="MemKernelNonpaged"    value="13">
      <desc>
        Total amount of non-paged memory used by the guest OS's kernel in megabytes.
      </desc>
    </const>
    <const name="MemSystemCache"       value="14">
      <desc>
        Total amount of memory used by the guest OS's system cache in megabytes.
      </desc>
    </const>
    <const name="PageFileSize"         value="15">
      <desc>
        Pagefile size in megabytes.
      </desc>
    </const>
    <const name="SampleNumber"         value="16">
      <desc>
        Statistics sample number
      </desc>
    </const>
    <const name="MaxVal"               value="17"/>
  </enum>

  <enum
    name="BIOSBootMenuMode"
    uuid="ae4fb9f7-29d2-45b4-b2c7-d579603135d5"
  >
    <desc>
      BIOS boot menu mode.
    </desc>

    <const name="Disabled"        value="0"/>
    <const name="MenuOnly"        value="1"/>
    <const name="MessageAndMenu"  value="2"/>
  </enum>

  <enum
    name="IDEControllerType"
    uuid="445330e3-202a-4dab-854f-ce22e6cb9715"
  >
    <desc>
      IDE controller type.
    </desc>

    <const name="Null"            value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="PIIX3"           value="1"/>
    <const name="PIIX4"           value="2"/>
  </enum>

  <enum
    name="DriveState"
    uuid="cb7233b7-c519-42a5-8310-1830953cacbc"
  >
    <const name="Null"              value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="NotMounted"        value="1"/>
    <const name="ImageMounted"      value="2"/>
    <const name="HostDriveCaptured" value="3"/>
  </enum>

  <enum
    name="ProcessorFeature"
    uuid="b8353b35-705d-4796-9967-ebfb7ba54af4"
  >
    <desc>
      CPU features.
    </desc>

    <const name="HWVirtEx"        value="0"/>
    <const name="PAE"             value="1"/>
    <const name="LongMode"        value="2"/>
  </enum>


  <!--
  // IVirtualBoxErrorInfo
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualBoxErrorInfo" extends="$errorinfo"
     uuid="e98b5376-8eb4-4eea-812a-3964bf3bb26f"
     supportsErrorInfo="no"
     wsmap="suppress"
     >
    <desc>
      The IVirtualBoxErrorInfo interface represents extended error information.

      Extended error information can be set by VirtualBox components after
      unsuccessful or partially successful method invocation. This information
      can be retrieved by the calling party as an IVirtualBoxErrorInfo object
      and then shown to the client in addition to the plain 32-bit result code.

      In MS COM, this interface extends the IErrorInfo interface,
      in XPCOM, it extends the nsIException interface. In both cases,
      it provides a set of common attributes to retrieve error
      information.

      Sometimes invocation of some component's method may involve methods of
      other components that may also fail (independently of this method's
      failure), or a series of non-fatal errors may precede a fatal error that
      causes method failure. In cases like that, it may be desirable to preserve
      information about all errors happened during method invocation and deliver
      it to the caller. The <link to="#next"/> attribute is intended
      specifically for this purpose and allows to represent a chain of errors
      through a single IVirtualBoxErrorInfo object set after method invocation.

      Note that errors are stored to a chain in the reverse order, i.e. the
      initial error object you query right after method invocation is the last
      error set by the callee, the object it points to in the @a next attribute
      is the previous error and so on, up to the first error (which is the last
      in the chain).
    </desc>

    <attribute name="resultCode" type="result" readonly="yes">
      <desc>
        Result code of the error.
        Usually, it will be the same as the result code returned
        by the method that provided this error information, but not
        always. For example, on Win32, CoCreateInstance() will most
        likely return E_NOINTERFACE upon unsuccessful component
        instantiation attempt, but not the value the component factory
        returned.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::result.
        </note>
      </desc>
    </attribute>

    <attribute name="interfaceID" type="uuid" readonly="yes">
      <desc>
        UUID of the interface that defined the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetGUID.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="component" type="wstring" readonly="yes">
      <desc>
        Name of the component that generated the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetSource.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="text" type="wstring" readonly="yes">
      <desc>
        Text description of the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetDescription.
          In XPCOM, it is the same as nsIException::message.
        </note>
      </desc>
    </attribute>

    <attribute name="next" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Next error object if there is any, or @c null otherwise.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::inner.
        </note>
      </desc>
    </attribute>

  </interface>


  <!--
  // IVirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualBoxCallback" extends="$unknown"
     uuid="5516cc08-fb81-47a6-b184-031e7bbd2997"
     wsmap="suppress"
     >
    <method name="onMachineStateChange">
      <desc>
        The execution state of the given machine has changed.
        <see>IMachine::state</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="state" type="MachineState" dir="in">
        <desc>New execution state.</desc>
      </param>
    </method>

    <method name="onMachineDataChange">
      <desc>
        Any of the settings of the given machine has changed.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
    </method>

    <method name="onExtraDataCanChange">
      <desc>
        Notification when someone tries to change extra data for
        either the given machine or (if null) global extra data.
        This gives the chance to veto against changes.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>
          ID of the machine this event relates to
          (null ID for global extra data change requests).
        </desc>
      </param>
      <param name="key" type="wstring" dir="in">
        <desc>
          Extra data key for the attempted write.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          Extra data value for the given key.
        </desc>
      </param>
      <param name="error" type="wstring" dir="out">
        <desc>
          Optional error message describing the reason of the
          veto (ignored if this notification returns @c true).
        </desc>
      </param>
      <param name="allowChange" type="boolean" dir="return">
        <desc>
          Flag to indicate whether the callee agrees (@c true)
          or vetoes against the change (@c false).
        </desc>
      </param>
    </method>

    <method name="onExtraDataChange">
      <desc>
        Notification when machine specific or global extra data
        has changed.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>
          ID of the machine this event relates to.
          Null for global extra data changes.
        </desc>
      </param>
      <param name="key" type="wstring" dir="in">
        <desc>
          Extra data key that has changed.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          Extra data value for the given key.
        </desc>
      </param>
    </method>

    <method name="onMediaRegistered">
      <desc>
        The given media was registered or unregistered
        within this VirtualBox installation.

        The @a mediaType parameter describes what type of
        media the specified @a mediaId refers to. Possible
        values are:

        <ul>
        <li><link to="DeviceType_HardDisk"/>: the media is a hard disk
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getHardDisk2()"/> call.</li>
        <li><link to="DeviceType_DVD"/>: the media is a CD/DVD image
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getDVDImage()"/> call.</li>
        <li><link to="DeviceType_Floppy"/>: the media is a Floppy image
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getFloppyImage()"/> call.</li>
        </ul>

        Note that if this is a deregistration notification,
        there is no way to access the object representing the
        unregistered media. It is supposed that the
        application will do required cleanup based on the @a
        mediaId value.
      </desc>
      <param name="mediaId" type="uuid" dir="in">
        <desc>ID of the media this event relates to.</desc>
      </param>
      <param name="mediaType" type="DeviceType" dir="in">
        <desc>Type of the media this event relates to.</desc>
      </param>
      <param name="registered" type="boolean" dir="in">
        <desc>
          If true, the media was registered, otherwise it was
          unregistered.
        </desc>
      </param>
    </method>

    <method name="onMachineRegistered">
      <desc>
        The given machine was registered or unregistered
        within this VirtualBox installation.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="registered" type="boolean" dir="in">
        <desc>
          If true, the machine was registered, otherwise it was
          unregistered.
        </desc>
      </param>
    </method>

    <method name="onSessionStateChange">
      <desc>
        The state of the session for the given machine was changed.
        <see>IMachine::sessionState</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="state" type="SessionState" dir="in">
        <desc>New session state.</desc>
      </param>
    </method>

    <method name="onSnapshotTaken">
      <desc>
        A new snapshot of the machine has been taken.
        <see>ISnapshot</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" dir="in">
        <desc>ID of the new snapshot.</desc>
      </param>
    </method>

    <method name="onSnapshotDiscarded">
      <desc>
        Snapshot of the given machine has been discarded.

        <note>
          This notification is delivered <b>after</b> the snapshot
          object has been uninitialized on the server (so that any
          attempt to call its methods will return an error).
        </note>

        <see>ISnapshot</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" dir="in">
        <desc>
          ID of the discarded snapshot. <tt>null</tt> means the
          current machine state has been discarded (restored from
          the current snapshot).
        </desc>
      </param>
    </method>

    <method name="onSnapshotChange">
      <desc>
        Snapshot properties (name and/or description) have been changed.
        <see>ISnapshot</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" dir="in">
        <desc>ID of the changed snapshot.</desc>
      </param>
    </method>

    <method name="onGuestPropertyChange">
      <desc>
        Notification when a guest property has changed.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>
          ID of the machine this event relates to.
        </desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property that has changed.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new property value.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          The new property flags.
        </desc>
      </param>
    </method>

  </interface>

  <interface
    name="IVirtualBox" extends="$dispatched"
    uuid="339abca2-f47a-4302-87f5-7bc324e6bbde"
    wsmap="managed"
  >
    <desc>
      The IVirtualBox interface represents the main interface exposed by the
      product that provides virtual machine management.

      An instance of IVirtualBox is required for the product to do anything
      useful. Even though the interface does not expose this, internally,
      IVirtualBox is implemented as a singleton and actually lives in the
      process of the VirtualBox server (VBoxSVC.exe). This makes sure that
      IVirtualBox can track the state of all virtual machines on a particular
      host, regardless of which frontend started them.

      To enumerate all the virtual machines on the host, use the
      <link to="IVirtualBox::machines2"/> attribute.
    </desc>

    <attribute name="version" type="wstring" readonly="yes">
      <desc>
        A string representing the version number of the product. The
        format is 3 integer numbers divided by dots (e.g. 1.0.1). The
        last number represents the build number and will frequently change.
      </desc>
    </attribute>

    <attribute name="revision" type="unsigned long" readonly="yes">
      <desc>
        The internal build revision number of the product.
      </desc>
    </attribute>

    <attribute name="packageType" type="wstring" readonly="yes">
      <desc>
        A string representing the package type of this product. The
        format is OS_ARCH_DIST where OS is either WINDOWS, LINUX,
        SOLARIS, DARWIN. ARCH is either 32BITS or 64BITS. DIST
        is either GENERIC, UBUNTU_606, UBUNTU_710, or something like
        this.
      </desc>
    </attribute>

    <attribute name="homeFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the directory where the global settings file,
        <tt>VirtualBox.xml</tt>, is stored.

        In this version of VirtualBox, the value of this property is
        always <tt>&lt;user_dir&gt;/.VirtualBox</tt> (where
        <tt>&lt;user_dir&gt;</tt> is the path to the user directory,
        as determined by the host OS), and cannot be changed.

        This path is also used as the base to resolve relative paths in
        places where relative paths are allowed (unless otherwise
        expressly indicated).
      </desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the global settings file.
        The value of this property corresponds to the value of
        <link to="#homeFolder"/> plus <tt>/VirtualBox.xml</tt>.
      </desc>
    </attribute>

    <attribute name="settingsFileVersion" type="wstring" readonly="yes">
      <desc>
        Current version of the format of the global VirtualBox settings file
        (<tt>VirtualBox.xml</tt>).

        The version string has the following format:
        <pre>
          x.y-platform
        </pre>
        where <tt>x</tt> and <tt>y</tt> are the major and the minor format
        versions, and <tt>platform</tt> is the platform identifier.

        The current version usually matches the value of the
        <link to="#settingsFormatVersion"/> attribute unless the
        settings file was created by an older version of VirtualBox and there
        was a change of the settings file format since then.

        Note that VirtualBox automatically converts settings files from older
        versions to the most recent version when reading them (usually at
        VirtualBox startup) but it doesn't save the changes back until
        you call a method that implicitly saves settings (such as
        <link to="#setExtraData()"/>) or call <link to="#saveSettings()"/>
        explicitly. Therefore, if the value of this attribute differs from the
        value of <link to="#settingsFormatVersion"/>, then it
        means that the settings file was converted but the result of the
        conversion is not yet saved to disk.

        The above feature may be used by interactive front-ends to inform users
        about the settings file format change and offer them to explicitly save
        all converted settings files (the global and VM-specific ones),
        optionally create backup copies of the old settings files before saving,
        etc.

        <see>settingsFormatVersion, saveSettingsWithBackup()</see>
      </desc>
    </attribute>

    <attribute name="settingsFormatVersion" type="wstring" readonly="yes">
      <desc>
        Most recent version of the settings file format.

        The version string has the following format:
        <pre>
          x.y-platform
        </pre>
        where <tt>x</tt> and <tt>y</tt> are the major and the minor format
        versions, and <tt>platform</tt> is the platform identifier.

        VirtualBox uses this version of the format when saving settings files
        (either as a result of method calls that require to save settings or as
        a result of an explicit call to <link to="#saveSettings()"/>).

        <see>settingsFileVersion</see>
      </desc>
    </attribute>

    <attribute name="host" type="IHost" readonly="yes">
      <desc>Associated host object.</desc>
    </attribute>

    <attribute name="systemProperties" type="ISystemProperties" readonly="yes">
      <desc>Associated system information object.</desc>
    </attribute>

    <attribute name="machines2" type="IMachine" readonly="yes" safearray="yes">
      <desc>
        Array of machine objects registered within this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="hardDisks2" type="IHardDisk2" readonly="yes" safearray="yes">
      <desc>
        Array of hard disk objects known to this VirtualBox installation.

        This array contains only base (root) hard disks. All differencing
        hard disks of the given base hard disk can be enumerated using
        <link to="IHardDisk2::children"/>.
      </desc>
    </attribute>

    <attribute name="DVDImages" type="IDVDImage2" readonly="yes" safearray="yes">
      <desc>
        Array of CD/DVD image objects registered with this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="floppyImages" type="IFloppyImage2" readonly="yes" safearray="yes">
      <desc>
        Array of floppy image objects registered with this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="progressOperations" type="IProgressCollection" readonly="yes"/>

    <attribute name="guestOSTypes" type="IGuestOSTypeCollection" readonly="yes"/>

    <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
      <desc>
        Collection of global shared folders. Global shared folders are
        available to all virtual machines.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.

        <note>
          In the current version of the product, global shared folders are not
          implemented and therefore this collection is always empty.
        </note>
      </desc>
    </attribute>

    <attribute name="performanceCollector" type="IPerformanceCollector" readonly="yes">
      <desc>
        Associated performance collector object.
      </desc>
    </attribute>

    <method name="createMachine">
      <desc>
        Creates a new virtual machine.

        The new machine is created unregistered, with the initial configuration
        set according to the specified guest OS type. A typical sequence of
        actions to create a new virtual machine is as follows:

        <ol>
          <li>
            Call this method to have a new machine created. The returned machine
            object will be "mutable" allowing to change any machine property.
          </li>

          <li>
            Configure the machine using the appropriate attributes and methods.
          </li>

          <li>
            Call <link to="IMachine::saveSettings()" /> to write the settings
            to the machine's XML settings file. The configuration of the newly
            created machine will not be saved to disk until this method is
            called.
          </li>

          <li>
            Call <link to="#registerMachine()" /> to add the machine to the list
            of machines known to VirtualBox.
          </li>
        </ol>

        You should specify valid name for the newly created machine when calling
        this method. See the <link to="IMachine::name"/> attribute description
        for more details about the machine name.

        The specified guest OS type identifier must match an ID of one of known
        guest OS types listed in the <link to="IVirtualBox::guestOSTypes"/>
        array.

        Every machine has a <i>settings file</i> that is used to store
        the machine configuration. This file is stored in a directory called the
        <i>machine settings subfolder</i>. Both the settings subfolder and file
        will have a name that corresponds to the name of the virtual machine.
        You can specify where to create the machine setting subfolder using the
        @a baseFolder argument. The base folder can be absolute (full path) or
        relative to the <link to="IVirtualBox::homeFolder">VirtualBox home
        directory</link>.

        If @a baseFolder is a null or empty string (which is recommended), the
        <link to="ISystemProperties::defaultMachineFolder">default machine
        settings folder</link> will be used as a base folder for the created
        machine. Otherwise the given base folder will be used. In either case,
        the full path to the resulting settings file has the following
        structure:
        <pre>
          &lt;base_folder&gt;/&lt;machine_name&gt;/&lt;machine_name&gt;.xml
        </pre>

        Note that if the resulting settings file already exists, this method
        will fail with <link to="VBOX_E_FILE_ERROR"/>.

        Optionally, you may specify an UUID of to assign to the created machine.
        However, this is not recommended and you should normally pass an empty
        (null) UUID to this method so that a new UUID will be automatically
        generated for every created machine.

        <note>
          There is no way to change the name of the settings file or
          subfolder of the created machine directly.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a osTypeId is invalid.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Resulting settings file name is invalid or the settings file already
          exists or could not be created due to an I/O error.
        </result>
        <result name="E_INVALIDARG">
          @a name is empty or null.
        </result>
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="osTypeId" type="wstring" dir="in">
        <desc>Guest OS Type ID.</desc>
      </param>
      <param name="baseFolder" type="wstring" dir="in">
        <desc>Base machine folder (optional).</desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>Machine UUID (optional).</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="createLegacyMachine">
      <desc>
        Creates a new virtual machine in "legacy" mode, using the specified
        settings file to store machine settings.

        As opposed to machines created by <link to="#createMachine()"/>,
        the settings file of the machine created in "legacy" mode is not
        automatically renamed when the machine name is changed -- it will always
        remain the same as specified in this method call.

        The specified settings file name can be absolute (full path) or relative
        to the <link to="IVirtualBox::homeFolder">VirtualBox home
        directory</link>. If the file name doesn't contain an extension, the
        default extension (.xml) will be appended.

        Note that the configuration of the newly created machine is not
        saved to disk (and therefore no settings file is created)
        until <link to="IMachine::saveSettings()"/> is called. If the
        specified settings file already exists, this method
        will fail with <link to="VBOX_E_FILE_ERROR"/>..

        See <link to="#createMachine()"/> for more information.

        @deprecated This method may be removed later. Use <link
        to="IVirtualBox::createMachine()"/> instead.

        <note>
          There is no way to change the name of the settings file
          of the machine created in "legacy" mode.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a osTypeId is invalid.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          @a settingsFile is invalid or the settings file already exists or
          could not be created due to an I/O error.
        </result>
        <result name="E_INVALIDARG">
          @a name or @a settingsFile is empty or null.
        </result>
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="osTypeId" type="wstring" dir="in">
        <desc>Machine OS Type ID.</desc>
      </param>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>Name of the machine settings file.</desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>Machine UUID (optional).</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="openMachine">
      <desc>
        Opens a virtual machine from the existing settings file.
        The opened machine remains unregistered until you call
        <link to="#registerMachine()"/>.

        The specified settings file name can be absolute
        (full path) or relative to the <link to="IVirtualBox::homeFolder">
          VirtualBox home directory</link>. This file must exist
        and must be a valid machine settings file whose contents
        will be used to construct the machine object.

        @deprecated Will be removed soon.
        <result name="VBOX_E_FILE_ERROR">
          Settings file name invalid, not found or sharing violation.
        </result>
      </desc>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>
          Name of the machine settings file.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Opened machine object.</desc>
      </param>
      <note>
        <link to="IMachine::settingsModified"/> will return
        false for the created machine, until any of machine settings
        are changed.
      </note>
    </method>

    <method name="registerMachine">
      <desc>

        Registers the machine previously created using
        <link to="#createMachine()"/> or opened using
        <link to="#openMachine()"/> within this VirtualBox installation. After
        successful method invocation, the
        <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
        to all registered callbacks.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/>
          to save all current machine settings before registering it.
        </note>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Virtual machine was not created within this VirtualBox instance.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="getMachine">
      <desc>
        Attempts to find a virtual machine given its UUID.
        To look up a machine by name, use <link to="IVirtualBox::findMachine" />
        instead.

        <result name="VBOX_E_FILE_ERROR">
          Could not find registered machine matching @a id.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in"/>
      <param name="machine" type="IMachine" dir="return"/>
    </method>

    <method name="findMachine">
      <desc>
        Attempts to find a virtual machine given its name.
        To look up a machine by UUID, use <link to="IVirtualBox::getMachine" />
        instead.

        <result name="VBOX_E_FILE_ERROR">
          Could not find registered machine matching @a name.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="machine" type="IMachine" dir="return"/>
    </method>

    <method name="unregisterMachine">
      <desc>

        Unregisters the machine previously registered using
        <link to="#registerMachine"/>. After successful method invocation, the
        <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
        to all registered callbacks.

        <note>
          The specified machine must not be in the Saved state, have an open
          (or a spawning) direct session associated with it, have snapshots or
          have hard disks attached.
        </note>

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/> to
          save all current machine settings before unregistering it.
        </note>

        <note>
          If the given machine is inaccessible (see
          <link to="IMachine::accessible"/>), it will be unregistered and
          fully uninitialized right afterwards. As a result, the returned
          machine object will be unusable and an attempt to call
          <b>any</b> method will return the "Object not ready" error.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Could not find registered machine matching @a id.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Machine is in Saved state.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Machine has snapshot or open session or hard disk attached.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the machine to unregister.</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Unregistered machine object.</desc>
      </param>
    </method>

    <method name="createHardDisk2">
      <desc>
        Creates a new base hard disk object that will use the given storage
        format and location for hard disk data.

        Note that the actual storage unit is not created by this method. In
        order to do it, and before you are able to attach the created hard disk
        to virtual machines, you must call one of the following methods to
        allocate a format-specific storage unit at the specified location:
        <ul>
          <li><link to="IHardDisk2::createDynamicStorage()"/></li>
          <li><link to="IHardDisk2::createFixedStorage()"/></li>
          <li><link to="IHardDisk2::createDiffStorage()"/></li>
        </ul>

        Some hard disk attributes, such as <link to="IHardDisk2::id"/>, may
        remain uninitialized until the hard disk storage unit is successfully
        created by one of the above methods.

        After the storage unit is successfully created, the hard disk gets
        remembered by this VirtualBox installation and will be accessible
        through <link to="#getHardDisk2()"/> and <link to="#findHardDisk2()"/>
        methods. Remembered root (base) hard disks are also returned as part of
        the <link to="#hardDisks2"/> array. See IHardDisk2 for more details.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        <link to="ISystemProperties::hardDiskFormats"/>. If the @a format
        attribute is empty or <tt>null</tt> then the default storage format
        specified by <link to="ISystemProperties::defaultHardDiskFormat"/> will
        be used for creating a storage unit of the hard disk.

        Note that the format of the location string is storage format specific.
        See <link to="IMedium::location"/>, IHardDisk2 and
        <link to="ISystemProperties::defaultHardDiskFolder"/> for more details.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a format identifier is invalid. See
          <link to="ISystemProperties::hardDiskFormats"/>.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          @a location is a not valid file name (for file-based formats only).
        </result>
        <result name="E_INVALIDARG">
          @a format is a null or empty string.
        </result>
      </desc>
      <param name="format" type="wstring" dir="in">
        <desc>
          Identifier of the storage format to use for the new hard disk.
        </desc>
      </param>
      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the storage unit for the new hard disk.
        </desc>
      </param>
      <param name="hardDisk" type="IHardDisk2" dir="return">
        <desc>Created hard disk object.</desc>
      </param>
    </method>

    <method name="openHardDisk2">
      <desc>
        Opens a hard disk from an existing location.

        After the hard disk is successfully opened by this method, it gets
        remembered by (known to) this VirtualBox installation and will be
        accessible through <link to="#getHardDisk2()"/> and
        <link to="#findHardDisk2()"/> methods. Remembered root (base) hard disks
        are also returned as part of the <link to="#hardDisks2"/> array and can
        be attached to virtual machines. See IHardDisk2 for more details.

        If a differencing hard disk is to be opened by this method, the
        operation will succeed only if its parent hard disk and all ancestors,
        if any, are already known to this VirtualBox installation (for example,
        were opened by this method before).

        This method tries to guess the storage format of the specified hard disk
        by reading hard disk data at the specified location.

        Note that the format of the location string is storage format specific.
        See <link to="IMedium::location"/>, IHardDisk2 and
        <link to="ISystemProperties::defaultHardDiskFolder"/> for more details.


        <result name="VBOX_E_FILE_ERROR">
          Invalid hard disk storage file location.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not get hard disk storage format.
        </result>
        <result name="E_INVALIDARG">
          Invalid hard disk storage format.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the storage unit that contains hard disk data in one of
          the supported storage formats.
        </desc>
      </param>
      <param name="hardDisk" type="IHardDisk2" dir="return">
        <desc>Opened hard disk object.</desc>
      </param>
    </method>

    <method name="getHardDisk2" const="yes">
      <desc>
        Returns a hard disk with the given UUID.

        The hard disk with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously created by
        <link to="#createHardDisk2()"/> or opened by <link
        to="#openHardDisk2()"/>, or attached to some known virtual machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No hard disk object matching @a id found.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the hard disk to look for.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk2" dir="return">
        <desc>Found hard disk object.</desc>
      </param>
    </method>

    <method name="findHardDisk2">
      <desc>
        Returns a hard disk that uses the given location to store hard
        disk data.

        The given hard disk must be known to this VirtualBox installation, i.e.
        it must be previously created by
        <link to="#createHardDisk2()"/> or opened by <link
        to="#openHardDisk2()"/>, or attached to some known virtual machine.

        The search is done by comparing the value of the @a location argument to
        the <link to="IHardDisk2::location"/> attribute of each known hard
        disk.

        For locations represented by file names in the host's file system, the
        requested location can be a path relative to the
        <link to="IVirtualBox::homeFolder">VirtualBox home folder</link>. If
        only a file name without any path is given, the
        <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
        folder</link> will be prepended to the file name before searching. Note
        that on case sensitive file systems, a case sensitive comparison is
        performed, otherwise the case of symbols in the file path is ignored.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No hard disk object matching @a location found.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>Location string to search for.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk2" dir="return">
        <desc>Found hard disk object.</desc>
      </param>
    </method>

    <method name="openDVDImage">
      <desc>
        Opens a CD/DVD image contained in the specified file of the supported
        format and assigns it the given UUID.

        After the image is successfully opened by this method, it gets
        remembered by (known to) this VirtualBox installation and will be
        accessible through <link to="#getDVDImage()"/> and
        <link to="#findDVDImage()"/> methods. Remembered images are also
        returned as part of the <link to="#DVDImages"/> array and can be mounted
        to virtual machines. See IMedium for more details.

        See <link to="IMedium::location"/> to get more details about the format
        of the location string.

        <note>
          Currently only ISO 9960 CD/DVD images are supported by VirtualBox.
        </note>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          CD/DVD image already exists in the media registry.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Full path to the file that contains a valid CD/DVD image.
        </desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>
          UUID to assign to the given image within this VirtualBox installation.
          If an empty (null) UUID is specified, the system will randomly
          generate a new UUID.
        </desc>
      </param>
      <param name="image" type="IDVDImage2" dir="return">
        <desc>Opened CD/DVD image object.</desc>
      </param>
    </method>

    <method name="getDVDImage">
      <desc>
        Returns a CD/DVD image with the given UUID.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openDVDImage()"/>, or mounted to some known virtual machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching DVD image found in the media registry.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the image to look for.</desc>
      </param>
      <param name="image" type="IDVDImage2" dir="return">
        <desc>Found CD/DVD image object.</desc>
      </param>
    </method>

    <method name="findDVDImage">
      <desc>
        Returns a CD/DVD image with the given image location.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openDVDImage()"/>, or mounted to some known virtual machine.

        The search is done by comparing the value of the @a location argument to
        the <link to="IMedium::location"/> attribute of each known CD/DVD image.

        The requested location can be a path relative to the
        <link to="IVirtualBox::homeFolder">VirtualBox home folder</link>. If
        only a file name without any path is given, the
        <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
        folder</link> will be prepended to the file name before searching. Note
        that on case sensitive file systems, a case sensitive comparison is
        performed, otherwise the case in the file path is ignored.

        <result name="VBOX_E_FILE_ERROR">
          Invalid image file location.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching DVD image found in the media registry.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>CD/DVD image file path to look for.</desc>
      </param>
      <param name="image" type="IDVDImage2" dir="return">
        <desc>Found CD/DVD image object.</desc>
      </param>
    </method>

    <method name="openFloppyImage">
      <desc>
        Opens a floppy image contained in the specified file of the supported
        format and assigns it the given UUID.

        After the image is successfully opened by this method, it gets
        remembered by (known to) this VirtualBox installation and will be
        accessible through <link to="#getFloppyImage()"/> and
        <link to="#findFloppyImage()"/> methods. Remembered images are also
        returned as part of the <link to="#floppyImages"/> array and can be
        mounted to virtual machines. See IMedium for more details.

        See <link to="IMedium::location"/> to get more details about the format
        of the location string.

        <result name="VBOX_E_FILE_ERROR">
          Floppy image specified by @a location not accessible.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Floppy image already exists in the media registry.
        </result>

        <note>
          Currently, only raw floppy images are supported by VirtualBox.
        </note>
      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Full path to the file that contains a valid floppy image.
        </desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>
          UUID to assign to the given image file within this VirtualBox
          installation. If an empty (null) UUID is specified, the system will
          randomly generate a new UUID.
        </desc>
      </param>
      <param name="image" type="IFloppyImage2" dir="return">
        <desc>Opened floppy image object.</desc>
      </param>
    </method>

    <method name="getFloppyImage">
      <desc>
        Returns a floppy image with the given UUID.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openFloppyImage()"/>, or mounted to some known virtual machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching floppy image found in the media registry.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the image to look for.</desc>
      </param>
      <param name="image" type="IFloppyImage2" dir="return">
        <desc>Found floppy image object.</desc>
      </param>
    </method>

    <method name="findFloppyImage">
      <desc>
        Returns a floppy image with the given image location.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openFloppyImage()"/>, or mounted to some known virtual machine.

        The search is done by comparing the value of the @a location argument to
        the <link to="IMedium::location"/> attribute of each known floppy image.

        The requested location can be a path relative to the
        <link to="IVirtualBox::homeFolder">VirtualBox home folder</link>. If
        only a file name without any path is given, the
        <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
        folder</link> will be prepended to the file name before searching. Note
        that on case sensitive file systems, a case sensitive comparison is
        performed, otherwise the case of symbols in the file path is ignored.

        <result name="VBOX_E_FILE_ERROR">
          Invalid image file location.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching floppy image found in the media registry.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>Floppy image file path to look for.</desc>
      </param>
      <param name="image" type="IFloppyImage2" dir="return">
        <desc>Found floppy image object.</desc>
      </param>
    </method>

    <method name="getGuestOSType">
      <desc>
        Returns an object describing the specified guest OS type.

        The requested guest OS type is specified using a string which is a
        mnemonic identifier of the guest operating system, such as
        <tt>"win31"</tt> or <tt>"ubuntu"</tt>. The guest OS type ID of a
        particular virtual machine can be read or set using the
        <link to="IMachine::OSTypeId"/> attribute.

        The <link to="IVirtualBox::guestOSTypes"/> collection contains all
        available guest OS type objects. Each object has an
        <link to="IGuestOSType::id"/> attribute which contains an identifier of
        the guest OS this object describes.

        <result name="E_INVALIDARG">
          @a id is not a valid Guest OS type.
        </result>

      </desc>
      <param name="id" type="wstring" dir="in">
        <desc>Guest OS type ID string.</desc>
      </param>
      <param name="type" type="IGuestOSType" dir="return">
        <desc>Guest OS type object.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new global shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the global shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="getNextExtraDataKey">
      <desc>
        Returns the global extra data key name following the supplied key.

        An error is returned if the supplied @a key does not exist. @c NULL is
        returned in @a nextKey if the supplied key is the last key. When
        supplying @c NULL for the @a key, the first key item is returned in @a
        nextKey (if there is any). @a nextValue is an optional parameter and
        if supplied, the next key's value is returned in it.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Extra data @a key not found.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to follow.</desc>
      </param>
      <param name="nextKey" type="wstring" dir="out">
        <desc>Name of the next data key.</desc>
      </param>
      <param name="nextValue" type="wstring" dir="out">
        <desc>Value of the next data key.</desc>
      </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated global extra data.

        If the requested data @a key does not exist, this function will
        succeed and return @c NULL in the @a value argument.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated global extra data.

        If you pass @c NULL as a key @a value, the given @a key will be
        deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered callbacks using the
          <link to="IVirtualBoxCallback::onExtraDataCanChange()"/>
          notification for a permission. If one of the callbacks refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IVirtualBoxCallback::onExtraDataChange()"/> notification
          is called to inform all registered callbacks about a successful data
          change.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="openSession">
      <desc>
        Opens a new direct session with the given virtual machine.

        A direct session acts as a local lock on the given VM.
        There can be only one direct session open at a time for every
        virtual machine, protecting the VM from being manipulated by
        conflicting actions from different processes. Only after a
        direct session has been opened, one can change all VM settings
        and execute the VM in the process space of the session object.

        Sessions therefore can be compared to mutex semaphores that
        lock a given VM for modification and execution.
        See <link to="ISession">ISession</link> for details.

        <note>Unless you are writing a new VM frontend, you will not
        want to execute a VM in the current process. To spawn a new
        process that executes a VM, use
        <link to="IVirtualBox::openRemoteSession" />
        instead.</note>

        Upon successful return, the session object can be used to
        get access to the machine and to the VM console.

        In VirtualBox terminology, the machine becomes "mutable" after
        a session has been opened. Note that the "mutable" machine
        object, on which you may invoke IMachine methods to change its
        settings, will be a different object from the immutable IMachine
        objects returned by various IVirtualBox methods. To obtain a
        mutable IMachine object (upon which you can invoke settings methods),
        use the <link to="ISession::machine" /> attribute.

        One must always call <link to="ISession::close" /> to release the
        lock on the machine, or the machine's state will eventually be
        set to "Aborted".

        In other words, to change settings on a machine, the following
        sequence is typically performed:

        <ol>
        <li>Call this method (openSession) to have a machine locked for
        the current session.</li>

        <li>Obtain a mutable IMachine object from <link to="ISession::machine" />.</li>

        <li>Change the settings of the machine.</li>

        <li>Call <link to="IMachine::saveSettings" />.</li>

        <li>Close the session by calling <link to="ISession::close()"/>.</li>
        </ol>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="E_ACCESSDENIED">
          Process not started by OpenRemoteSession.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to assign machine to session.
        </result>

      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the opened session after
          successful method invocation. This object must not represent
          the already open session.
          <note>
            This session will be automatically closed if the
            VirtualBox server is terminated for some reason.
          </note>
        </desc>
      </param>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
    </method>

    <method name="openRemoteSession">
      <desc>
        Spawns a new process that executes a virtual machine (called a
        "remote session").

        Opening a remote session causes the VirtualBox server to start a new
        process that opens a direct session with the given VM. As a result, the
        VM is locked by that direct session in the new process, preventing
        conflicting changes from other processes. Since sessions act as locks
        that such prevent conflicting changes, one cannot open a remote session
        for a VM that already has another open session (direct or remote), or
        is currently in the process of opening one (see <link
          to="IMachine::sessionState"/>).

        While the remote session still provides some level of control over the
        VM execution to the caller (using the <link to="IConsole" /> interface),
        not all VM settings are available for modification within the remote
        session context.

        This operation can take some time (a new VM is started in a new process,
        for which memory and other resources need to be set up). Because of this,
        an <link to="IProgress" /> is returned to allow the caller to wait for this
        asynchronous operation to be completed. Until then, the remote session
        object remains in the closed state, and accessing the machine or its
        console through it is invalid. It is recommended to use
        <link to="IProgress::waitForCompletion" /> or similar calls to wait for
        completion.

        As with all <link to="ISession" /> objects, it is recommended to call
        <link to="ISession::close" /> on the local session object once openRemoteSession()
        has been called. However, the session's state (see <link to="ISession::state" />)
        will not return to "Closed" until the remote session has also closed (i.e.
        until the VM is no longer running). In that case, however, the state of
        the session will automatically change back to "Closed".

        Currently supported session types (values of the @a type
        argument) are:
        <ul>
          <li><tt>gui</tt>: VirtualBox Qt GUI session</li>
          <li><tt>vrdp</tt>: VirtualBox VRDP Server session</li>
        </ul>

        The @a environment argument is a string containing definitions of
        environment variables in the following format:
        @code
          NAME[=VALUE]\n
          NAME[=VALUE]\n
          ...
        @endcode
        where <tt>\\n</tt> is the new line character. These environment
        variables will be appended to the environment of the VirtualBox server
        process. If an environment variable exists both in the server process
        and in this list, the value from this list takes precedence over the
        server's variable. If the value of the environment variable is
        omitted, this variable will be removed from the resulting environment.
        If the environment string is @c null, the server environment is
        inherited by the started process as is.

        <see>openExistingSession</see>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="E_INVALIDARG">
          Invalid session type @a type.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No machine matching @a machineId found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Launching process for machine failed.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to assign machine to session.
        </result>

      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the opened remote session
          after successful method invocation (this object must not
          represent an already open session).
        </desc>
      </param>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
      <param name="type" type="wstring" dir="in">
        <desc>
          Type of the remote session (case sensitive).
        </desc>
      </param>
      <param name="environment" type="wstring" dir="in">
        <desc>
          Environment to pass to the opened session (may be @c null).
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="openExistingSession">
      <desc>
        Opens a new remote session with the virtual machine for
        which a direct session is already open.

        The remote session provides some level of control over the VM
        execution (using the IConsole interface) to the caller; however,
        within the remote session context, not all VM settings are available
        for modification.

        As opposed to <link to="#openRemoteSession()"/>, the number of
        remote sessions opened this way is not limited by the API

        <note>
          It is an error to open a remote session with the machine that
          doesn't have an open direct session.
        </note>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No machine matching @a machineId found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_INVALID_SESSION_STATE">
          Direct session state not Open.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to get console object from direct session or assign
          machine to session.
        </result>

        <see>openRemoteSession</see>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the open remote session
          after successful method invocation. This object must not
          represent an already open session.
          <note>
            This session will be automatically closed when the peer
            (direct) session dies or gets closed.
          </note>
        </desc>
      </param>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
    </method>

    <method name="registerCallback">
      <desc>
        Registers a new global VirtualBox callback. The methods of the given
        callback object will be called by VirtualBox when an appropriate
        event occurs.

        <result name="E_INVALIDARG">
          Registering a @c NULL @a callback is pretty pointless, ain't it?
          <!-- See if someone is actually reading this and objects :-) -->
        </result>

      </desc>
      <param name="callback" type="IVirtualBoxCallback" dir="in">
        <desc>Callback object to register.</desc>
      </param>
    </method>

    <method name="unregisterCallback">
      <desc>
        Unregisters the previously registered global VirtualBox callback.

        <result name="E_INVALIDARG">
          Specified @a callback not registered.
        </result>

      </desc>
      <param name="callback" type="IVirtualBoxCallback" dir="in">
        <desc>Callback object to unregister.</desc>
      </param>
    </method>

    <method name="waitForPropertyChange">
      <desc>
        Blocks the caller until any of the properties represented by the @a
        what argument changes the value or until the given timeout interval
        expires.

        The @a what argument is a comma separated list of property masks that
        describe properties the caller is interested in. The property mask is
        a string in the following format:

        <pre>
        [[group.]subgroup.]name
        </pre>

        where @c name is the property name and @c group, @c subgroup are zero
        or more property group specifiers. Each element (group or name) in
        the property mask may be either a Latin string or an asterisk symbol
        (@c "*") which is used to match any string for the given element. A
        property mask that doesn't contain asterisk symbols represents a
        single fully qualified property name.

        Groups in the fully qualified property name go from more generic (the
        left-most part) to more specific (the right-most part). The first
        element is usually a name of the object the property belongs to.  The
        second element may be either a property name, or a child object name,
        or an index if the preceding element names an object which is one of
        many objects of the same type. This way, property names form a
        hierarchy of properties.  Here are some examples of property names:

        <table>
          <tr>
            <td><tt>VirtualBox.version</tt></td>
            <td><link to="IVirtualBox::version"/> property</td>
          </tr>
          <tr>
            <td><tt>Machine.&lt;UUID&gt;.name</tt></td>
            <td><link to="IMachine::name"/> property of the machine with the
            given UUID</td>
            </tr>
        </table>

        Most property names directly correspond to the properties of objects
        (components) provided by the VirtualBox library and may be used to
        track changes to these properties. However, there may be
        pseudo-property names that don't correspond to any existing object's
        property directly, as well as there may be object properties that
        don't have a corresponding property name that is understood by this
        method, and therefore changes to such properties cannot be
        tracked. See individual object's property descriptions to get a
        fully qualified property name that can be used with this method (if
        any).

        There is a special property mask @c "*" (i.e. a string consisting of a
        single asterisk symbol) that can be used to match all properties.
        Below are more examples of property masks:

        <table>
          <tr>
            <td><tt>VirtualBox.*</tt></td>
            <td>Track all properties of the VirtualBox object</td>
          </tr>
          <tr>
            <td><tt>Machine.*.name</tt></td>
            <td>Track changes to the <link to="IMachine::name"/> property of
            all registered virtual machines</td>
          </tr>
        </table>

        <note>
          This function is not implemented in the current version of the
          product.
        </note>
      </desc>
      <param name="what" type="wstring" dir="in">
        <desc>Comma separated list of property masks.</desc>
      </param>
      <param name="timeout" type="unsigned long" dir="in">
        <desc>
          Wait timeout in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
      <param name="changed" type="wstring" dir="out">
        <desc>
          Comma separated list of properties that have been changed and caused
          this method to return to the caller.
        </desc>
      </param>
      <param name="values" type="wstring" dir="out">
        <desc>Reserved, not currently used.</desc>
      </param>
    </method>

    <method name="saveSettings">
      <desc>
        Saves the global settings to the global settings file
        (<link to="#settingsFilePath"/>).

        This method is only useful for explicitly saving the global settings
        file after it has been auto-converted from the old format to the most
        recent format (see <link to="#settingsFileVersion"/> for details).
        Normally, the global settings file is implicitly saved when a global
        setting is changed.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
    </method>

    <method name="saveSettingsWithBackup">
      <desc>
        Creates a backup copy of the global settings file
        (<link to="#settingsFilePath"/>) in case of auto-conversion, and then
        calls <link to="#saveSettings()"/>.

        Note that the backup copy is created <b>only</b> if the settings file
        auto-conversion took place (see <link to="#settingsFileVersion"/> for
        details). Otherwise, this call is fully equivalent to
        <link to="#saveSettings()"/> and no backup copying is done.

        The backup copy is created in the same directory where the original
        settings file is located. It is given the following file name:
        <pre>
          original.xml.x.y-platform.bak
        </pre>
        where <tt>original.xml</tt> is the original settings file name
        (excluding path), and <tt>x.y-platform</tt> is the version of the old
        format of the settings file (before auto-conversion).

        If the given backup file already exists, this method will try to add the
        <tt>.N</tt> suffix to the backup file name (where <tt>N</tt> counts from
        0 to 9) and copy it again until it succeeds. If all suffixes are
        occupied, or if any other copy error occurs, this method will return a
        failure.

        If the copy operation succeeds, the @a bakFileName return argument will
        receive a full path to the created backup file (for informational
        purposes). Note that this will happen even if the subsequent
        <link to="#saveSettings()"/> call performed by this method after the
        copy operation, fails.

        <note>
          The VirtualBox API never calls this method. It is intended purely for
          the purposes of creating backup copies of the settings files by
          front-ends before saving the results of the automatically performed
          settings conversion to disk.
        </note>

        <see>settingsFileVersion</see>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not copy the settings file.
        </result>

      </desc>
      <param name="bakFileName" type="wstring" dir="return">
        <desc>Full path to the created backup copy.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IMachine
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IMachineEnumerator" type="IMachine"
     uuid="1b554149-be0a-4465-9252-9ff8f420af55"
     />

  <collection
     name="IMachineCollection" type="IMachine" enumerator="IMachineEnumerator"
     uuid="FD443EC1-3007-4F5B-9282-D72760A66916"
     readonly="yes"
     />

  <interface
     name="IInternalMachineControl" extends="$unknown"
     uuid="4042ddf2-93d3-4749-8517-dde3f17ea630"
     internal="yes"
     wsmap="suppress"
     >
    <method name="updateState">
      <desc>
        Updates the VM state.
        <note>
          This operation will also update the settings file with
          the correct information about the saved state file
          and delete this file from disk when appropriate.
        </note>
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="getIPCId">
      <param name="id" type="wstring" dir="return"/>
    </method>

    <method name="runUSBDeviceFilters">
      <desc>
        Asks the server to run USB devices filters of the associated
        machine against the given USB device and tell if there is
        a match.
        <note>
          Intended to be used only for remote USB devices. Local
          ones don't require to call this method (this is done
          implicitly by the Host and USBProxyService).
        </note>
      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="matched" type="boolean" dir="out"/>
      <param name="maskedInterfaces" type="unsigned long" dir="out"/>
    </method>

    <method name="captureUSBDevice">
      <desc>
        Requests a capture of the given host USB device.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification.
      </desc>
      <param name="id" type="uuid" dir="in"/>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Notification that a VM is going to detach (done = false) or has
        already detached (done = true) the given USB device.
        When the done = true request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceDetach"/>
        notification.
        <note>
          In the done = true case, the server must run its own filters
          and filters of all VMs but this one on the detached device
          as if it were just attached to the host computer.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in"/>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="autoCaptureUSBDevices">
      <desc>
        Requests a capture all matching USB devices attached to the host.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification per every captured device.
      </desc>
    </method>

    <method name="detachAllUSBDevices">
      <desc>
        Notification that a VM that is being powered down. The done
        parameter indicates whether which stage of the power down
        we're at. When done = false the VM is announcing its
        intentions, while when done = true the VM is reporting
        what it has done.
        <note>
          In the done = true case, the server must run its own filters
          and filters of all VMs but this one on all detach devices as
          if they were just attached to the host computer.
        </note>
      </desc>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="onSessionEnd">
      <desc>
        Triggered by the given session object when the session is about
        to close normally.
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>Session that is being closed</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Used to wait until the corresponding machine is actually
          dissociated from the given session on the server.
          Returned only when this session is a direct one.
        </desc>
      </param>
    </method>

    <method name="beginSavingState">
      <desc>
        Called by the VM process to inform the server it wants to
        save the current state and stop the VM execution.
      </desc>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process to wait until
          the state is saved.
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
    </method>

    <method name="endSavingState">
      <desc>
        Called by the VM process to inform the server that saving
        the state previously requested by #beginSavingState is either
        successfully finished or there was a failure.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>

      <param name="success" type="boolean" dir="in">
        <desc><tt>true</tt> to indicate success and <tt>false</tt>
          otherwise.
        </desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Gets called by IConsole::adoptSavedState.
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file path.
        </result>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="beginTakingSnapshot">
      <desc>
        Called by the VM process to inform the server it wants to
        take a snapshot.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Snapshot name.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Snapshot description.</desc>
      </param>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process to wait until
          the state is saved (only for online snapshots).
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
      <param name="serverProgress" type="IProgress" dir="out">
        <desc>
          Progress object created by the server process to wait until
          the snapshot is taken (VDI diff creation, etc.).
        </desc>
      </param>
    </method>

    <method name="endTakingSnapshot">
      <desc>
        Called by the VM process to inform the server that the snapshot
        previously requested by #beginTakingSnapshot is either
        successfully taken or there was a failure.
      </desc>

      <param name="success" type="boolean" dir="in">
        <desc><tt>true</tt> to indicate success and <tt>false</tt> otherwise</desc>
      </param>
    </method>

    <method name="discardSnapshot">
      <desc>
        Gets called by IConsole::discardSnapshot.
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Snapshot has more than one child snapshot.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to discard.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentState">
      <desc>
        Gets called by IConsole::discardCurrentState.
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Virtual machine does not have any snapshot.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentSnapshotAndState">
      <desc>
        Gets called by IConsole::discardCurrentSnapshotAndState.
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Virtual machine does not have any snapshot.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="pullGuestProperties">
      <desc>
        Get the list of the guest properties matching a set of patterns along
        with their values, time stamps and flags and give responsibility for
        managing properties to the console.
      </desc>
      <param name="name" type="wstring" dir="out" safearray="yes">
        <desc>
          The names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>

    <method name="pushGuestProperties">
      <desc>
        Set the list of the guest properties matching a set of patterns along
        with their values, time stamps and flags and return responsibility for
        managing properties to IMachine.
      </desc>
      <param name="name" type="wstring" dir="in" safearray="yes">
        <desc>
          The names of the properties.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in" safearray="yes">
        <desc>
          The values of the properties.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="in" safearray="yes">
        <desc>
          The time stamps of the properties.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in" safearray="yes">
        <desc>
          The flags of the properties.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>
    <method name="pushGuestProperty">
      <desc>
        Update a single guest property in IMachine.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to be updated.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The value of the property.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="in">
        <desc>
          The timestamp of the property.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          The flags of the property.
        </desc>
      </param>
    </method>
  </interface>

  <interface
     name="IBIOSSettings" extends="$unknown"
     uuid="38b54279-dc35-4f5e-a431-835b867c6b5e"
     wsmap="managed"
     >
    <desc>
        The IBIOSSettings interface represents BIOS settings of the virtual
        machine. This is used only in the <link to="IMachine::BIOSSettings" /> attribute.
    </desc>
    <attribute name="logoFadeIn" type="boolean">
      <desc>Fade in flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoFadeOut" type="boolean">
      <desc>Fade out flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoDisplayTime" type="unsigned long">
      <desc>BIOS logo display time in milliseconds (0 = default).</desc>
    </attribute>

    <attribute name="logoImagePath" type="wstring">
      <desc>Local file system path for external BIOS image.</desc>
    </attribute>

    <attribute name="bootMenuMode" type="BIOSBootMenuMode">
      <desc>Mode of the BIOS boot device menu.</desc>
    </attribute>

    <attribute name="ACPIEnabled" type="boolean">
      <desc>ACPI support flag.</desc>
    </attribute>

    <attribute name="IOAPICEnabled" type="boolean">
      <desc>
        IO APIC support flag. If set, VirtualBox will provide an IO APIC
        and support IRQs above 15.
      </desc>
    </attribute>

    <attribute name="timeOffset" type="long long">
      <desc>
        Offset in milliseconds from the host system time. This allows for
        guests running with a different system date/time than the host.
        It is equivalent to setting the system date/time in the BIOS except
        it is not an absolute value but a relative one. Guest Additions
        time synchronization honors this offset.
      </desc>
    </attribute>

    <attribute name="PXEDebugEnabled" type="boolean">
      <desc>
        PXE debug logging flag. If set, VirtualBox will write extensive
        PXE trace information to the release log.
      </desc>
    </attribute>

    <attribute name="IDEControllerType" type="IDEControllerType">
      <desc>
        Type of the virtual IDE controller. Depending on this value,
        VirtualBox will provide different virtual IDE hardware
        devices to the guest.
      </desc>
    </attribute>

  </interface>

  <interface
     name="IMachine" extends="$unknown"
     uuid="ea6fb7ea-1993-4642-b113-f29eb39e0df0"
     wsmap="managed"
     >
    <desc>
      The IMachine interface represents a virtual machine, or guest, created
      in VirtualBox.

      This interface is used in two contexts. First of all, a collection of
      objects implementing this interface is stored in the
      <link to="IVirtualBox::machines2"/> attribute which lists all the virtual
      machines that are currently registered with this VirtualBox
      installation. Also, once a session has been opened for the given virtual
      machine (e.g. the virtual machine is running), the machine object
      associated with the open session can be queried from the session object;
      see <link to="ISession"/> for details.

      The main role of this interface is to expose the settings of the virtual
      machine and provide methods to change various aspects of the virtual
      machine's configuration. For machine objects stored in the
      <link to="IVirtualBox::machines2"/> collection, all attributes are
      read-only unless explicitly stated otherwise in individual attribute
      and method descriptions. In order to change a machine setting, a session
      for this machine must be opened using one of
      <link to="IVirtualBox::openSession"/>,
      <link to="IVirtualBox::openRemoteSession"/> or
      <link to="IVirtualBox::openExistingSession"/> methods. After the
      session has been successfully opened, a mutable machine object needs to
      be queried from the session object and then the desired settings changes
      can be applied to the returned object using IMachine attributes and
      methods. See the ISession interface description for more information
      about sessions.

      Note that the IMachine interface does not provide methods to control
      virtual machine execution (such as start the machine, or power it
      down) -- these methods are grouped in a separate IConsole
      interface. Refer to the IConsole interface description to get more
      information about this topic.

      <see>ISession, IConsole</see>
    </desc>

    <attribute name="parent" type="IVirtualBox" readonly="yes">
      <desc>Associated parent object.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether this virtual machine is currently accessible or not.

        The machine is considered to be inaccessible when:
        <ul>
          <li>It is a registered virtual machine, and
          </li>
          <li>Its settings file is inaccessible (for example, it is
            located on a network share that is not accessible during
            VirtualBox startup, or becomes inaccessible later, or if
            the settings file can be read but is invalid).
          </li>
        </ul>

        Otherwise, the value of this property is always <tt>true</tt>.

        Every time this property is read, the accessibility state of
        this machine is re-evaluated. If the returned value is |false|,
        the <link to="#accessError"/> property may be used to get the
        detailed error information describing the reason of
        inaccessibility.

        When the machine is inaccessible, only the following properties
        can be used on it:
        <ul>
          <li><link to="#parent"/></li>
          <li><link to="#id"/></li>
          <li><link to="#settingsFilePath"/></li>
          <li><link to="#accessible"/></li>
          <li><link to="#accessError"/></li>
        </ul>

        An attempt to access any other property or method will return
        an error.

        The only possible action you can perform on an inaccessible
        machine is to unregister it using the
        <link to="IVirtualBox::unregisterMachine"/> call (or, to check
        for the accessibility state once more by querying this
        property).

        <note>
          In the current implementation, once this property returns
          <tt>true</tt>, the machine will never become inaccessible
          later, even if its settings file cannot be successfully
          read/written any more (at least, until the VirtualBox
          server is restarted). This limitation may be removed in
          future releases.
        </note>
      </desc>
    </attribute>

    <attribute name="accessError" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Error information describing the reason of machine
        inaccessibility.

        Reading this property is only valid after the last call to
        <link to="#accessible"/> returned <tt>false</tt> (i.e. the
        machine is currently unaccessible). Otherwise, a null
        IVirtualBoxErrorInfo object will be returned.
      </desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>
        Name of the virtual machine.

        Besides being used for human-readable identification purposes
        everywhere in VirtualBox, the virtual machine name is also used
        as a name of the machine's settings file and as a name of the
        subdirectory this settings file resides in. Thus, every time you
        change the value of this property, the settings file will be
        renamed once you call <link to="#saveSettings()"/> to confirm the
        change. The containing subdirectory will be also renamed, but
        only if it has exactly the same name as the settings file
        itself prior to changing this property (for backward compatibility
        with previous API releases). The above implies the following
        limitations:
        <ul>
          <li>The machine name cannot be empty.</li>
          <li>The machine name can contain only characters that are valid
            file name characters according to the rules of the file
            system used to store VirtualBox configuration.</li>
          <li>You cannot have two or more machines with the same name
            if they use the same subdirectory for storing the machine
            settings files.</li>
          <li>You cannot change the name of the machine if it is running,
            or if any file in the directory containing the settings file
            is being used by another running machine or by any other
            process in the host operating system at a time when
            <link to="#saveSettings()"/> is called.
          </li>
        </ul>
        If any of the above limitations are hit, <link to="#saveSettings()"/>
        will return an appropriate error message explaining the exact
        reason and the changes you made to this machine will not be
        saved.
        <note>
          For "legacy" machines created using the
          <link to="IVirtualBox::createLegacyMachine()"/> call,
          the above naming limitations do not apply because the
          machine name does not affect the settings file name.
          The settings file name remains the same as it was specified
          during machine creation and never changes.
        </note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Description of the virtual machine.

        The description attribute can contain any text and is
        typically used to describe the hardware and software
        configuration of the virtual machine in detail (i.e. network
        settings, versions of the installed software and so on).
      </desc>
    </attribute>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>UUID of the virtual machine.</desc>
    </attribute>

    <attribute name="OSTypeId" type="wstring">
      <desc>
        User-defined identifier of the Guest OS type.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          This value may differ from the value returned by
          <link to="IGuest::OSTypeId"/> if Guest Additions are
          installed to the guest OS.
        </note>
      </desc>
    </attribute>

    <attribute name="HardwareVersion" type="wstring">
      <desc>Hardware version identifier. Internal use only for now.</desc>
    </attribute>

    <attribute name="CPUCount" type="unsigned long">
      <desc>Number of virtual CPUs in the VM. In the current version of the product, this is always 1.</desc>
    </attribute>

    <attribute name="memorySize" type="unsigned long">
      <desc>System memory size in megabytes.</desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Initial memory balloon size in megabytes.</desc>
    </attribute>

    <attribute name="statisticsUpdateInterval" type="unsigned long">
      <desc>Initial interval to update guest statistics in seconds.</desc>
    </attribute>

    <attribute name="VRAMSize" type="unsigned long">
      <desc>Video memory size in megabytes.</desc>
    </attribute>

    <attribute name="accelerate3DEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox allows guests to make use
        of the 3D graphics support available on the host. Currently limited
        to OpenGL only. </desc>
    </attribute>

    <attribute name="monitorCount" type="unsigned long">
      <desc>
        Number of virtual monitors.
        <note>
          Only effective on Windows XP and later guests with
          Guest Additions installed.
        </note>
      </desc>
    </attribute>

    <attribute name="BIOSSettings" type="IBIOSSettings" readonly="yes">
      <desc>Object containing all BIOS settings.</desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="TSBool">
      <desc>
        This setting determines whether VirtualBox will try to make use of
        the host CPU's hardware virtualization extensions such as Intel VT-x
        and AMD-V. Note that in case such extensions are not available,
        they will not be used.
      </desc>
    </attribute>

    <attribute name="HWVirtExNestedPagingEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox will try to make use of
        the nested paging extension of Intel VT-x and AMD-V. Note that in case
        such extensions are not available, they will not be used.
      </desc>
    </attribute>

    <attribute name="HWVirtExVPIDEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox will try to make use of
        the VPID extension of Intel VT-x. Note that in case such extensions are
        not available, they will not be used.
      </desc>
    </attribute>

    <attribute name="PAEEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox will expose the Physical Address
        Extension (PAE) feature of the host CPU to the guest. Note that in case PAE
        is not available, it will not be reported.
      </desc>
    </attribute>

    <attribute name="snapshotFolder" type="wstring">
      <desc>
        Full path to the directory used to store snapshot data
        (differencing hard disks and saved state files) of this machine.

        The initial value of this property is
        <tt>&lt;</tt><link to="#settingsFilePath">
          path_to_settings_file</link><tt>&gt;/&lt;</tt>
        <link to="#id">machine_uuid</link>
        <tt>&gt;</tt>.

        Currently, it is an error to try to change this property on
        a machine that has snapshots (because this would require to
        move possibly large files to a different location).
        A separate method will be available for this purpose later.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
        <note>
          When setting this property, the specified path can be
          absolute (full path) or relative to the directory where the
          <link to="#settingsFilePath">machine settings file</link>
          is located. When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>
      </desc>
    </attribute>

    <attribute name="VRDPServer" type="IVRDPServer" readonly="yes">
      <desc>VRDP server object.</desc>
    </attribute>

    <attribute name="hardDisk2Attachments" type="IHardDisk2Attachment" readonly="yes" safearray="yes">
      <desc>Array of hard disks attached to this machine.</desc>
    </attribute>

    <attribute name="DVDDrive" type="IDVDDrive" readonly="yes">
      <desc>Associated DVD drive object.</desc>
    </attribute>

    <attribute name="floppyDrive" type="IFloppyDrive" readonly="yes">
      <desc>Associated floppy drive object.</desc>
    </attribute>

    <attribute name="USBController" type="IUSBController" readonly="yes">
      <desc>
        Associated USB controller object.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="audioAdapter" type="IAudioAdapter" readonly="yes">
      <desc>Associated audio adapter, always present.</desc>
    </attribute>

    <attribute name="SATAController" type="ISATAController" readonly="yes">
      <desc>
        Associated SATA controller object.
      </desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the file containing machine settings data.
      </desc>
    </attribute>

    <attribute name="settingsFileVersion" type="wstring" readonly="yes">
      <desc>
        Current version of the format of the settings file of this machine
        (<link to="#settingsFilePath"/>).

        The version string has the following format:
        <pre>
          x.y-platform
        </pre>
        where <tt>x</tt> and <tt>y</tt> are the major and the minor format
        versions, and <tt>platform</tt> is the platform identifier.

        The current version usually matches the value of the
        <link to="IVirtualBox::settingsFormatVersion"/> attribute unless the
        settings file was created by an older version of VirtualBox and there
        was a change of the settings file format since then.

        Note that VirtualBox automatically converts settings files from older
        versions to the most recent version when reading them (usually at
        VirtualBox startup) but it doesn't save the changes back until
        you call a method that implicitly saves settings (such as
        <link to="#setExtraData()"/>) or call <link to="#saveSettings()"/>
        explicitly. Therefore, if the value of this attribute differs from the
        value of <link to="IVirtualBox::settingsFormatVersion"/>, then it
        means that the settings file was converted but the result of the
        conversion is not yet saved to disk.

        The above feature may be used by interactive front-ends to inform users
        about the settings file format change and offer them to explicitly save
        all converted settings files (the global and VM-specific ones),
        optionally create backup copies of the old settings files before saving,
        etc.

        <see>IVirtualBox::settingsFormatVersion, saveSettingsWithBackup()</see>
      </desc>
    </attribute>

    <attribute name="settingsModified" type="boolean" readonly="yes">
      <desc>
        Whether the settings of this machine have been modified
        (but neither yet saved nor discarded).
        <note>
          Reading this property is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or opened
          by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>. For all other
          cases, the settings can never be modified.
        </note>
        <note>
          For newly created unregistered machines, the value of this
          property is always TRUE until <link to="#saveSettings()"/>
          is called (no matter if any machine settings have been
          changed after the creation or not). For opened machines
          the value is set to FALSE (and then follows to normal rules).
        </note>
      </desc>
    </attribute>

    <attribute name="sessionState" type="SessionState" readonly="yes">
      <desc>Current session state for this machine.</desc>
    </attribute>

    <attribute name="sessionType" type="wstring" readonly="yes">
      <desc>
        Type of the session.  If <link to="#sessionState"/> is
        SessionSpawning or SessionOpen, this attribute contains the
        same value as passed to the
        <link to="IVirtualBox::openRemoteSession()"/> method in the @a
        type parameter. If the session was opened directly using
        <link to="IVirtualBox::openSession()"/>, or if
        <link to="#sessionState"/> is SessionClosed, the value of this
        attribute is @c null.
      </desc>
    </attribute>

    <attribute name="sessionPid" type="unsigned long" readonly="yes">
      <desc>
        Identifier of the session process. This attribute contains the
        platform-dependent identifier of the process that has opened a
        direct session for this machine using the
        <link to="IVirtualBox::openSession()"/> call. The returned value
        is only valid if <link to="#sessionState"/> is SessionOpen or
        SessionClosing (i.e. a session is currently open or being
        closed) by the time this property is read.
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>Current execution state of this machine.</desc>
    </attribute>

    <attribute name="lastStateChange" type="long long" readonly="yes">
      <desc>
        Time stamp of the last execution state change,
        in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="stateFilePath" type="wstring" readonly="yes">
      <desc>
        Full path to the file that stores the execution state of
        the machine when it is in the <link to="MachineState_Saved"/> state.
        <note>
          When the machine is not in the Saved state, this attribute
          <tt>null</tt>.
        </note>
      </desc>
    </attribute>

    <attribute name="logFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the folder that stores a set of rotated log files
        recorded during machine execution. The most recent log file is
        named <tt>VBox.log</tt>, the previous log file is
        named <tt>VBox.log.1</tt> and so on (up to <tt>VBox.log.3</tt>
        in the current version).
      </desc>
    </attribute>

    <attribute name="currentSnapshot" type="ISnapshot" readonly="yes">
      <desc>
        Current snapshot of this machine.
        <note>
          A <tt>null</tt> object is returned if the machine doesn't
          have snapshots.
        </note>
        <see><link to="ISnapshot"/></see>
      </desc>
    </attribute>

    <attribute name="snapshotCount" type="unsigned long" readonly="yes">
      <desc>
        Number of snapshots taken on this machine. Zero means the
        machine doesn't have any snapshots.
      </desc>
    </attribute>

    <attribute name="currentStateModified" type="boolean" readonly="yes">
      <desc>
        Returns <tt>true</tt> if the current state of the machine is not
        identical to the state stored in the current snapshot.

        The current state is identical to the current snapshot right
        after one of the following calls are made:
        <ul>
          <li><link to="IConsole::discardCurrentState"/> or
            <link to="IConsole::discardCurrentSnapshotAndState"/>
          </li>
          <li><link to="IConsole::takeSnapshot"/> (issued on a
            powered off or saved machine, for which
            <link to="#settingsModified"/> returns <tt>false</tt>)
          </li>
          <li><link to="IMachine::setCurrentSnapshot"/>
          </li>
        </ul>

        The current state remains identical until one of the following
        happens:
        <ul>
          <li>settings of the machine are changed</li>
          <li>the saved state is discarded</li>
          <li>the current snapshot is discarded</li>
          <li>an attempt to execute the machine is made</li>
        </ul>

        <note>
          For machines that don't have snapshots, this property is
          always <tt>false</tt>.
        </note>
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
      <desc>
        Collection of shared folders for this machine (permanent shared
        folders). These folders are shared automatically at machine startup
        and available only to the guest OS installed within this machine.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="clipboardMode" type="ClipboardMode">
      <desc>
        Synchronization mode between the host OS clipboard
        and the guest OS clipboard.
      </desc>
    </attribute>

    <attribute name="guestPropertyNotificationPatterns" type="wstring">
      <desc>
        A comma-separated list of simple glob patterns.  Changes to guest
        properties whose name matches one of the patterns will generate an
        <link to="IVirtualBoxCallback::onGuestPropertyChange"/> signal.
      </desc>
    </attribute>

    <method name="setBootOrder">
      <desc>
        Puts the given device to the specified position in
        the boot order.

        To indicate that no device is associated with the given position,
        <link to="DeviceType_Null"/> should be used.

        @todo setHardDiskBootOrder(), setNetworkBootOrder()

        <result name="E_INVALIDARG">
          Boot @a position out of range.
        </result>
        <result name="E_NOTIMPL">
          Booting from USB @a device currently not supported.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (<tt>1</tt> to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="in">
        <desc>
          The type of the device used to boot at the given position.
        </desc>
      </param>
    </method>

    <method name="getBootOrder" const="yes">
      <desc>
        Returns the device type that occupies the specified
        position in the boot order.

        @todo [remove?]
        If the machine can have more than one device of the returned type
        (such as hard disks), then a separate method should be used to
        retrieve the individual device that occupies the given position.

        If here are no devices at the given position, then
        <link to="DeviceType_Null"/> is returned.

        @todo getHardDiskBootOrder(), getNetworkBootOrder()

        <result name="E_INVALIDARG">
          Boot @a position out of range.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (<tt>1</tt> to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="return">
        <desc>
          Device at the given position.
        </desc>
      </param>
    </method>

    <method name="attachHardDisk2">
      <desc>
        Attaches a virtual hard disk identified by the given UUID @a id
        to a device slot of the specified bus.

        For the IDE bus, the @a channel parameter can be either @c 0 or @c 1, to
        specify the primary or secondary IDE controller, respectively. The
        SATA bus supports 30 channels, so this parameter can be a number
        ranging from @c 0 to @c 29.

        For the primary controller of the IDE bus, the @a device number can be
        either @c 0 or @c 1, to specify the master or the slave device,
        respectively. For the secondary IDE controller, the device number is
        always @c 1 because the master device is reserved for the CD-ROM drive.

        For the SATA bus, the @a device parameter is currently unused and
        must be @c 0.

        The specified device slot must not have another disk attached to it, or
        this method will fail.

        See <link to="IHardDisk2"/> for more detailed information about
        attaching hard disks.

        <note>
          You cannot attach a hard disk to a running machine. Also, you cannot
          attach a hard disk to a newly created machine until this machine's
          settings are saved to disk using <link to="#saveSettings()"/>.
        </note>
        <note>
          If the hard disk is being attached indirectly, a new differencing hard
          disk will implicitly be created for it and attached instead. If the
          changes made to the machine settings (including this indirect
          attachment) are later cancelled using <link to="#discardSettings()"/>,
          this implicitly created differencing hard disk will implicitly
          be deleted.
        </note>

        <result name="E_INVALIDARG">
          SATA device, SATA channel, IDE channel or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to attach hard disk to an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Hard disk already attached to this or another virtual machine.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the hard disk to attach.</desc>
      </param>
      <param name="bus" type="StorageBus" dir="in">
        <desc>Type of the storage bus to use (IDE or SATA).</desc>
      </param>
      <param name="channel" type="long" dir="in">
        <desc>Channel to attach the hard disk to.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>
          Device slot in the given channel to attach the hard disk to.
        </desc>
      </param>
    </method>

    <method name="getHardDisk2" const="yes">
      <desc>
        Returns the virtual hard disk attached to a device slot of the specified
        bus.

        Note that if the hard disk was indirectly attached by
        <link to="#attachHardDisk2()"/> to the given device slot then this
        method will return not the same object as passed to the
        <link to="#attachHardDisk2()"/> call. See <link to="IHardDisk2"/> for
        more detailed information about attaching hard disks.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No hard disk attached to given slot/bus.
        </result>

      </desc>
      <param name="bus" type="StorageBus" dir="in">
        <desc>Type of the storage bus to query (IDE or SATA).</desc>
      </param>
      <param name="channel" type="long" dir="in">
        <desc>Channel to query.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given channel to query.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk2" dir="return">
        <desc>Attached hard disk object.</desc>
      </param>
    </method>

    <method name="detachHardDisk2">
      <desc>
        Detaches the virtual hard disk attached to a device slot of the
        specified bus.

        Detaching the hard disk from the virtual machine is deferred. This means
        that the hard disk remains associated with the machine when this method
        returns and gets actually de-associated only after a successful
        <link to="#saveSettings()"/> call. See <link to="IHardDisk2"/>
        for more detailed information about attaching hard disks.

        <note>
          You cannot detach the hard disk from a running machine.
        </note>
        <note>
          Detaching differencing hard disks implicitly created by <link
          to="#attachHardDisk2()"/> for the indirect attachment using this
          method will <b>not</b> implicitly delete them. The
          <link to="IHardDisk2::deleteStorage()"/> operation should be
          explicitly performed by the caller after the hard disk is successfully
          detached and the settings are saved with
          <link to="#saveSettings()"/>, if it is the desired action.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Attempt to detach hard disk from a running virtual machine.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No hard disk attached to given slot/bus.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Hard disk format does not support storage deletion.
        </result>

      </desc>
      <param name="bus" type="StorageBus" dir="in">
        <desc>Bus to detach the hard disk from.</desc>
      </param>
      <param name="channel" type="long" dir="in">
        <desc>Channel number to detach the hard disk from.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot number to detach the hard disk from.</desc>
      </param>
    </method>

    <method name="getNetworkAdapter" const="yes">
      <desc>
        Returns the network adapter associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of adapters per machine is defined by the
        <link to="ISystemProperties::networkAdapterCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="adapter" type="INetworkAdapter" dir="return"/>
    </method>

    <method name="getSerialPort" const="yes">
      <desc>
        Returns the serial port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of serial ports per machine is defined by the
        <link to="ISystemProperties::serialPortCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="ISerialPort" dir="return"/>
    </method>

    <method name="getParallelPort" const="yes">
      <desc>
        Returns the parallel port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of parallel ports per machine is defined by the
        <link to="ISystemProperties::parallelPortCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="IParallelPort" dir="return"/>
    </method>

    <method name="getNextExtraDataKey">
      <desc>
        Returns the machine-specific extra data key name following the
        supplied key.

        An error is returned if the supplied @a key does not exist. @c NULL is
        returned in @a nextKey if the supplied key is the last key. When
        supplying @c NULL for the @a key, the first key item is returned in @a
        nextKey (if there is any). @a nextValue is an optional parameter and
        if supplied, the next key's value is returned in it.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Extra data @a key not found.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to follow.</desc>
      </param>
      <param name="nextKey" type="wstring" dir="out">
        <desc>Name of the next data key.</desc>
      </param>
      <param name="nextValue" type="wstring" dir="out">
        <desc>Value of the next data key.</desc>
      </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated machine-specific extra data.

        If the requested data @a key does not exist, this function will
        succeed and return @c NULL in the @a value argument.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated machine-specific extra data.

        If you pass @c NULL as a key @a value, the given @a key will be
        deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered callbacks using the
          <link to="IVirtualBoxCallback::onExtraDataCanChange()"/>
          notification for a permission. If one of the callbacks refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IVirtualBoxCallback::onExtraDataChange()"/> notification
          is called to inform all registered callbacks about a successful data
          change.
        </note>
        <note>
          This method can be called outside the machine session and therefore
          it's a caller's responsibility to handle possible race conditions
          when several clients change the same key at the same time.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="saveSettings">
      <desc>
        Saves any changes to machine settings made since the session
        has been opened or a new machine has been created, or since the
        last call to <link to="#saveSettings()"/> or <link to="#discardSettings()"/>.
        For registered machines, new settings become visible to all
        other VirtualBox clients after successful invocation of this
        method.
        <note>
          The method sends <link to="IVirtualBoxCallback::onMachineDataChange()"/>
          notification event after the configuration has been successfully
          saved (only for registered machines).
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
    </method>

    <method name="saveSettingsWithBackup">
      <desc>
        Creates a backup copy of the machine settings file (<link
        to="#settingsFilePath"/>) in case of auto-conversion, and then calls
        <link to="#saveSettings()"/>.

        Note that the backup copy is created <b>only</b> if the settings file
        auto-conversion took place (see <link to="#settingsFileVersion"/> for
        details). Otherwise, this call is fully equivalent to
        <link to="#saveSettings()"/> and no backup copying is done.

        The backup copy is created in the same directory where the original
        settings file is located. It is given the following file name:
        <pre>
          original.xml.x.y-platform.bak
        </pre>
        where <tt>original.xml</tt> is the original settings file name
        (excluding path), and <tt>x.y-platform</tt> is the version of the old
        format of the settings file (before auto-conversion).

        If the given backup file already exists, this method will try to add the
        <tt>.N</tt> suffix to the backup file name (where <tt>N</tt> counts from
        0 to 9) and copy it again until it succeeds. If all suffixes are
        occupied, or if any other copy error occurs, this method will return a
        failure.

        If the copy operation succeeds, the @a bakFileName return argument will
        receive a full path to the created backup file (for informational
        purposes). Note that this will happen even if the subsequent
        <link to="#saveSettings()"/> call performed by this method after the
        copy operation, fails.

        <note>
          The VirtualBox API never calls this method. It is intended purely for
          the purposes of creating backup copies of the settings files by
          front-ends before saving the results of the automatically performed
          settings conversion to disk.
        </note>

        <see>settingsFileVersion</see>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
      <param name="bakFileName" type="wstring" dir="return">
        <desc>Full path to the created backup copy.</desc>
      </param>
    </method>

    <method name="discardSettings">
      <desc>
        Discards any changes to the machine settings made since the session
        has been opened or since the last call to <link to="#saveSettings()"/>
        or <link to="#discardSettings"/>.
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>

      </desc>
    </method>

    <method name="deleteSettings">
      <desc>
        Deletes the settings file of this machine from disk.
        The machine must not be registered in order for this operation
        to succeed.
        <note>
          <link to="#settingsModified"/> will return TRUE after this
          method successfully returns.
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>
        <note>
          The deleted machine settings file can be restored (saved again)
          by calling <link to="#saveSettings()"/>.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Cannot delete settings of a registered machine or
          machine not mutable.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not delete the settings file.
        </result>

      </desc>
    </method>

    <method name="getSnapshot">
      <desc>
        Returns a snapshot of this machine with the given UUID.
        A <tt>null</tt> UUID can be used to obtain the first snapshot
        taken on this machine. This is useful if you want to traverse
        the whole tree of snapshots starting from the root.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Virtual machine has no snapshots or snapshot not found.
        </result>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to get</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given UUID.</desc>
      </param>
    </method>

    <method name="findSnapshot">
      <desc>
        Returns a snapshot of this machine with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Virtual machine has no snapshots or snapshot not found.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the snapshot to find</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given name.</desc>
      </param>
    </method>

    <method name="setCurrentSnapshot">
      <desc>
        Sets the current snapshot of this machine.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to set as the current snapshot.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new permanent shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.

        <result name="VBOX_E_OBJECT_IN_USE">
          Shared folder already exists.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder @a hostPath not accessible.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the permanent shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Shared folder @a name does not exist.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="canShowConsoleWindow">
      <desc>
        Returns @c true if the VM console process can activate the
        console window and bring it to foreground on the desktop of
        the host PC.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c
          false otherwise.
        </desc>
      </param>
    </method>

    <method name="showConsoleWindow">
      <desc>
        Activates the console window and brings it to foreground on
        the desktop of the host PC. Many modern window managers on
        many platforms implement some sort of focus stealing
        prevention logic, so that it may be impossible to activate
        a window without the help of the currently active
        application. In this case, this method will return a non-zero
        identifier that represents the top-level window of the VM
        console process. The caller, if it represents a currently
        active process, is responsible to use this identifier (in a
        platform-dependent manner) to perform actual window
        activation.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="winId" type="unsigned long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or VirtualBox front-end.
        </desc>
      </param>
    </method>

    <method name="getGuestProperty">
      <desc>
        Reads an entry from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out">
        <desc>
          The value of the property.  If the property does not exist then this
          will be empty.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out">
        <desc>
          The time at which the property was last modified, as seen by the
          server process.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries.
        </desc>
      </param>
    </method>

    <method name="getGuestPropertyValue">
      <desc>
        Reads a value from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>
          The value of the property.  If the property does not exist then this
          will be empty.
        </desc>
      </param>
    </method>

    <method name="getGuestPropertyTimestamp">
      <desc>
        Reads a property timestamp from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="unsigned long long" dir="return">
        <desc>
          The timestamp.  If the property does not exist then this will be
          empty.
        </desc>
      </param>
    </method>

    <method name="setGuestProperty">
      <desc>
        Sets, changes or deletes an entry in the machine's guest property
        store.

        <result name="E_ACCESSDENIED">
          Property cannot be changed.
        </result>
        <result name="E_INVALIDARG">
          Invalid @a flags.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable or session not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Cannot set transient property when machine not running.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to set, change or delete.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new value of the property to set, change or delete.  If the
          property does not yet exist and value is non-empty, it will be
          created.  If the value is empty, the key will be deleted if it
          exists.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries.
        </desc>
      </param>
    </method>

    <method name="setGuestPropertyValue">
      <desc>
        Sets, changes or deletes a value in the machine's guest property
        store.  The flags field will be left unchanged or created empty for a
        new property.

        <result name="E_ACCESSDENIED">
          Property cannot be changed.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable or session not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Cannot set transient property when machine not running.
        </result>
      </desc>

      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to set, change or delete.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new value of the property to set, change or delete.  If the
          property does not yet exist and value is non-empty, it will be
          created.  If value is empty, the property will be deleted if it
          exists.
        </desc>
      </param>
    </method>

    <method name="enumerateGuestProperties">
      <desc>
        Return a list of the guest properties matching a set of patterns along
        with their values, time stamps and flags.
      </desc>
      <param name="patterns" type="wstring" dir="in">
        <desc>
          The patterns to match the properties against, separated by '|'
          characters.  If this is empty or NULL, all properties will match.
        </desc>
      </param>
      <param name="name" type="wstring" dir="out" safearray="yes">
        <desc>
          The names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>
</interface>

  <!--
  // IConsole
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IConsoleCallback" extends="$unknown"
     uuid="13dfbef3-b74d-487d-bada-2304529aefa6"
     wsmap="suppress"
     >

    <method name="onMousePointerShapeChange">
      <desc>
        Notification when the guest mouse pointer shape has
        changed. The new shape data is given.
      </desc>
      <param name="visible" type="boolean" dir="in">
        <desc>
          Flag whether the pointer is visible.
        </desc>
      </param>
      <param name="alpha" type="boolean" dir="in">
        <desc>
          Flag whether the pointer has an alpha channel.
        </desc>
      </param>
      <param name="xHot" type="unsigned long" dir="in">
        <desc>
          The pointer hot spot x coordinate.
        </desc>
      </param>
      <param name="yHot" type="unsigned long" dir="in">
        <desc>
          The pointer hot spot y coordinate.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Width of the pointer shape in pixels.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Height of the pointer shape in pixels.
        </desc>
      </param>
      <param name="shape" type="octet" mod="ptr" dir="in">
        <desc>
          Address of the shape buffer.

          The @a shape buffer contains a 1-bpp (bits per pixel) AND mask
          followed by a 32-bpp XOR (color) mask.

          For pointers without alpha channel the XOR mask pixels are 32
          bit values: (lsb)BGR0(msb). For pointers with alpha channel
          the XOR mask consists of (lsb)BGRA(msb) 32 bit values.

          An AND mask is used for pointers with alpha channel, so if the
          callback does not support alpha, the pointer could be
          displayed as a normal color pointer.

          The AND mask is a 1-bpp bitmap with byte aligned scanlines. The
          size of the AND mask therefore is <tt>cbAnd = (width + 7) / 8 *
          height</tt>. The padding bits at the end of each scanline are
          undefined.

          The XOR mask follows the AND mask on the next 4-byte aligned
          offset: <tt>uint8_t *pXor = pAnd + (cbAnd + 3) &amp; ~3</tt>.
          Bytes in the gap between the AND and the XOR mask are undefined.
          The XOR mask scanlines have no gap between them and the size of
          the XOR mask is: <tt>cXor = width * 4 * height</tt>.

          <note>
            If @a shape is 0, only the pointer visibility is changed.
          </note>
        </desc>
      </param>
    </method>

    <method name="onMouseCapabilityChange">
      <desc>
        Notification when the mouse capabilities reported by the
        guest have changed. The new capabilities are passed.
      </desc>
      <param name="supportsAbsolute" type="boolean" dir="in"/>
      <param name="needsHostCursor" type="boolean" dir="in"/>
    </method>

    <method name="onKeyboardLedsChange">
      <desc>
        Notification when the guest OS executes the KBD_CMD_SET_LEDS command
        to alter the state of the keyboard LEDs.
      </desc>
      <param name="numLock" type="boolean" dir="in"/>
      <param name="capsLock" type="boolean" dir="in"/>
      <param name="scrollLock" type="boolean" dir="in"/>
    </method>

    <method name="onStateChange">
      <desc>
        Notification when the execution state of the machine has changed.
        The new state will be given.
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="onAdditionsStateChange">
      <desc>
        Notification when a Guest Additions property changes.
        Interested callees should query IGuest attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onDVDDriveChange">
      <desc>
        Notification when a property of the
        virtual <link to="IMachine::DVDDrive">DVD drive</link> changes.
        Interested callees should use IDVDDrive methods to find out what has
        changed.
      </desc>
    </method>

    <method name="onFloppyDriveChange">
      <desc>
        Notification when a property of the
        virtual <link to="IMachine::floppyDrive">floppy drive</link> changes.
        Interested callees should use IFloppyDrive methods to find out what
        has changed.
      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getNetworkAdapter">network adapters</link>
        changes.  Interested callees should use INetworkAdapter methods and
        attributes to find out what has changed.
      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in">
        <desc>Network adapter that is subject to change.</desc>
      </param>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getSerialPort">serial ports</link> changes.
        Interested callees should use ISerialPort methods and attributes
        to find out what has changed.
      </desc>
      <param name="serialPort" type="ISerialPort" dir="in">
        <desc>Serial port that is subject to change.</desc>
      </param>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getParallelPort">parallel ports</link>
        changes.  Interested callees should use ISerialPort methods and
        attributes to find out what has changed.
      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in">
        <desc>Parallel port that is subject to change.</desc>
      </param>
    </method>

    <method name="onVRDPServerChange">
      <desc>
        Notification when a property of the
        <link to="IMachine::VRDPServer">VRDP server</link> changes.
        Interested callees should use IVRDPServer methods and attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Notification when a property of the virtual
        <link to="IMachine::USBController">USB controller</link> changes.
        Interested callees should use IUSBController methods and attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onUSBDeviceStateChange">
      <desc>
        Notification when a USB device is attached to or detached from
        the virtual USB controller.

        This notification is sent as a result of the indirect
        request to attach the device because it matches one of the
        machine USB filters, or as a result of the direct request
        issued by <link to="IConsole::attachUSBDevice"/> or
        <link to="IConsole::detachUSBDevice"/>.

        This notification is sent in case of both a succeeded and a
        failed request completion. When the request succeeds, the @a
        error parameter is @c null, and the given device has been
        already added to (when @a attached is @c true) or removed from
        (when @a attached is @c false) the collection represented by
        <link to="IConsole::USBDevices"/>. On failure, the collection
        doesn't change and the @a error parameter represents the error
        message describing the failure.

      </desc>
      <param name="device" type="IUSBDevice" dir="in">
        <desc>Device that is subject to state change.</desc>
      </param>
      <param name="attached" type="boolean" dir="in">
        <desc>
          <tt>true</tt> if the device was attached
          and <tt>false</tt> otherwise.
        </desc>
      </param>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in">
        <desc>
          <tt>null</tt> on success or an error message object on
          failure.
        </desc>
      </param>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Notification when a shared folder is added or removed.
        The @a scope argument defines one of three scopes:
        <link to="IVirtualBox::sharedFolders">global shared folders</link>
        (<link to="Scope_Global">Global</link>),
        <link to="IMachine::sharedFolders">permanent shared folders</link> of
        the machine (<link to="Scope_Machine">Machine</link>) or <link
        to="IConsole::sharedFolders">transient shared folders</link> of the
        machine (<link to="Scope_Session">Session</link>). Interested callees
        should use query the corresponding collections to find out what has
        changed.
      </desc>
      <param name="scope" type="Scope" dir="in">
        <desc>Scope of the notification.</desc>
      </param>
    </method>

    <method name="onRuntimeError">
      <desc>
        Notification when an error happens during the virtual
        machine execution.

        There are three kinds of runtime errors:
        <ul>
          <li><i>fatal</i></li>
          <li><i>non-fatal with retry</i></li>
          <li><i>non-fatal warnings</i></li>
        </ul>

        <b>Fatal</b> errors are indicated by the @a fatal parameter set
        to <tt>true</tt>. In case of fatal errors, the virtual machine
        execution is always paused before calling this notification, and
        the notification handler is supposed either to immediately save
        the virtual machine state using <link to="IConsole::saveState()"/>
        or power it off using <link to="IConsole::powerDown()"/>.
        Resuming the execution can lead to unpredictable results.

        <b>Non-fatal</b> errors and warnings are indicated by the
        @a fatal parameter set to <tt>false</tt>. If the virtual machine
        is in the Paused state by the time the error notification is
        received, it means that the user can <i>try to resume</i> the machine
        execution after attempting to solve the problem that caused the
        error. In this case, the notification handler is supposed
        to show an appropriate message to the user (depending on the
        value of the @a id parameter) that offers several actions such
        as <i>Retry</i>, <i>Save</i> or <i>Power Off</i>. If the user
        wants to retry, the notification handler should continue
        the machine execution using the <link to="IConsole::resume()"/>
        call. If the machine execution is not Paused during this
        notification, then it means this notification is a <i>warning</i>
        (for example, about a fatal condition that can happen very soon);
        no immediate action is required from the user, the machine
        continues its normal execution.

        Note that in either case the notification handler
        <b>must not</b> perform any action directly on a thread
        where this notification is called. Everything it is allowed to
        do is to post a message to another thread that will then talk
        to the user and take the corresponding action.

        Currently, the following error identifiers are known:
        <ul>
          <li><tt>"HostMemoryLow"</tt></li>
          <li><tt>"HostAudioNotResponding"</tt></li>
          <li><tt>"VDIStorageFull"</tt></li>
        </ul>

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c S_OK from all but one of them that does actual
          user notification and performs necessary actions.
        </note>

      </desc>
      <param name="fatal" type="boolean" dir="in">
        <desc>Whether the error is fatal or not</desc>
      </param>
      <param name="id" type="wstring" dir="in">
        <desc>Error identifier</desc>
      </param>
      <param name="message" type="wstring" dir="in">
        <desc>Optional error message</desc>
      </param>
    </method>

    <method name="onCanShowWindow">
      <desc>
        Notification when a call to
        <link to="IMachine::canShowConsoleWindow()"/> is made by a
        front-end to check if a subsequent call to
        <link to="IMachine::showConsoleWindow()"/> can succeed.

        The callee should give an answer appropriate to the current
        machine state in the @a canShow argument. This answer must
        remain valid at least until the next
        <link to="IConsole::state">machine state</link> change.

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c true and @c S_OK from all but one of them that
          actually manages console window activation.
        </note>
      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c
          false otherwise.
        </desc>
      </param>
    </method>

    <method name="onShowWindow">
      <desc>
        Notification when a call to
        <link to="IMachine::showConsoleWindow()"/>
        requests the console window to be activated and brought to
        foreground on the desktop of the host PC.

        This notification should cause the VM console process to
        perform the requested action as described above. If it is
        impossible to do it at a time of this notification, this
        method should return a failure.

        Note that many modern window managers on many platforms
        implement some sort of focus stealing prevention logic, so
        that it may be impossible to activate a window without the
        help of the currently active application (which is supposedly
        an initiator of this notification). In this case, this method
        must return a non-zero identifier that represents the
        top-level window of the VM console process. The caller, if it
        represents a currently active process, is responsible to use
        this identifier (in a platform-dependent manner) to perform
        actual window activation.

        This method must set @a winId to zero if it has performed all
        actions necessary to complete the request and the console
        window is now active and in foreground, to indicate that no
        further action is required on the caller's side.

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c S_OK from all but one of them that actually
          manages console window activation.
        </note>
      </desc>
      <param name="winId" type="unsigned long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or this VirtualBox front-end.
        </desc>
      </param>
    </method>

  </interface>

  <interface
     name="IRemoteDisplayInfo" extends="$unknown"
     uuid="550104cd-2dfd-4a6c-857d-f6f8e088e62c"
     wsmap="struct"
     >
     <desc>
        Contains information about the remote display (VRDP) capabilities and status.
        This is used in the <link to="IConsole::remoteDisplayInfo" /> attribute.
     </desc>

    <attribute name="active" type="boolean" readonly="yes">
      <desc>
        Whether the remote display connection is active.
      </desc>
    </attribute>

    <attribute name="numberOfClients" type="unsigned long" readonly="yes">
      <desc>
        How many times a client connected.
      </desc>
    </attribute>

    <attribute name="beginTime" type="long long" readonly="yes">
      <desc>
        When the last connection was established, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="endTime" type="long long" readonly="yes">
      <desc>
        When the last connection was terminated or the current time, if
        connection is still active, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="bytesSent" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were sent in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesSentTotal" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were sent in all connections.
      </desc>
    </attribute>

    <attribute name="bytesReceived" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were received in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesReceivedTotal" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were received in all connections.
      </desc>
    </attribute>

    <attribute name="user" type="wstring" readonly="yes">
      <desc>
        Login user name supplied by the client.
      </desc>
    </attribute>

    <attribute name="domain" type="wstring" readonly="yes">
      <desc>
        Login domain name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientName" type="wstring" readonly="yes">
      <desc>
        The client name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientIP" type="wstring" readonly="yes">
      <desc>
        The IP address of the client.
      </desc>
    </attribute>

    <attribute name="clientVersion" type="unsigned long" readonly="yes">
      <desc>
        The client software version number.
      </desc>
    </attribute>

    <attribute name="encryptionStyle" type="unsigned long" readonly="yes">
      <desc>
        Public key exchange method used when connection was established.
        Values: 0 - RDP4 public key exchange scheme.
        1 - X509 certificates were sent to client.
      </desc>
    </attribute>

  </interface>

  <interface
     name="IConsole" extends="$unknown"
     uuid="e3c6d4a1-a935-47ca-b16d-f9e9c496e53e"
     wsmap="managed"
     >
    <desc>
      The IConsole interface represents an interface to control virtual
      machine execution.

      The console object that implements the IConsole interface is obtained
      from a session object after the session for the given machine has been
      opened using one of <link to="IVirtualBox::openSession"/>,
      <link to="IVirtualBox::openRemoteSession"/> or
      <link to="IVirtualBox::openExistingSession"/> methods.

      Methods of the IConsole interface allow the caller to query the current
      virtual machine execution state, pause the machine or power it down, save
      the machine state or take a snapshot, attach and detach removable media
      and so on.

      <see>ISession</see>
    </desc>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Machine object this console is sessioned with.
        <note>
          This is a convenience property, it has the same value as
          <link to="ISession::machine"/> of the corresponding session
          object.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>
        Current execution state of the machine.
        <note>
          This property always returns the same value as the corresponding
          property of the IMachine object this console is sessioned with.
          For the process that owns (executes) the VM, this is the
          preferable way of querying the VM state, because no IPC
          calls are made.
        </note>
      </desc>
    </attribute>

    <attribute name="guest" type="IGuest" readonly="yes">
      <desc>Guest object.</desc>
    </attribute>

    <attribute name="keyboard" type="IKeyboard" readonly="yes">
      <desc>
        Virtual keyboard object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="mouse" type="IMouse" readonly="yes">
      <desc>
        Virtual mouse object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="display" type="IDisplay" readonly="yes">
      <desc>Virtual display object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="debugger" type="IMachineDebugger" readonly="yes">
      <desc>Debugging interface.</desc>
    </attribute>

    <attribute name="USBDevices" type="IUSBDeviceCollection" readonly="yes">
      <desc>
        Collection of USB devices currently attached to the virtual
        USB controller.
        <note>
          The collection is empty if the machine is not running.
        </note>
      </desc>
    </attribute>

    <attribute name="remoteUSBDevices" type="IHostUSBDeviceCollection" readonly="yes">
      <desc>
        List of USB devices currently attached to the remote VRDP client.
        Once a new device is physically attached to the remote host computer,
        it appears in this list and remains there until detached.
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
      <desc>
        Collection of shared folders for the current session.  These folders
        are called transient shared folders because they are available to the
        guest OS running inside the associated virtual machine only for the
        duration of the session (as opposed to
        <link to="IMachine::sharedFolders"/> which represent permanent shared
        folders). When the session is closed (e.g. the machine is powered down),
        these folders are automatically discarded.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="remoteDisplayInfo" type="IRemoteDisplayInfo" readonly="yes">
      <desc>
        Interface that provides information on Remote Display (VRDP) connection.
      </desc>
    </attribute>

    <method name="powerUp">
      <desc>
        Starts the virtual machine execution using the current machine
        state (that is, its current execution state, current settings and
        current hard disks).

        If the machine is powered off or aborted, the execution will
        start from the beginning (as if the real hardware were just
        powered on).

        If the machine is in the <link to="MachineState_Saved"/> state,
        it will continue its execution the point where the state has
        been saved.

        <note>
          Unless you are trying to write a new VirtualBox front-end that
          performs direct machine execution (like the VirtualBox or VBoxSDL
          front-ends), don't call <link to="IConsole::powerUp"/> in a direct
          session opened by <link to="IVirtualBox::openSession"/> and use this
          session only to change virtual machine settings. If you simply want to
          start virtual machine execution using one of the existing front-ends
          (for example the VirtualBox GUI or headless server), simply use
          <link to="IVirtualBox::openRemoteSession"/>; these front-ends will
          power up the machine automatically for you.
        </note>

        <see>#saveState</see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine already running.
        </result>
        <result name="VBOX_E_HOST_ERROR">
          Host interface does not exist or name not set.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerUpPaused">
      <desc>
        Identical to powerUp except that the VM will enter the
        <link to="MachineState_Paused"/> state, instead of
        <link to="MachineState_Running"/>.

        <see>#powerUp</see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine already running.
        </result>
        <result name="VBOX_E_HOST_ERROR">
          Host interface does not exist or name not set.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerDown">
      <desc>
        Stops the virtual machine execution.
        After this operation completes, the machine will go to the
        PoweredOff state.

        @deprecated This method will be removed in VirtualBox 2.1 where the
        powerDownAsync() method will take its name. Do not use this method in
        the code.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine must be Running, Paused or Stuck to be powered down.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Unable to power off or destroy virtual machine.
        </result>
      </desc>
    </method>

    <method name="powerDownAsync">
      <desc>
        Initiates the power down procedure to stop the virtual machine
        execution.

        The completion of the power down procedure is tracked using the returned
        IProgress object. After the operation is complete, the machine will go
        to the PoweredOff state.

        @warning This method will be renamed to "powerDown" in VirtualBox 2.1
        where the original powerDown() method will be removed. You will need to
        rename "powerDownAsync" to "powerDown" in your sources to make them
        build with version 2.1.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine must be Running, Paused or Stuck to be powered down.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="reset">
      <desc>Resets the virtual machine.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in reset operation.
        </result>
      </desc>
    </method>

    <method name="pause">
      <desc>Pauses the virtual machine execution.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in suspend operation.
        </result>
      </desc>
    </method>

    <method name="resume">
      <desc>Resumes the virtual machine execution.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Paused state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in resume operation.
        </result>
      </desc>
    </method>

    <method name="powerButton">
      <desc>Sends the ACPI power button event to the guest.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Controlled power off failed.
        </result>
      </desc>
    </method>

    <method name="sleepButton">
      <desc>Sends the ACPI sleep button event to the guest.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Sending sleep button event failed.
        </result>
      </desc>
    </method>

    <method name="getPowerButtonHandled">
      <desc>Checks if the last power button event was handled by guest.
        <result name="VBOX_E_PDM_ERROR">
          Checking if the event was handled by the guest OS failed.
        </result>
      </desc>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="getGuestEnteredACPIMode">
      <desc>Checks if the guest entered the ACPI mode G0 (working) or
        G1 (sleeping). If this method returns false, the guest will
        most likely not respond to external ACPI events.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
      </desc>
      <param name="entered" type="boolean" dir="return"/>
    </method>

    <method name="saveState">
      <desc>
        Saves the current execution state of a running virtual machine
        and stops its execution.

        After this operation completes, the machine will go to the
        Saved state. Next time it is powered up, this state will
        be restored and the machine will continue its execution from
        the place where it was saved.

        This operation differs from taking a snapshot to the effect
        that it doesn't create new differencing hard disks. Also, once
        the machine is powered up from the state saved using this method,
        the saved state is deleted, so it will be impossible to return
        to this state later.

        <note>
          On success, this method implicitly calls
          <link to="IMachine::saveSettings()"/> to save all current machine
          settings (including runtime changes to the DVD drive, etc.).
          Together with the impossibility to change any VM settings when it is
          in the Saved state, this guarantees adequate hardware
          configuration of the machine when it is restored from the saved
          state file.
        </note>

        <note>
          The machine must be in the Running or Paused state, otherwise
          the operation will fail.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither Running nor Paused.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Failed to create directory for saved state file.
        </result>

        <see><link to="#takeSnapshot"/></see>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Associates the given saved state file to the virtual machine.

        On success, the machine will go to the Saved state. Next time it is
        powered up, it will be restored from the adopted saved state and
        continue execution from the place where the saved state file was
        created.

        The specified saved state file path may be absolute or relative to the
        folder the VM normally saves the state to (usually,
        <link to="IMachine::snapshotFolder"/>).

        <note>
          It's a caller's responsibility to make sure the given saved state
          file is compatible with the settings of this virtual machine that
          represent its virtual hardware (memory size, hard disk configuration
          etc.). If there is a mismatch, the behavior of the virtual machine
          is undefined.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither PoweredOff nor Aborted.
        </result>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="discardSavedState">
      <desc>
        Discards (deletes) the saved state of the virtual machine
        previously created by <link to="#saveState"/>. Next time the
        machine is powered up, a clean boot will occur.
        <note>
          This operation is equivalent to resetting or powering off
          the machine without doing a proper shutdown in the guest OS.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in state Saved.
        </result>
      </desc>
    </method>

    <method name="getDeviceActivity">
      <desc>
        Gets the current activity type of a given device or device group.
        <result name="E_INVALIDARG">
          Invalid device type.
        </result>
      </desc>
      <param name="type" type="DeviceType" dir="in"/>
      <param name="activity" type="DeviceActivity" dir="return"/>
    </method>

    <method name="attachUSBDevice">
      <desc>
        Attaches a host USB device with the given UUID to the
        USB controller of the virtual machine.

        The device needs to be in one of the following states:
        <link to="USBDeviceState_Busy"/>,
        <link to="USBDeviceState_Available"/> or
        <link to="USBDeviceState_Held"/>,
        otherwise an error is immediately returned.

        When the device state is
        <link to="USBDeviceState_Busy">Busy</link>, an error may also
        be returned if the host computer refuses to release it for some reason.

        <see>IUSBController::deviceFilters, USBDeviceState</see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither Running nor Paused.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a USB controller.
        </result>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the host USB device to attach.</desc>
      </param>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Detaches an USB device with the given UUID from the USB controller
        of the virtual machine.

        After this method succeeds, the VirtualBox server re-initiates
        all USB filters as if the device were just physically attached
        to the host, but filters of this machine are ignored to avoid
        a possible automatic re-attachment.

        <see>IUSBController::deviceFilters, USBDeviceState</see>

        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a USB controller.
        </result>
        <result name="E_INVALIDARG">
          USB device not attached to this virtual machine.
        </result>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the USB device to detach.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Detached USB device.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a transient new shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine in Saved state or currently changing state.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder already exists or not accessible.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes a transient shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine in Saved state or currently changing state.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder does not exists.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="takeSnapshot">
      <desc>
        Saves the current execution state and all settings of the
        machine and creates differencing images for all
        normal (non-independent) hard disks.

        This method can be called for a PoweredOff, Saved, Running or
        Paused virtual machine. When the machine is PoweredOff, an
        offline <link to="ISnapshot">snapshot</link> is created,
        in all other cases -- an online snapshot.

        The taken snapshot is always based on the
        <link to="IMachine::currentSnapshot">current
          snapshot</link> of the associated virtual machine and becomes
        a new current snapshot.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings()"/> to
          save all current machine settings before taking an offline snapshot.
        </note>

        <see>ISnapshot, <link to="#saveState"/></see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine currently changing state.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Short name for the snapshot.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Optional description of the snapshot.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardSnapshot">
      <desc>

        Starts discarding the specified snapshot. The execution state
        and settings of the associated machine stored in the snapshot
        will be deleted. The contents of all differencing hard disks of
        this snapshot will be merged with the contents of their
        dependent child hard disks to keep the, disks valid (in other
        words, all changes represented by hard disks being discarded
        will be propagated to their child hard disks). After that, this
        snapshot's differencing hard disks will be deleted. The parent
        of this snapshot will become a new parent for all its child
        snapshots.

        If the discarded snapshot is the current one, its parent
        snapshot will become a new current snapshot. The current machine
        state is not directly affected in this case, except that
        currently attached differencing hard disks based on hard disks
        of the discarded snapshot will be also merged as described
        above.

        If the discarded snapshot is the first one (the root snapshot)
        and it has exactly one child snapshot, this child snapshot will
        become the first snapshot after discarding. If there are no
        children at all (i.e. the first snapshot is the only snapshot of
        the machine), both the current and the first snapshot of the
        machine will be set to null. In all other cases, the first
        snapshot cannot be discarded.

        You cannot discard the snapshot if it
        stores <link to="HardDiskType_Normal">normal</link> (non-differencing)
        hard disks that have differencing hard disks based on them. Snapshots of
        such kind can be discarded only when every normal hard disk has either
        no children at all or exactly one child. In the former case, the normal
        hard disk simply becomes unused (i.e. not attached to any VM). In the
        latter case, it receives all the changes stored in the child hard disk,
        and then it replaces the child hard disk in the configuration of the
        corresponding snapshot or machine.

        Also, you cannot discard the snapshot if it stores hard disks
        (of any type) having differencing child hard disks that belong
        to other machines. Such snapshots can be only discarded after
        you discard all snapshots of other machines containing "foreign"
        child disks, or detach these "foreign" child disks from machines
        they are attached to.

        One particular example of the snapshot storing normal hard disks
        is the first snapshot of a virtual machine that had normal hard
        disks attached when taking the snapshot. Be careful when
        discarding such snapshots because this implicitly commits
        changes (made since the snapshot being discarded has been taken)
        to normal hard disks (as described above), which may be not what
        you want.

        The virtual machine is put to
        the <link to="MachineState_Discarding">Discarding</link> state until
        the discard operation is completed.

        <note>
          The machine must not be running, otherwise the operation
          will fail.
        </note>

        <note>
          Child hard disks of all normal hard disks of the discarded snapshot
          must be accessible (see <link to="IMedium::state"/>) for this
          operation to succeed.  In particular, this means that all virtual
          machines, whose hard disks are directly or indirectly based on the
          hard disks of discarded snapshot, must be powered off.
        </note>
        <note>
          Merging hard disk contents can be very time and disk space
          consuming, if these disks are big in size and have many
          children. However, if the snapshot being discarded is the last
          (head) snapshot on the branch, the operation will be rather
          quick.
        </note>
        <note>
          Note that discarding the current snapshot
          will implicitly call <link to="IMachine::saveSettings()"/> to
          make all current machine settings permanent.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is running.
        </result>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to discard.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentState">
      <desc>
        This operation is similar to <link to="#discardSnapshot()"/> but
        affects the current machine state. This means that the state stored in
        the current snapshot will become a new current state, and all current
        settings of the machine and changes stored in differencing hard disks
        will be lost.

        After this operation is successfully completed, new empty differencing
        hard disks are created for all normal hard disks of the machine.

        If the current snapshot of the machine is an online snapshot, the
        machine will go to the <link to="MachineState_Saved"> saved
        state</link>, so that the next time it is powered on, the execution
        state will be restored from the current snapshot.

        <note>
          The machine must not be running, otherwise the operation will fail.
        </note>

        <note>
          If the machine state is <link to="MachineState_Saved">Saved</link>
          prior to this operation, the saved state file will be implicitly
          discarded (as if <link to="IConsole::discardSavedState()"/> were
          called).
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is running.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentSnapshotAndState">
      <desc>

        This method is equivalent to
        doing <link to="IConsole::discardSnapshot">discardSnapshot</link>
        (currentSnapshot.id(), progress) followed by
        <link to="#discardCurrentState()"/>.

        As a result, the machine will be fully restored from the
        snapshot preceding the current snapshot, while both the current
        snapshot and the current machine state will be discarded.

        If the current snapshot is the first snapshot of the machine (i.e. it
        has the only snapshot), the current machine state will be
        discarded <b>before</b> discarding the snapshot. In other words, the
        machine will be restored from its last snapshot, before discarding
        it. This differs from performing a single
        <link to="#discardSnapshot()"/> call (note that no
        <link to="#discardCurrentState()"/> will be possible after it)
        to the effect that the latter will preserve the current state instead of
        discarding it.

        Unless explicitly mentioned otherwise, all remarks and
        limitations of the above two methods also apply to this method.

        <note>
          The machine must not be running, otherwise the operation
          will fail.
        </note>

        <note>
          If the machine state is <link to="MachineState_Saved">Saved</link>
          prior to this operation, the saved state file will be implicitly
          discarded (as if <link to="#discardSavedState()"/> were
          called).
        </note>

        <note>
          This method is more efficient than calling both of the above
          methods separately: it requires less IPC calls and provides
          a single progress object.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is running.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="registerCallback">
      <desc>
        Registers a new console callback on this instance. The methods of the
        callback interface will be called by this instance when the appropriate
        event occurs.
      </desc>
      <param name="callback" type="IConsoleCallback" dir="in"/>
    </method>

    <method name="unregisterCallback">
      <desc>
        Unregisters the console callback previously registered using
        <link to="#registerCallback"/>.
        <result name="E_INVALIDARG">
          Given @a callback handler is not registered.
        </result>
      </desc>
      <param name="callback" type="IConsoleCallback" dir="in"/>
    </method>
  </interface>

  <!--
  // IHost
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IHostDVDDrive" extends="$unknown"
     uuid="21f86694-202d-4ce4-8b05-a63ff82dbf4c"
     wsmap="managed"
     >
    <desc>
      The IHostDVDDrive interface represents the physical CD/DVD drive
      hardware on the host. Used indirectly in <link to="IHost::DVDDrives"/>.
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Returns the platform-specific device identifier.
        On DOS-like platforms, it is a drive name (e.g. R:).
        On Unix-like platforms, it is a device name (e.g. /dev/hdc).
      </desc>
    </attribute>
    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Returns a human readable description for the drive.  This
        description usually contains the product and vendor name.  A
        @c null string is returned if the description is not available.
      </desc>
    </attribute>
    <attribute name="udi" type="wstring" readonly="yes">
      <desc>
        Returns the unique device identifier for the drive.  This
        attribute is reserved for future use instead of
        <link to="#name"/>. Currently it is not used and may return
        @c null on some platforms.
      </desc>
    </attribute>

  </interface>

  <enumerator
     name="IHostDVDDriveEnumerator" type="IHostDVDDrive"
     uuid="1ed7cfaf-c363-40df-aa4e-89c1afb7d96b"
     />

  <collection
     name="IHostDVDDriveCollection" type="IHostDVDDrive"
     enumerator="IHostDVDDriveEnumerator"
     uuid="1909c533-1a1e-445f-a4e1-a267cffc30ed"
     readonly="yes"
     >
    <method name="findByName">
      <desc>
        Searches this collection for a host drive with the given name.
        <note>
          The method returns an error if the given name does not
          correspond to any host drive in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host drive to search for</desc>
      </param>
      <param name="drive" type="IHostDVDDrive" dir="return">
        <desc>Found host drive object</desc>
      </param>
    </method>
  </collection>

  <interface
     name="IHostFloppyDrive" extends="$unknown"
     uuid="b6a4d1a9-4221-43c3-bd52-021a5daa9ed2"
     wsmap="managed"
     >
    <desc>
      The IHostFloppyDrive interface represents the physical floppy drive
      hardware on the host. Used indirectly in <link to="IHost::floppyDrives"/>.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Returns the platform-specific device identifier.
        On DOS-like platforms, it is a drive name (e.g. A:).
        On Unix-like platforms, it is a device name (e.g. /dev/fd0).
      </desc>
    </attribute>
    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Returns a human readable description for the drive.  This
        description usually contains the product and vendor name.  A
        @c null string is returned if the description is not available.
      </desc>
    </attribute>
    <attribute name="udi" type="wstring" readonly="yes">
      <desc>
        Returns the unique device identifier for the drive.  This
        attribute is reserved for future use instead of
        <link to="#name"/>. Currently it is not used and may return
        @c null on some platforms.
      </desc>
    </attribute>
  </interface>

  <enumerator
     name="IHostFloppyDriveEnumerator" type="IHostFloppyDrive"
     uuid="ce04c924-4f54-432a-9dec-11fddc3ea875"
     />

  <collection
     name="IHostFloppyDriveCollection" type="IHostFloppyDrive"
     enumerator="IHostFloppyDriveEnumerator"
     uuid="fd84bb86-c59a-4037-a557-755ff263a460"
     readonly="yes"
     >
    <method name="findByName">
      <desc>
        Searches this collection for a host drive with the given name.
        <note>
          The method returns an error if the given name does not
          correspond to any host drive in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host drive to search for</desc>
      </param>
      <param name="drive" type="IHostFloppyDrive" dir="return">
        <desc>Found host drive object</desc>
      </param>
    </method>
  </collection>

  <enum
    name="HostNetworkInterfaceType"
    uuid="763754FA-3246-4539-9590-9E603EDBF706"
  >
    <desc>
      Type of encapsulation. Ethernet encapsulation includes both wired and
      wireless Ethernet connections.
      <see>IHostNetworkInterface</see>
    </desc>

    <const name="Unknown" value="0">
      <desc>
        The type of interface cannot be determined.
      </desc>
    </const>
    <const name="Ethernet" value="1">
      <desc>
        Ethernet frame encapsulation.
      </desc>
    </const>
    <const name="PPP" value="2">
      <desc>
        Point-to-point protocol encapsulation.
      </desc>
    </const>
    <const name="SLIP" value="3">
      <desc>
        Serial line IP encapsulation.
      </desc>
    </const>
  </enum>

  <enum
    name="HostNetworkInterfaceStatus"
    uuid="CC474A69-2710-434B-8D99-C38E5D5A6F41"
  >
    <desc>
      Current status of the interface.
      <see>IHostNetworkInterface</see>
    </desc>

    <const name="Unknown" value="0">
      <desc>
        The state of interface cannot be determined.
      </desc>
    </const>
    <const name="Up" value="1">
      <desc>
        The interface is fully operational.
      </desc>
    </const>
    <const name="Down" value="2">
      <desc>
        The interface is not functioning.
      </desc>
    </const>
  </enum>

  <interface
     name="IHostNetworkInterface" extends="$unknown"
     uuid="832720ac-2df6-41d4-a867-a0b40df14c7f"
     wsmap="managed"
     >
    <desc>
      Reprents one of host's network interfaces. IP V6 address and network
      mask are strings of 32 hexdecimal digits grouped by four. Groups are
      separated by colons.
      For example, fe80:0000:0000:0000:021e:c2ff:fed2:b030.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>Returns the host network interface name.</desc>
    </attribute>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>Returns the interface UUID.</desc>
    </attribute>

    <attribute name="IPAddress" type="unsigned long" readonly="yes">
      <desc>Returns the IP V4 address of the interface.</desc>
    </attribute>

    <attribute name="networkMask" type="unsigned long" readonly="yes">
      <desc>Returns the network mask of the interface.</desc>
    </attribute>

    <attribute name="IPV6Address" type="wstring" readonly="yes">
      <desc>Returns the IP V6 address of the interface.</desc>
    </attribute>

    <attribute name="IPV6NetworkMask" type="wstring" readonly="yes">
      <desc>Returns the IP V6 network mask of the interface.</desc>
    </attribute>

    <attribute name="hardwareAddress" type="wstring" readonly="yes">
      <desc>Returns the hardware address. For Ethernet it is MAC address.</desc>
    </attribute>

    <attribute name="type" type="HostNetworkInterfaceType" readonly="yes">
      <desc>Type of protocol encapsulation used.</desc>
    </attribute>

    <attribute name="status" type="HostNetworkInterfaceStatus" readonly="yes">
      <desc>Status of the interface.</desc>
    </attribute>
  </interface>

  <interface
     name="IHost" extends="$unknown"
     uuid="f39438d7-abfd-409b-bc80-5f5291d92897"
     wsmap="managed"
     >
    <desc>
      The IHost interface represents the physical machine that this VirtualBox
      installation runs on.

      An object implementing this interface is returned by the
      <link to="IVirtualBox::host" /> attribute. This interface contains
      read-only information about the host's physical hardware (such as what
      processors and disks are available, what the host operating system is,
      and so on) and also allows for manipulating some of the host's hardware,
      such as global USB device filters and host interface networking.

    </desc>
    <attribute name="DVDDrives" type="IHostDVDDriveCollection" readonly="yes">
      <desc>List of DVD drives available on the host.</desc>
    </attribute>

    <attribute name="floppyDrives" type="IHostFloppyDriveCollection" readonly="yes">
      <desc>List of floppy drives available on the host.</desc>
    </attribute>

    <attribute name="USBDevices" type="IHostUSBDeviceCollection" readonly="yes">
      <desc>
        List of USB devices currently attached to the host.
        Once a new device is physically attached to the host computer,
        it appears in this list and remains there until detached.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="USBDeviceFilters" type="IHostUSBDeviceFilterCollection" readonly="yes">
      <desc>
        List of USB device filters in action.
        When a new device is physically attached to the host computer,
        filters from this list are applied to it (in order they are stored
        in the list). The first matched filter will determine the
        <link to="IHostUSBDeviceFilter::action">action</link>
        performed on the device.

        Unless the device is ignored by these filters, filters of all
        currently running virtual machines
        (<link to="IUSBController::deviceFilters"/>) are applied to it.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>IHostUSBDeviceFilter, USBDeviceState</see>
      </desc>
    </attribute>

    <attribute name="networkInterfaces" type="IHostNetworkInterface" safearray="yes" readonly="yes">
      <desc>List of host network interfaces currently defined on the host.</desc>
    </attribute>

    <attribute name="processorCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs installed in the host system.</desc>
    </attribute>

    <attribute name="processorOnlineCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs online in the host system.</desc>
    </attribute>

    <method name="getProcessorSpeed">
      <desc>Query the (approximate) maximum speed of a specified host CPU in
        Megahertz.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.
        </desc>
      </param>
      <param name="speed" type="unsigned long" dir="return">
        <desc>
          Speed value. 0 is returned if value is not known or @a cpuId is
          invalid.
        </desc>
      </param>
    </method>

    <method name="getProcessorFeature">
      <desc>Query whether a CPU feature is supported or not.</desc>
      <param name="feature" type="ProcessorFeature" dir="in">
        <desc>
          CPU Feature identifier.
        </desc>
      </param>
      <param name="supported" type="boolean" dir="return">
        <desc>
          Feature is supported or not.
        </desc>
      </param>
    </method>

    <method name="getProcessorDescription">
      <desc>Query the model string of a specified host CPU.
        <note>
          This function is not implemented in the current version of the
          product.
        </note>
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.
        </desc>
      </param>
      <param name="description" type="wstring" dir="return">
        <desc>
          Model string. A NULL string is returned if value is not known or
          @a cpuId is invalid.
        </desc>
      </param>
    </method>

    <attribute name="memorySize" type="unsigned long" readonly="yes">
      <desc>Amount of system memory in megabytes installed in the host system.</desc>
    </attribute>

    <attribute name="memoryAvailable" type="unsigned long" readonly="yes">
      <desc>Available system memory in the host system.</desc>
    </attribute>

    <attribute name="operatingSystem" type="wstring" readonly="yes">
      <desc>Name of the host system's operating system.</desc>
    </attribute>

    <attribute name="OSVersion" type="wstring" readonly="yes">
      <desc>Host operating system's version string.</desc>
    </attribute>

    <attribute name="UTCTime" type="long long" readonly="yes">
      <desc>Returns the current host time in milliseconds since 1970-01-01 UTC.</desc>
    </attribute>

<if target="midl">
    <method name="createHostNetworkInterface">
      <desc>
        Creates a new adapter for Host Interface Networking.
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Adapter name.
        </desc>
      </param>
      <param name="hostInterface" type="IHostNetworkInterface" dir="out">
        <desc>
          Created host interface object.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>
    <method name="removeHostNetworkInterface">
      <desc>
        Removes the given host network interface.
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No host network interface matching @a id found.
        </result>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>
          Adapter GUID.
        </desc>
      </param>
      <param name="hostInterface" type="IHostNetworkInterface" dir="out">
        <desc>
          Removed host interface object.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>
</if>

    <method name="createUSBDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to <tt>null</tt> (any match),
        <i>active</i> is <tt>false</tt> (the filter is not active).

        The created filter can be added to the list of filters using
        <link to="#insertUSBDeviceFilter()"/>.

        <see>#USBDeviceFilters</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IHostUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertUSBDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from <tt>0</tt>. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added at the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter that is already in the list, will return an
          error.
        </note>
        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>#USBDeviceFilters</see>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          USB device filter is not created within this VirtualBox instance.
        </result>
        <result name="E_INVALIDARG">
          USB device filter already in list.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeUSBDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from <tt>0</tt>. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>#USBDeviceFilters</see>

        <result name="E_INVALIDARG">
          USB device filter list empty or invalid @a position.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="return">
        <desc>Removed USB device filter.</desc>
      </param>
    </method>

  </interface>

  <!--
  // ISystemProperties
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="ISystemProperties"
     extends="$unknown"
     uuid="604afeba-5963-4d12-a577-902ffb96352a"
     wsmap="managed"
     >
    <desc>
      The ISystemProperties interface represents global properties of the given
      VirtualBox installation.

      These properties define limits and default values for various attributes
      and parameters. Most of the properties are read-only, but some can be
      changed by a user.
    </desc>

    <attribute name="minGuestRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="minGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxVDISize" type="unsigned long long" readonly="yes">
      <desc>Maximum size of a virtual disk image in Megabytes.</desc>
    </attribute>

    <attribute name="networkAdapterCount" type="unsigned long" readonly="yes">
      <desc>
        Number of network adapters associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="serialPortCount" type="unsigned long" readonly="yes">
      <desc>
        Number of serial ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="parallelPortCount" type="unsigned long" readonly="yes">
      <desc>
        Number of parallel ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="maxBootPosition" type="unsigned long" readonly="yes">
      <desc>
        Maximum device position in the boot order. This value corresponds
        to the total number of devices a machine can boot from, to make it
        possible to include all possible devices to the boot list.
        <see><link to="IMachine::setBootOrder()"/></see>
      </desc>
    </attribute>

    <attribute name="defaultMachineFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open
        existing machines when a settings file name contains no
        path.

        The initial value of this property is
        <tt>&lt;</tt><link to="IVirtualBox::homeFolder">
          VirtualBox_home</link><tt>&gt;/Machines</tt>.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
        <note>
          When settings this property, the specified path can be
          absolute (full path) or relative
          to the <link to="IVirtualBox::homeFolder">
            VirtualBox home directory</link>.
          When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>

        <see>
          <link to="IVirtualBox::createMachine()"/>,
          <link to="IVirtualBox::openMachine()"/>
        </see>
      </desc>
    </attribute>

    <attribute name="defaultHardDiskFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open existing
        virtual disks.

        This path is used when the storage unit of a hard disk is a regular file
        in the host's file system and only a file name that contains no path is
        given.

        The initial value of this property is
        <tt>&lt;</tt>
        <link to="IVirtualBox::homeFolder">VirtualBox_home</link>
        <tt>&gt;/HardDisks</tt>.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
        <note>
          When settings this property, the specified path can be relative
          to the
          <link to="IVirtualBox::homeFolder">VirtualBox home directory</link> or
          absolute. When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>

        <see>
          IHardDisk2,
          <link to="IVirtualBox::createHardDisk2()"/>,
          <link to="IVirtualBox::openHardDisk2()"/>,
          <link to="IMedium::location"/>
        </see>
      </desc>
    </attribute>

    <attribute name="hardDiskFormats" type="IHardDiskFormat" safearray="yes" readonly="yes">
      <desc>
        List of all hard disk storage formats supported by this VirtualBox
        installation.

        Note that the virtual hard disk framework is backend-based, therefore
        the list of supported formats depends on what backends are currently
        installed.

        <see>
          <link to="IHardDiskFormat"/>,
        </see>
      </desc>
    </attribute>

    <attribute name="defaultHardDiskFormat" type="wstring">
      <desc>
        Identifier of the default hard disk format used by VirtualBox.

        The hard disk format set by this attribute is used by VirtualBox
        when the hard disk format was not specified explicitly. One example is
        <link to="IVirtualBox::createHardDisk2()"/> with the <tt>null</tt>
        format argument. A more complex example is implicit creation of
        differencing hard disks when taking a snapshot of a virtual machine:
        this operation will try to use a format of the parent hard disk first
        and if this format does not support differencing hard disks the default
        format specified by this argument will be used.

        The list of supported hard disk formats may be obtained by the
        <link  to="#hardDiskFormats"/> call. Note that the default hard disk
        format must have a capability to create differencing hard disks;
        otherwise opeartions that create hard disks implicitly may fail
        unexpectedly.

        The initial value of this property is <tt>VDI</tt> in the current
        version of the VirtualBox product, but may change in the future.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>

        <see>
          <link to="#hardDiskFormats"/>,
          <link to="IHardDiskFormat::id"/>,
          <link to="IVirtualBox::createHardDisk2()"/>
        </see>
      </desc>
    </attribute>

    <attribute name="remoteDisplayAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for VRDP clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration.

        The system library extension (".DLL" or ".so") must be omitted.
        A full path can be specified; if not, then the library must reside on the
        system's default library path.

        The default value of this property is <tt>VRDPAuth</tt>. There is a library
        of that name in one of the default VirtualBox library directories.

        For details about VirtualBox authentication libraries and how to implement
        them, please refer to the VirtualBox manual.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
      </desc>
    </attribute>

    <attribute name="webServiceAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for webservice clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration and will be called from
        within the <link to="IWebsessionManager::logon" /> implementation.

        As opposed to <link to="ISystemProperties::remoteDisplayAuthLibrary" />,
        there is no per-VM setting for this, as the webservice is a global
        resource (if it is running). Only for this setting (for the webservice),
        setting this value to a literal "null" string disables authentication,
        meaning that <link to="IWebsessionManager::logon" /> will always succeed,
        no matter what user name and password are supplied.

        The initial value of this property is <tt>VRDPAuth</tt>,
        meaning that the webservice will use the same authentication
        library that is used by default for VBoxVRDP (again, see
        <link to="ISystemProperties::remoteDisplayAuthLibrary" />).
        The format and calling convention of authentication libraries
        is the same for the webservice as it is for VBoxVRDP.

      </desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="boolean">
      <desc>
        This specifies the default value for hardware virtualization
        extensions. If enabled, virtual machines will make use of
        hardware virtualization extensions such as Intel VT-x and
        AMD-V by default. This value can be overridden by each VM
        using their <link to="IMachine::HWVirtExEnabled" /> property.
      </desc>
    </attribute>

    <attribute name="LogHistoryCount" type="unsigned long">
      <desc>
        This value specifies how many old release log files are kept.
       </desc>
    </attribute>
  </interface>

  <!--
  // IGuest
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IGuestOSType" extends="$unknown"
    uuid="bc415228-eed0-402c-92f5-96fc4e2dd7e4"
    wsmap="struct"
  >
    <desc>
    </desc>

    <attribute name="familyId" type="wstring" readonly="yes">
      <desc>Guest OS family identifier string.</desc>
    </attribute>

    <attribute name="familyDescription" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS family.</desc>
    </attribute>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>Guest OS identifier string.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS.</desc>
    </attribute>

    <attribute name="is64Bit" type="boolean" readonly="yes">
      <desc>Returns @c true if the given OS is 64-bit</desc>
    </attribute>

    <attribute name="recommendedIOAPIC" type="boolean" readonly="yes">
      <desc>Returns @c true if IO APIC recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedVirtEx" type="boolean" readonly="yes">
      <desc>Returns @c true if VT-x or AMD-V recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedRAM" type="unsigned long" readonly="yes">
      <desc>Recommended RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedVRAM" type="unsigned long" readonly="yes">
      <desc>Recommended video RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedHDD" type="unsigned long" readonly="yes">
      <desc>Recommended hard disk size in Megabytes.</desc>
    </attribute>

    <attribute name="adapterType" type="NetworkAdapterType" readonly="yes">
      <desc>Returns recommended network adapter for this OS type.</desc>
    </attribute>
  </interface>


  <enumerator
     name="IGuestOSTypeEnumerator" type="IGuestOSType"
     uuid="a3335e02-4669-4e3c-80c7-c4dc7056a07c"
     />

  <collection
     name="IGuestOSTypeCollection" type="IGuestOSType" enumerator="IGuestOSTypeEnumerator"
     uuid="a5e36749-a610-498b-9f29-2e36c1042d65"
     readonly="yes"
     />

  <interface
     name="IGuest" extends="$unknown"
     uuid="d8556fca-81bc-12af-fca3-365528fa38ca"

     wsmap="suppress"
     >
    <desc>
      The IGuest interface represents information about the operating system
      running inside the virtual machine. Used in
      <link to="IConsole::guest"/>.

      IGuest provides information about the guest operating system, whether
      Guest Additions are installed and other OS-specific virtual machine
      properties.
    </desc>

    <attribute name="OSTypeId" type="wstring" readonly="yes">
      <desc>
        Identifier of the Guest OS type as reported by the Guest
        Additions.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          If Guest Additions are not installed, this value will be
          the same as <link to="IMachine::OSTypeId"/>.
        </note>
      </desc>
    </attribute>

    <attribute name="additionsActive" type="boolean" readonly="yes">
      <desc>
        Flag whether the Guest Additions are installed and active
        in which case their version will be returned by the
        <link to="#additionsVersion"/> property.
      </desc>
    </attribute>

    <attribute name="additionsVersion" type="wstring" readonly="yes">
      <desc>
        Version of the Guest Additions (3 decimal numbers separated
        by dots) or empty when the Additions are not installed. The
        Additions may also report a version but yet not be active as
        the version might be refused by VirtualBox (incompatible) or
        other failures occurred.
      </desc>
    </attribute>

    <attribute name="supportsSeamless" type="boolean" readonly="yes">
      <desc>
        Flag whether seamless guest display rendering (seamless desktop
        integration) is supported.
      </desc>
    </attribute>

    <attribute name="supportsGraphics" type="boolean" readonly="yes">
      <desc>
        Flag whether the guest is in graphics mode.  If it is not, then
        seamless rendering will not work, resize hints are not immediately
        acted on and guest display resizes are probably not initiated by
        the guest additions.
      </desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Guest system memory balloon size in megabytes.</desc>
    </attribute>

    <attribute name="statisticsUpdateInterval" type="unsigned long">
      <desc>Interval to update guest statistics in seconds.</desc>
    </attribute>

    <method name="setCredentials">
      <desc>
        Store login credentials that can be queried by guest operating
        systems with Additions installed. The credentials are transient
        to the session and the guest may also choose to erase them. Note
        that the caller cannot determine whether the guest operating system
        has queried or made use of the credentials.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="userName" type="wstring" dir="in">
        <desc>User name string, can be empty</desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>Password string, can be empty</desc>
      </param>
      <param name="domain" type="wstring" dir="in">
        <desc>Domain name (guest logon scheme specific), can be empty</desc>
      </param>
      <param name="allowInteractiveLogon" type="boolean" dir="in">
        <desc>
          Flag whether the guest should alternatively allow the user to
          interactively specify different credentials. This flag might
          not be supported by all versions of the Additions.
        </desc>
      </param>
    </method>

    <method name="getStatistic">
      <desc>
        Query specified guest statistics as reported by the VirtualBox Additions.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>Virtual CPU id; not relevant for all statistic types</desc>
      </param>
      <param name="statistic" type="GuestStatisticType" dir="in">
        <desc>Statistic type.</desc>
      </param>
      <param name="statVal" type="unsigned long" dir="out">
        <desc>Statistics value</desc>
      </param>
    </method>

  </interface>


  <!--
  // IProgress
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IProgressEnumerator" type="IProgress"
     uuid="e0380522-4ef1-48f4-856c-e455177ccb2d"
     />

  <collection
     name="IProgressCollection" type="IProgress" enumerator="IProgressEnumerator"
     uuid="78B76A7C-F0F2-467c-9F0E-F089A54EE957"
     readonly="yes"
     />

  <interface
     name="IProgress" extends="$unknown"
     uuid="10CC03A1-717E-429b-992D-C67B56175A51"
     wsmap="managed"
     >
    <desc>
      The IProgress interface represents a task progress object that allows
      to wait for the completion of some asynchronous task.

      The task consists of one or more operations that run sequentially,
      one after one. There is an individual percent of completion of the
      current operation and the percent of completion of the task as a
      whole. Similarly, you can wait for the completion of a particular
      operation or for the completion of the whole task.

      Every operation is identified by a number (starting from 0)
      and has a separate description.
    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>ID of the task.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Description of the task.</desc>
    </attribute>

    <attribute name="initiator" type="$unknown" readonly="yes">
      <desc>Initiator of the task.</desc>
    </attribute>

    <attribute name="cancelable" type="boolean" readonly="yes">
      <desc>Whether the task can be interrupted.</desc>
    </attribute>

    <attribute name="percent" type="long" readonly="yes">
      <desc>
        Current task progress value in percent.
        This value depends on how many operations are already complete.
      </desc>
    </attribute>

    <attribute name="completed" type="boolean" readonly="yes">
      <desc>Whether the task has been completed.</desc>
    </attribute>

    <attribute name="canceled" type="boolean" readonly="yes">
      <desc>Whether the task has been canceled.</desc>
    </attribute>

    <attribute name="resultCode" type="result" readonly="yes">
      <desc>
        Result code of the progress task.
        Valid only if <link to="#completed"/> is true.
      </desc>
    </attribute>

    <attribute name="errorInfo" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Extended information about the unsuccessful result of the
        progress operation. May be NULL when no extended information
        is available.
        Valid only if <link to="#completed"/> is true and
        <link to="#resultCode"/> indicates a failure.
      </desc>
    </attribute>

    <attribute name="operationCount" type="unsigned long" readonly="yes">
      <desc>
        Number of operations this task is divided into.
        Every task consists of at least one operation.
      </desc>
    </attribute>

    <attribute name="operation" type="unsigned long" readonly="yes">
      <desc>Number of the operation being currently executed.</desc>
    </attribute>

    <attribute name="operationDescription" type="wstring" readonly="yes">
      <desc>
        Description of the operation being currently executed.
      </desc>
    </attribute>

    <attribute name="operationPercent" type="long" readonly="yes">
      <desc>Current operation progress value in percent.</desc>
    </attribute>

    <method name="waitForCompletion">
      <desc>
        Waits until the task is done (including all operations) with a
        given timeout.

        <result name="VBOX_E_IPRT_ERROR">
          Failed to wait for task completion.
        </result>

      </desc>
      <param name="timeout" type="long" dir="in">
        <desc>
          Timeout value in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
    </method>

    <method name="waitForOperationCompletion">
      <desc>
        Waits until the given operation is done with a given timeout.

        <result name="VBOX_E_IPRT_ERROR">
          Failed to wait for operation completion.
        </result>

      </desc>
      <param name="operation" type="unsigned long" dir="in">
        <desc>
          Number of the operation to wait for.
          Must be less than <link to="#operationCount"/>.
        </desc>
      </param>
      <param name="timeout" type="long" dir="in">
        <desc>
          Timeout value in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
    </method>

    <method name="cancel">
      <desc>
        Cancels the task.
        <note>
          If <link to="#cancelable"/> is <tt>false</tt>, then
          this method will fail.
        </note>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Operation cannot be canceled.
        </result>

      </desc>
    </method>

  </interface>


  <!--
  // ISnapshot
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="ISnapshotEnumerator" type="ISnapshot"
     uuid="25cfa2a4-1f1d-4f05-9658-b7a5894ef1a3"
     />

  <collection
     name="ISnapshotCollection" type="ISnapshot"
     enumerator="ISnapshotEnumerator"
     uuid="23852e3c-94cd-4801-ab05-ed35675b3894"
     readonly="yes"
     />

  <interface
     name="ISnapshot" extends="$unknown"
     uuid="9f1bbf79-13b0-4da2-abba-4a992c65c083"
     wsmap="managed"
     >
    <desc>
      The ISnapshot interface represents a snapshot of the virtual
      machine.

      The <i>snapshot</i> stores all the information about a virtual
      machine necessary to bring it to exactly the same state as it was at
      the time of taking the snapshot. The snapshot includes:

      <ul>
        <li>all settings of the virtual machine (i.e. its hardware
          configuration: RAM size, attached hard disks, etc.)
        </li>
        <li>the execution state of the virtual machine (memory contents,
          CPU state, etc.).
        </li>
      </ul>

      Snapshots can be <i>offline</i> (taken when the VM is powered off)
      or <i>online</i> (taken when the VM is running). The execution
      state of the offline snapshot is called a <i>zero execution state</i>
      (it doesn't actually contain any information about memory contents
      or the CPU state, assuming that all hardware is just powered off).

      <h3>Snapshot branches</h3>

      Snapshots can be chained. Chained snapshots form a branch where
      every next snapshot is based on the previous one. This chaining is
      mostly related to hard disk branching (see <link to="IHardDisk2"/>
      description). This means that every time a new snapshot is created,
      a new differencing hard disk is implicitly created for all normal
      hard disks attached to the given virtual machine. This allows to
      fully restore hard disk contents when the machine is later reverted
      to a particular snapshot.

      In the current implementation, multiple snapshot branches within one
      virtual machine are not allowed. Every machine has a single branch,
      and <link to="IConsole::takeSnapshot()"/> operation adds a new
      snapshot to the top of that branch.

      Existing snapshots can be discarded using
      <link to="IConsole::discardSnapshot()"/>.

      <h3>Current snapshot</h3>

      Every virtual machine has a current snapshot, identified by
      <link to="IMachine::currentSnapshot"/>. This snapshot is used as
      a base for the <i>current machine state</i> (see below), to the effect
      that all normal hard disks of the machine and its execution
      state are based on this snapshot.

      In the current implementation, the current snapshot is always the
      last taken snapshot (i.e. the head snapshot on the branch) and it
      cannot be changed.

      The current snapshot is <tt>null</tt> if the machine doesn't have
      snapshots at all; in this case the current machine state is just
      current settings of this machine plus its current execution state.

      <h3>Current machine state</h3>

      The current machine state is what represented by IMachine instances got
      directly from IVirtualBox
      using <link
      to="IVirtualBox::getMachine()">getMachine()</link>, <link
      to="IVirtualBox::findMachine()">findMachine()</link>, etc. (as opposed
      to instances returned by <link to="ISnapshot::machine"/>).  This state
      is always used when the machine is <link to="IConsole::powerUp"> powered
      on</link>.

      The current machine state also includes the current execution state.
      If the machine is being currently executed
      (<link to="IMachine::state"/> is <link to="MachineState_Running"/>
      and above), its execution state is just what's happening now.
      If it is powered off (<link to="MachineState_PoweredOff"/> or
      <link to="MachineState_Aborted"/>), it has a zero execution state.
      If the machine is saved (<link to="MachineState_Saved"/>), its
      execution state is what saved in the execution state file
      (<link to="IMachine::stateFilePath"/>).

      If the machine is in the saved state, then, next time it is powered
      on, its execution state will be fully restored from the saved state
      file and the execution will continue from the point where the state
      was saved.

      Similarly to snapshots, the current machine state can be discarded
      using <link to="IConsole::discardCurrentState()"/>.

      <h3>Taking and discarding snapshots</h3>

      The table below briefly explains the meaning of every snapshot
      operation:

      <table>
        <tr><th>Operation</th><th>Meaning</th><th>Remarks</th></tr>

        <tr><td><link to="IConsole::takeSnapshot()"/></td>

          <td>Save the current state of the virtual machine, including all
            settings, contents of normal hard disks and the current modifications
            to immutable hard disks (for online snapshots)</td>

          <td>The current state is not changed (the machine will continue
            execution if it is being executed when the snapshot is
            taken)</td></tr>

        <tr><td><link to="IConsole::discardSnapshot()"/></td>

          <td>Forget the state of the virtual machine stored in the snapshot:
            dismiss all saved settings and delete the saved execution state (for
            online snapshots)</td>

          <td>Other snapshots (including child snapshots, if any) and the
            current state are not directly affected</td></tr>

        <tr><td><link to="IConsole::discardCurrentState()"/></td>

          <td>Restore the current state of the virtual machine from the state
            stored in the current snapshot, including all settings and hard disk
            contents</td>

          <td>The current state of the machine existed prior to this operation
            is lost</td></tr>

        <tr><td><link to="IConsole::discardCurrentSnapshotAndState()"/></td>

          <td>Completely revert the virtual machine to the state it was in
            before the current snapshot has been taken</td>

          <td>The current state, as well as the current snapshot, are
            lost</td></tr>

      </table>

    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>UUID of the snapshot.</desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>Short name of the snapshot.</desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>Optional description of the snapshot.</desc>
    </attribute>

    <attribute name="timeStamp" type="long long" readonly="yes">
      <desc>
        Time stamp of the snapshot, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="online" type="boolean" readonly="yes">
      <desc>
        <tt>true</tt> if this snapshot is an online snapshot and
        <tt>false</tt> otherwise.

        <note>
          When this attribute is <tt>true</tt>, the
          <link to="IMachine::stateFilePath"/> attribute of the
          <link to="#machine"/> object associated with this snapshot
          will point to the saved state file. Otherwise, it will be
          <tt>null</tt>.
        </note>
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Virtual machine this snapshot is taken on. This object
        stores all settings the machine had when taking this snapshot.
        <note>
          The returned machine object is immutable, i.e. no
          any settings can be changed.
        </note>
      </desc>
    </attribute>

    <attribute name="parent" type="ISnapshot" readonly="yes">
      <desc>
        Parent snapshot (a snapshot this one is based on).
        <note>
          It's not an error to read this attribute on a snapshot
          that doesn't have a parent -- a null object will be
          returned to indicate this.
        </note>
      </desc>
    </attribute>

    <attribute name="children" type="ISnapshotCollection" readonly="yes">
      <desc>
        Child snapshots (all snapshots having this one as a parent).
        <note>
          In the current implementation, there can be only one
          child snapshot, or no children at all, meaning this is the
          last (head) snapshot.
        </note>
      </desc>
    </attribute>

  </interface>


  <!--
  // IMedia
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MediaState"
    uuid="8b86e03c-2f1c-412a-8fbd-326f62701200"
  >
    <desc>
      Virtual media state.
      <see>IMedia</see>
    </desc>

    <const name="NotCreated" value="0">
      <desc>
        Associated media storage does not exist (either was not created yet or
        was deleted).
      </desc>
    </const>
    <const name="Created" value="1">
      <desc>
        Associated storage exists and accessible.
      </desc>
    </const>
    <const name="LockedRead" value="2">
      <desc>
        Media is locked for reading, no data modification is possible.
      </desc>
    </const>
    <const name="LockedWrite" value="3">
      <desc>
        Media is locked for writing, no concurrent data reading or modification
        is possible.
      </desc>
    </const>
    <const name="Inaccessible" value="4">
      <desc>
        Associated media storage is not accessible.
      </desc>
    </const>
    <const name="Creating" value="5">
      <desc>
        Associated media storage is being created.
      </desc>
    </const>
    <const name="Deleting" value="6">
      <desc>
        Associated media storage is being deleted.
      </desc>
    </const>
  </enum>

  <interface
    name="IMedium" extends="$unknown"
    uuid="a7fb3bfb-c180-4274-bae4-7fbc89046e13"
    wsmap="managed"
  >
    <desc>
      The IMedium interface is a common interface for all objects representing
      virtual media such as hard disks, DVD images.

      Each medium is associated with a storage unit (such as a file on the host
      computer or a network resource) that holds actual data. The location of
      the storage unit is represented by the #location attribute. The value of
      this attribute is media type dependent.

      The exact media type may be determined by querying the appropriate
      interface such as:
      <ul>
        <li>IHardDisk2 (virtual hard disks)</li>
        <li>IDVDImage2 (standard CD/DVD ISO image files)</li>
        <li>IFloppyImage2 (raw floppy image files)</li>
      </ul>

      Existing media are opened using the following methods, depending on the
      media type:
      <ul>
        <li><link to="IVirtualBox::openHardDisk2()"/></li>
        <li><link to="IVirtualBox::openDVDImage()"/></li>
        <li><link to="IVirtualBox::openFloppyImage()"/></li>
      </ul>

      New hard disk media are created using the
      <link to="IVirtualBox::createHardDisk2()"/> method. CD/DVD and floppy
      images are created outside VirtualBox, usually by storing a copy
      of the real medium of the corresponding type in a regular file.

      <h3>Known Media</h3>

      When an existing medium gets opened for the first time, it gets
      automatically remembered by the given VirtualBox installation or, in other
      words, becomes a <i>known medium</i>. Known media are stored in the media
      registry transparently maintained by VirtualBox and stored in settings
      files so that this registry is preserved when VirtualBox is not running.

      Newly created virtual hard disks get remembered only when the associated
      storage unit is actually created (see IHardDisk2 for more details).

      All known media can be enumerated using
      <link to="IVirtualBox::hardDisks2"/>,
      <link to="IVirtualBox::DVDImages"/> and
      <link to="IVirtualBox::floppyImages"/> attributes. Individual media can be
      quickly found by UUID using <link to="IVirtualBox::getHardDisk2()"/>
      and similar methods or by location using
      <link to="IVirtualBox::findHardDisk2()"/> and similar methods.

      Only known media can be attached to virtual machines.

      Removing known media from the media registry is performed when the given
      medium is closed using the <link to="#close()"/> method or when its
      associated storage unit is deleted (only for hard disks).

      <h3>Accessibility Checks</h3>

      The given medium (with the created storage unit) is considered to be
      <i>accessible</i> when its storage unit can be successfully read from.
      Accessible media are indicated by the <link to="MediaState_Created"/>
      value of the <link to="#state"/> attribute. When the storage unit cannot
      be read (for example, because it is located on a disconnected network
      resource, or was accidentally deleted outside VirtualBox), the medium is
      considered to be <i>inaccessible</i> which is indicated by the
      <link to="MediaState_Inaccessible"/> state. The details about the reason
      of being inaccessible can be obtained using the
      <link to="#lastAccessError"/> attribute.

      A new accessibility check is performed each time the <link to="#state"/>
      attribute is read. Please note that this check may take long time (several
      seconds or even minutes, depending on the storage unit location and
      format), and will block the calling thread until finished. For this
      reason, it is recommended to never read this attribute on the main UI
      thread to avoid making the UI unresponsive.

      Note that when VirtualBox starts up (e.g. the VirtualBox object gets
      created for the first time), all known media are in the
      <link to="MediaState_Inaccessible"/> state but the value of the <link
      to="#lastAccessError"/> attribute is <tt>null</tt> because no actual
      accessibility check is made on startup. This is done to make the
      VirtualBox object ready for serving requests as
      fast as possible and let the end-user application decide if it needs to
      check media accessibility right away or not.
    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>
        UUID of the medium. For a newly created medium, this value is a randomly
        generated UUID.

        <note>
          For media in one of MediaState_NotCreated, MediaState_Creating or
          MediaState_Deleting states, the value of this property is undefined
          and will most likely be an empty UUID.
        </note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Optional description of the medium. For newly created media, the value
        of this attribute value is <tt>null</tt>.

        Media types that don't support this attribute will return E_NOTIMPL in
        attempt to get or set this attribute's value.

        <note>
          For some storage types, reading this attribute may return an outdated
          (last known) value when <link to="#state"/> is <link
          to="MediaState_Inaccessible"/> or <link
          to="MediaState_LockedWrite"/> because the value of this attribute is
          stored within the storage unit itself. Also note that changing the
          attribute value is not possible in such case, as well as when the
          medium is the <link to="MediaState_LockedRead"/> state.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MediaState" readonly="yes">
      <desc>
        Current media state. Inspect <link to="MediaState"/> values for details.

        Reading this attribute may take long time because a new accessibility
        check of the storage unit is performed every time the attribute is read.
        This check may cause a significant delay if the storage unit of the
        given medium is, for example, a file located on a network share which is
        not currently accessible due to connectivity problems -- the call will
        not return until a timeout interval defined by the host OS for this
        operation expires.

        If the last known state of the medium is <link to="MediaState_Created"/>
        and the accessibility check fails then the state would be set to
        <link to="MediaState_Inaccessible"/> and <link to="#lastAccessError"/>
        may be used to get more details about the failure. If the state of the
        medium is <link to="MediaState_LockedRead"/> or
        <link to="MediaState_LockedWrite"/> then it remains the same, and a
        non-null value of <link to="#lastAccessError"/> will indicate a failed
        accessibility check in this case.

        Note that not all media states are applicable to certain media types.
        For example, states <link to="MediaState_NotCreated"/>,
        <link to="MediaState_LockedWrite"/>, <link to="MediaState_Creating"/>,
        <link to="MediaState_Deleting"/> are meaningless for IDVDImage2 and
        IFloppyImage2 media.
      </desc>
    </attribute>

    <attribute name="location" type="wstring">
      <desc>
        Location of the storage unit holding media data.

        The format of the location string is media type specific. For media
        types that use regular files in a host's file system, the location
        string is just a full file name.

        Some media types may support changing the storage unit location by
        simply changing the value of this property. If this operation is not
        supported, the implementation will return E_NOTIMPL in attempt to set
        this attribute's value.

        When setting a value of the location attribute which is a regular file
        in the host's file system, the given file name may be either relative to
        the <link to="IVirtualBox::homeFolder">VirtualBox home folder</link> or
        absolute. Note that if the given location specification does not contain
        the file extension part then a proper default extension will be
        automatically appended by the implementation depending on the media type.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Name of the storage unit holding media data.

        The returned string is a short version of the <link to="#location"/>
        attribute that is suitable for representing the medium in situations
        where the full location specification is too long (such as lists
        and comboboxes in GUI frontends). This string is also used by frontends
        to sort the media list alphabetically when needed.

        For example, for locations that are regular files in the host's file
        system, the value of this attribute is just a file name (+ extension),
        without the path specification.

        Note that as opposed to the <link to="#location"/> attribute, the name
        attribute will not necessary be unique for a list of media of the
        given type and format.
      </desc>
    </attribute>

    <attribute name="size" type="unsigned long long" readonly="yes">
      <desc>
        Physical size of the storage unit used to hold media data (in bytes).

        <note>
          For media whose <link to="#state"/> is <link
          to="MediaState_Inaccessible"/>, the value of this property is the
          last known size. For <link to="MediaState_NotCreated"/> media,
          the returned value is zero.
        </note>
      </desc>
    </attribute>

    <attribute name="lastAccessError" type="wstring" readonly="yes">
      <desc>
        Text message that represents the result of the last accessibility
        check.

        Accessibility checks are performed each time the <link to="#state"/>
        attribute is read. A @c null string is returned if the last
        accessibility check was successful. A non-null string indicates a
        failure and should normally describe a reason of the failure (for
        example, a file read error).
      </desc>
    </attribute>

    <attribute name="machineIds" type="uuid" safearray="yes" readonly="yes">
      <desc>
        Array of UUIDs of all machines this medium is attached to.

        A <tt>null</tt> array is returned if this medium is not attached to any
        machine or to any machine's snapshot.

        <note>
          The returned array will include a machine even if this medium is not
          attached to that machine in the current state but attached to it in
          one of the machine's snapshots. See <link to="#getSnapshotIds()"/> for
          details.
        </note>
      </desc>
    </attribute>

    <method name="getSnapshotIds">
      <desc>
        Returns an array of UUIDs of all snapshots of the given machine where
        this medium is attached to it.

        If the medium is attached to the machine in the current state, then the
        first element in the array will always be the ID of the queried machine
        (i.e. the value equal to the @c machineId argument), followed by
        snapshot IDs (if any).

        If the medium is not attached to the machine in the current state, then
        the array will contain only snapshot IDs.

        The returned array may be <tt>null</tt> if this medium is not attached
        to the given machine at all, neither in the current state nor in one of
        snapshots.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>
          UUID of the machine to query.
        </desc>
      </param>
      <param name="snapshotIds" type="uuid" safearray="yes" dir="return">
        <desc>
          Array of snapshot UUIDs of the given machine using this medium.
        </desc>
      </param>
    </method>

    <method name="lockRead">
      <desc>
        Locks this medium for reading.

        The read lock is shared: many clients can simultaneously lock the
        same media for reading unless it is already locked for writing (see
        <link to="#lockWrite()"/>) in which case an error is returned.

        When the medium is locked for reading, it cannot be modified
        from within VirtualBox. This means that any method that changes
        the properties of this medium or contents of the storage unit
        will return an error (unless explicitly stated otherwise) and
        that an attempt to start a virtual machine that wants to modify
        the medium will also fail.

        When the virtual machine is started up, it locks for reading all
        media it uses in read-only mode. If some media cannot be locked
        for reading, the startup procedure will fail.

        The medium locked for reading must be unlocked using the <link
        to="#unlockRead()"/> method. Calls to <link to="#lockRead()"/>
        can be nested and must be followed by the same number of paired
        <link to="#unlockRead()"/> calls.

        This method sets the media state to <link
        to="MediaState_LockedRead"/> on success. The state prior to
        this call must be <link to="MediaState_Created"/>, <link
        to="MediaState_Inaccessible"/> or <link
        to="MediaState_LockedRead"/>. As you can see, inaccessible
        media can be locked too. This is not an error; this method
        performs a logical lock that prevents modifications of this
        media through the VirtualBox API, not a physical lock of the
        underlying storage unit.

        This method returns the current state of the medium
        <b>before</b> the operation.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid media state (e.g. not created, locked, inaccessible,
          creating, deleting).
        </result>

      </desc>
      <param name="state" type="MediaState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="unlockRead">
      <desc>
        Cancels the read lock previously set by <link to="#lockRead()"/>.

        Either on success or on failure, this method returns the current state
        of the medium <b>after</b> the operation.

        See <link to="#lockRead()"/> for more details.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium not locked for reading.
        </result>

      </desc>
      <param name="state" type="MediaState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="lockWrite">
      <desc>
        Locks this medium for writing.

        The write lock, as opposed to <link to="#lockRead()"/>, is
        exclusive: there may be only one client that holds a write lock
        and there may be no read locks while the write lock is held.

        When the medium is locked for writing, it cannot be modified
        from within VirtualBox and it is not guaranteed that the values
        of its properties are up-to-date. Any method that changes the
        properties of this medium or contents of the storage unit will
        return an error ((unless explicitly stated otherwise) and an
        attempt to start a virtual machine that wants to modify or to
        read the medium will also fail.

        When the virtual machine is started up, it locks for writing all
        media it uses to write data to. If some media cannot be locked
        for writing, the startup procedure will fail.

        The medium locked for writing must be unlocked using the <link
        to="#unlockWrite()"/> method. Calls to <link to="#lockWrite()"/>
        can <b>not</b> be nested and must be followed by a paired <link
        to="#unlockWrite()"/> call.

        This method sets the media state to <link
        to="MediaState_LockedWrite"/> on success. The state prior to
        this call must be <link to="MediaState_Created"/> or <link
        to="MediaState_Inaccessible"/>. As you can see, inaccessible
        media can be locked too. This is not an error; this method
        performs a logical lock that prevents modifications of this
        media through the VirtualBox API, not a physical lock of the
        underlying storage unit.

        Either on success or on failure, this method returns the current
        state of the medium <b>before</b> the operation.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid media state (e.g. not created, locked, inaccessible,
          creating, deleting).
        </result>

      </desc>
      <param name="state" type="MediaState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="unlockWrite">
      <desc>
        Cancels the write lock previously set by <link to="#lockWrite()"/>.

        Either on success or on failure, this method returns the current
        state of the medium <b>after</b> the operation.

        See <link to="#lockWrite()"/> for more details.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium not locked for writing.
        </result>

      </desc>
      <param name="state" type="MediaState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="close">
      <desc>
        Closes this medium.

        The hard disk must not be attached to any known virtual machine
        and must not have any known child hard disks, otherwise the
        operation will fail.

        When the hard disk is successfully closed, it gets removed from
        the list of remembered hard disks, but its storage unit is not
        deleted. In particular, this means that this hard disk can be
        later opened again using the <link
        to="IVirtualBox::openHardDisk2"/> call.

        Note that after this method successfully returns, the given hard
        disk object becomes uninitialized. This means that any attempt
        to call any of its methods or attributes will fail with the
        <tt>"Object not ready" (E_ACCESSDENIED)</tt> error.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid media state (other than not created, created or
          inaccessible).
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium attached to virtual machine.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
    </method>

  </interface>


  <!--
  // IHardDisk2
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="HardDiskType"
    uuid="a348fafd-a64e-4643-ba65-eb3896bd7e0a"
   >
    <desc>
      Virtual hard disk type.
      <see>IHardDisk</see>
    </desc>

    <const name="Normal"            value="0">
      <desc>
        Normal hard disk (attached directly or indirectly, preserved
        when taking snapshots).
      </desc>
    </const>
    <const name="Immutable"         value="1">
      <desc>
        Immutable hard disk (attached indirectly, changes are wiped out
        after powering off the virtual machine).
      </desc>
    </const>
    <const name="Writethrough"      value="2">
      <desc>
        Write through hard disk (attached directly, ignored when
        taking snapshots).
      </desc>
    </const>
  </enum>

  <interface
    name="IHardDisk2Attachment" extends="$unknown"
    uuid="fa2f4619-2c14-4090-869e-73b45419b7b5"
    wsmap="struct"
  >
    <desc>
      The IHardDisk2Attachment interface represents a hard disk attachment of a
      virtual machine.

      Every hard disk attachment specifies a slot of the virtual hard disk
      controller and a virtual hard disk attached to this slot.

      The array of hard disk attachments is returned by
      <link to="IMachine::hardDisk2Attachments"/>.

      <note>
        With the COM API, this is an interface like all the others. With the
        webservice, this is mapped to a structure, so querying the attribute
        will not return an object, but a complete structure.
      </note>
    </desc>
    <attribute name="hardDisk" type="IHardDisk2" readonly="yes">
      <desc>Hard disk object associated with this attachment.</desc>
    </attribute>

    <attribute name="bus" type="StorageBus" readonly="yes">
      <desc>Interface bus of this attachment.</desc>
    </attribute>

    <attribute name="channel" type="long" readonly="yes">
      <desc>Channel number of this attachment.</desc>
    </attribute>

    <attribute name="device" type="long" readonly="yes">
      <desc>Device slot number of this attachment.</desc>
    </attribute>

  </interface>

  <interface
    name="IHardDisk2" extends="IMedium"
    uuid="ed6e2525-c2fd-42a4-917a-7a9045ac9e15"
    wsmap="managed"
  >
    <desc>
      The IHardDisk2 interface represents a virtual hard disk drive
      used by a virtual machine.

      Virtual hard disk objects virtualize the hard disk hardware and look like
      regular hard disks for the guest OS running inside the virtual machine.

      <h3>Hard Disk Types</h3>

      There are three types of hard disks:
      <link to="HardDiskType_Normal">Normal</link>,
      <link to="HardDiskType_Immutable">Immutable</link> and
      <link to="HardDiskType_Writethrough">Writethrough</link>. The type of the
      hard disk defines how the hard disk is attached to a virtual machine and
      what happens when a <link to="ISnapshot">snapshot</link> of the virtual
      machine with the attached hard disk is taken. The type of the hard disk is
      defined by the <link to="#type"/> attribute.

      All hard disks can be also divided in two big groups: <i>base</i> hard
      disks and <i>differencing</i> hard disks. A base hard disk contains all
      sectors of the hard disk data in its storage unit and therefore can be
      used independently. On the contrary, a differencing hard disk contains
      only some part of the hard disk data (a subset of sectors) and needs
      another hard disk to get access to the missing sectors of data. This
      another hard disk is called a <i>parent</i> hard disk and defines a hard
      disk to which this differencing hard disk is known to be <i>linked to</i>.
      The parent hard disk may be itself a differencing hard disk. This
      way, differencing hard disks form a linked hard disk chain. This chain
      always ends with the base hard disk which is sometimes referred to as the
      root hard disk of this chain. Note that several differencing hard disks
      may be linked to the same parent hard disk. This way, all known hard disks
      form a hard disk tree which is based on their parent-child relationship.

      Differencing hard disks can be distinguished from base hard disks by
      querying the <link to="#parent"/> attribute: base hard disks do not have
      parents they would depend on, so the value of this attribute is always
      <tt>null</tt> for them. Using this attribute, it is possible to walk up
      the hard disk tree (from the child hard disk to its parent). It is also
      possible to walk down the tree using the <link to="#children"/>
      attribute.

      Note that the type of all differencing hard disks is
      <link to="HardDiskType_Normal">Normal</link>; all other values are
      meaningless for them. Base hard disks may be of any type.

      <h3>Creating Hard Disks</h3>

      New base hard disks are created using
      <link to="IVirtualBox::createHardDisk2()"/>. Existing hard disks are
      opened using <link to="IVirtualBox::openHardDisk2()"/>. Differencing hard
      disks are usually implicitly created by VirtualBox when needed but may
      also be created explicitly using <link to="#createDiffStorage()"/>.

      After the hard disk is successfully created (including the storage unit)
      or opened, it becomes a known hard disk (remembered in the internal media
      registry). Known hard disks can be attached to a virtual machine, accessed
      through <link to="IVirtualBox::getHardDisk2()"/> and
      <link to="IVirtualBox::findHardDisk2()"/> methods or enumerated using the
      <link to="IVirtualBox::hardDisks2"/> array (only for base hard disks).

      The following methods, besides <link to="IMedium::close()"/>,
      automatically remove the hard disk from the media registry:
      <ul>
        <li><link to="#deleteStorage()"/></li>
        <li><link to="#mergeTo()"/></li>
      </ul>

      If the storage unit of the hard disk is a regular file in the host's
      file system then the rules stated in the description of the
      <link to="IMedium::location"/> attribute apply when setting its value. In
      addition, a plain file name without any path may be given, in which case
      the <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
      folder</link> will be prepended to it.

      <h4>Automatic composition of the file name part</h4>

      Another extension to the <link to="IMedium::location"/> attribute is that
      there is a possibility to cause VirtualBox to compose a unique value for
      the file name part of the location using the UUID of the hard disk. This
      applies only to hard disks in <link to="MediaState_NotCreated"/> state,
      e.g. before the storage unit is created, and works as follows. You set the
      value of the <link to="IMedium::location"/> attribute to a location
      specification which only contains the path specification but not the file
      name part and ends with either a forward slash or a backslash character.
      In response, VirtualBox will generate a new UUID for the hard disk and
      compose the file name using the following pattern:
      <pre>
        &lt;path&gt;/{&lt;uuid&gt;}.&lt;ext&gt;
      </pre>
      where <tt>&lt;path&gt;</tt> is the supplied path specification,
      <tt>&lt;uuid&gt;</tt> is the newly generated UUID and <tt>&lt;ext&gt;</tt>
      is the default extension for the storage format of this hard disk. After
      that, you may call any of the methods that create a new hard disk storage
      unit and they will use the generated UUID and file name.

      <h3>Attaching Hard Disks</h3>

      Hard disks are attached to virtual machines using the
      <link to="IMachine::attachHardDisk2()"/> method and detached using the
      <link to="IMachine::detachHardDisk2()"/> method. Depending on their
      <link to="#type"/>, hard disks are attached either
      <i>directly</i> or <i>indirectly</i>.

      When a hard disk is being attached directly, it is associated with the
      virtual machine and used for hard disk operations when the machine is
      running. When a hard disk is being attached indirectly, a new differencing
      hard disk linked to it is implicitly created and this differencing hard
      disk is associated with the machine and used for hard disk operations.
      This also means that if <link to="IMachine::attachHardDisk2()"/> performs
      a direct attachment then the same hard disk will be returned in response
      to the subsequent  <link to="IMachine::getHardDisk2()"/> call; however if
      an indirect attachment is performed then
      <link to="IMachine::getHardDisk2()"/> will return the implicitly created
      differencing hard disk, not the original one passed to <link
      to="IMachine::attachHardDisk2()"/>. The following table shows the
      dependency of the attachment type on the hard disk type:

      <table>
        <tr>
          <th>Hard Disk Type</th>
          <th>Direct or Indirect?</th>
        </tr>
        <tr>
          <td>Normal (Base)</td>
          <td>
            Normal base hard disks that do not have children (i.e. differencing
            hard disks linked to them) and that are not already attached to
            virtual machines in snapshots are attached <b>directly</b>.
            Otherwise, they are attached <b>indirectly</b> because having
            dependent children or being part of the snapshot makes it impossible
            to modify hard disk contents without breaking the integrity of the
            dependent party. The <link to="#readOnly"/> attribute allows to
            quickly determine the kind of the attachment for the given hard
            disk. Note that if a normal base hard disk is to be indirectly
            attached to a virtual machine with snapshots then a special
            procedure called <i>smart attachment</i> is performed (see below).
          </td>
        </tr>
        <tr>
          <td>Normal (Differencing)</td>
          <td>
            Differencing hard disks are like normal base hard disks: attached
            <b>directly</b> if they do not have children and are not attached to
            virtual machines in snapshots, and <b>indirectly</b> otherwise. Note
            that the smart attachment procedure is never performed for
            differencing hard disks.
          </td>
        </tr>
        <tr>
          <td>Immutable</td>
          <td>
            Immutable hard disks are always attached <b>indirectly</b> because
            they are designed to be non-writable. If an immutable hard disk is
            attached to a virtual machine with snapshots then a special
            procedure called smart attachment is performed (see below).
          </td>
        </tr>
        <tr>
          <td>Writethrough</td>
          <td>
            Writethrough hard disks are always attached <b>directly</b>, also as
            designed. This also means that writethrough hard disks cannot have
            other hard disks linked to them at all.
          </td>
        </tr>
      </table>

      Note that the same hard disk, regardless of its type, may be attached to
      more than one virtual machine at a time. In this case, the machine that is
      started first gains exclusive access to the hard disk and attempts to
      start other machines having this hard disk attached will fail until the
      first machine is powered down.

      Detaching hard disks is performed in a <i>deferred</i> fashion. This means
      that the given hard disk remains associated with the given machine after a
      successful <link to="IMachine::detachHardDisk2()"/> call until
      <link to="IMachine::saveSettings()"/> is called to save all changes to
      machine settings to disk. This deferring is necessary to guarantee that
      the hard disk configuration may be restored at any time by a call to
      <link to="IMachine::discardSettings()"/>  before the settings
      are saved (committed).

      Note that if <link to="IMachine::discardSettings()"/> is called after
      indirectly attaching some hard disks to the machine but before a call to
      <link to="IMachine::saveSettings()"/> is made, it will implicitly delete
      all differencing hard disks implicitly created by
      <link to="IMachine::attachHardDisk2()"/> for these indirect attachments.
      Such implicitly created hard disks will also be immediately deleted when
      detached explicitly using the <link to="IMachine::detachHardDisk2()"/>
      call if it is made before <link to="IMachine::saveSettings()"/>. This
      implicit deletion is safe because newly created differencing hard
      disks do not contain any user data.

      However, keep in mind that detaching differencing hard disks that were
      implicitly created by <link to="IMachine::attachHardDisk2()"/>
      before the last <link to="IMachine::saveSettings()"/> call will
      <b>not</b> implicitly delete them as they may already contain some data
      (for example, as a result of virtual machine execution). If these hard
      disks are no more necessary, the caller can always delete them explicitly
      using <link to="#deleteStorage()"/> after they are actually de-associated
      from this machine by the <link to="IMachine::saveSettings()"/> call.

      <h3>Smart Attachment</h3>

      When normal base or immutable hard disks are indirectly attached to a
      virtual machine then some additional steps are performed to make sure the
      virtual machine will have the most recent "view" of the hard disk being
      attached. These steps include walking through the machine's snapshots
      starting from the current one and going through ancestors up to the first
      snapshot. Hard disks attached to the virtual machine in all
      of the encountered snapshots are checked whether they are descendants of
      the given normal base or immutable hard disk. The first found child (which
      is the differencing hard disk) will be used instead of the normal base or
      immutable hard disk as a parent for creating a new differencing hard disk
      that will be actually attached to the machine. And only if no descendants
      are found or if the virtual machine does not have any snapshots then the
      normal base or immutable hard disk will be used itself as a parent for
      this differencing hard disk.

      It is easier to explain what smart attachment does using the
      following example:
      <pre>
BEFORE attaching B.vdi:       AFTER attaching B.vdi:

Snapshot 1 (B.vdi)            Snapshot 1 (B.vdi)
 Snapshot 2 (D1->B.vdi)        Snapshot 2 (D1->B.vdi)
  Snapshot 3 (D2->D1.vdi)       Snapshot 3 (D2->D1.vdi)
   Snapshot 4 (none)             Snapshot 4 (none)
    CurState   (none)             CurState   (D3->D2.vdi)

                              NOT
                                 ...
                                  CurState   (D3->B.vdi)
      </pre>
      The first column is the virtual machine configuration before the base hard
      disk <tt>B.vdi</tt> is attached, the second column shows the machine after
      this hard disk is attached. Constructs like <tt>D1->B.vdi</tt> and similar
      mean that the hard disk that is actually attached to the machine is a
      differencing hard disk, <tt>D1.vdi</tt>, which is linked to (based on)
      another hard disk, <tt>B.vdi</tt>.

      As we can see from the example, the hard disk <tt>B.vdi</tt> was detached
      from the machine before taking Snapshot 4. Later, after Snapshot 4 was
      taken, the user decides to attach <tt>B.vdi</tt> again. <tt>B.vdi</tt> has
      dependent child hard disks (<tt>D1.vdi</tt>, <tt>D2.vdi</tt>), therefore
      it cannot be attached directly and needs an indirect attachment (i.e.
      implicit creation of a new differencing hard disk). Due to the smart
      attachment procedure, the new differencing hard disk
      (<tt>D3.vdi</tt>) will be based on <tt>D2.vdi</tt>, not on
      <tt>B.vdi</tt> itself, since <tt>D2.vdi</tt> is the most recent view of
      <tt>B.vdi</tt> existing for this snapshot branch of the given virtual
      machine.

      Note that if there is more than one descendant hard disk of the given base
      hard disk found in a snapshot, and there is an exact device, channel and
      bus match, then this exact match will be used. Otherwise, the youngest
      descendant will be picked up.

      There is one more important aspect of the smart attachment procedure which
      is not related to snapshots at all. Before walking through the snapshots
      as described above, the backup copy of the current list of hard disk
      attachment is searched for descendants. This backup copy is created when
      the hard disk configuration is changed for the first time after the last
      <link to="IMachine::saveSettings()"/> call and used by
      <link to="IMachine::discardSettings()"/> to undo the recent hard disk
      changes. When such a descendant is found in this backup copy, it will be
      simply re-attached back, without creating a new differencing hard disk for
      it. This optimization is necessary to make it possible to re-attach the
      base or immutable hard disk to a different bus, channel or device slot
      without losing the contents of the differencing hard disk actually
      attached to the machine in place of it.
    </desc>

    <attribute name="format" type="wstring" readonly="yes">
      <desc>
        Storage format of this hard disk.

        The value of this attribute is a string that specifies a backend used to
        store hard disk data. The storage format is defined when you create a
        new hard disk or automatically detected when you open an existing hard
        disk medium, and cannot be changed later.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        <link to="ISystemProperties::hardDiskFormats"/>.
      </desc>
    </attribute>

    <attribute name="type" type="HardDiskType">
      <desc>
        Type (role) of this hard disk.

        The following constraints apply when changing the value of this
        attribute:
        <ul>
          <li>If a hard disk is attached to a virtual machine (either in the
              current state or in one of the snapshots), its type cannot be
              changed.
          </li>
          <li>As long as the hard disk has children, its type cannot be set
              to <link to="HardDiskType_Writethrough"/>.
          </li>
          <li>The type of all differencing hard disks is
              <link to="HardDiskType_Normal"/> and cannot be changed.
          </li>
        </ul>

        The type of a newly created or opened hard disk is set to
        <link to="HardDiskType_Normal"/>.
      </desc>
    </attribute>

    <attribute name="parent" type="IHardDisk2" readonly="yes">
      <desc>
        Parent of this hard disk (a hard disk this hard disk is directly based
        on).

        Only differencing hard disks have parents. For base (non-differencing)
        hard disks, <tt>null</tt> is returned.
      </desc>
    </attribute>

    <attribute name="children" type="IHardDisk2" safearray="yes" readonly="yes">
      <desc>
        Children of this hard disk (all differencing hard disks directly based
        on this hard disk). A <tt>null</tt> array is returned if this hard disk
        does not have any children.
      </desc>
    </attribute>

    <attribute name="root" type="IHardDisk2" readonly="yes">
      <desc>
        Root hard disk of this hard disk.

        If this is a differencing hard disk, its root hard disk is the base hard
        disk the given hard disk branch starts from. For all other types of hard
        disks, this property returns the hard disk object itself (i.e. the same
        object this property is read on).
      </desc>
    </attribute>

    <attribute name="readOnly" type="boolean" readonly="yes">
      <desc>
        Returns <tt>true</tt> if this hard disk is read-only and <tt>false</tt>
        otherwise.

        A hard disk is considered to be read-only when its contents cannot be
        modified without breaking the integrity of other parties that depend on
        this hard disk such as its child hard disks or snapshots of virtual
        machines where this hard disk is attached to these machines. If there
        are no children and no such snapshots then there is no dependency and
        the hard disk is not read-only.

        The value of this attribute can be used to determine the kind of the
        attachment that will take place when attaching this hard disk to a
        virtual machine. If the value is <tt>false</tt> then the hard disk will
        be attached directly. If the value is <tt>true</tt> then the hard disk
        will be attached indirectly by creating a new differencing child hard
        disk for that. See the interface description for more information.

        Note that all <link to="HardDiskType_Immutable">Immutable</link> hard
        disks are always read-only while all
        <link to="HardDiskType_Writethrough">Writethrough</link> hard disks are
        always not.

        <note>
          The read-only condition represented by this attribute is related to
          the hard disk type and usage, not to the current
          <link to="IMedium::state">media state</link> and not to the read-only
          state of the storage unit.
        </note>
      </desc>
    </attribute>

    <attribute name="logicalSize" type="unsigned long long" readonly="yes">
      <desc>
        Logical size of this hard disk (in megabytes), as reported to the
        guest OS running inside the virtual machine this disk is
        attached to. The logical size is defined when the hard disk is created
        and cannot be changed later.

        <note>
          Reading this property on a differencing hard disk will return the size
          of its <link to="#root"/> hard disk.
        </note>
        <note>
          For hard disks whose state is <link to="#state"/> is <link
          to="MediaState_Inaccessible"/>, the value of this property is the
          last known logical size. For <link to="MediaState_NotCreated"/> hard
          disks, the returned value is zero.
        </note>
      </desc>
    </attribute>

    <!-- storage methods -->

    <method name="getProperty">
      <desc>
        Returns the value of the custom hard disk property with the given name.

        The list of all properties supported by the given hard disk format can
        be obtained with <link to="IHardDiskFormat::describeProperties()"/>.

        Note that if this method returns a <tt>null</tt> @a value, the requested
        property is supported but currently not assigned any value.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Requested property does not exist (not supported by the format).
        </result>
        <result name="E_INVALIDARG">@a name is NULL or empty.</result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the property to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Current property value.</desc>
      </param>
    </method>

    <method name="setProperty">
      <desc>
        Sets the value of the custom hard disk property with the given name.

        The list of all properties supported by the given hard disk format can
        be obtained with <link to="IHardDiskFormat::describeProperties()"/>.

        Note that setting the property value to <tt>null</tt> is equivalent to
        deleting the existing value. A default value (if it is defined for this
        property) will be used by the format backend in this case.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Requested property does not exist (not supported by the format).
        </result>
        <result name="E_INVALIDARG">@a name is NULL or empty.</result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the property to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Property value to set.</desc>
      </param>
    </method>

    <method name="getProperties">
      <desc>
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        <tt>null</tt> if all properties are to be returned. Note that currently
        the value of this argument is ignored and the method always returns all
        existing properties.

        The list of all properties supported by the given hard disk format can
        be obtained with <link to="IHardDiskFormat::describeProperties()"/>.

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each elemend at the
        given index in the first array corresponds to an element at the same
        index in the second array.

        Note that for properties that do not have assigned values,
        <tt>null</tt> is returned at the appropriate index in the @a
        returnValues array.

      </desc>
      <param name="names" type="wstring" dir="in">
        <desc>
          Names of properties to get.
        </desc>
      </param>
      <param name="returnNames" type="wstring" safearray="yes" dir="out">
        <desc>Names of returned properties.</desc>
      </param>
      <param name="returnValues" type="wstring" safearray="yes" dir="return">
        <desc>Values of returned properties.</desc>
      </param>
    </method>

    <method name="setProperties">
      <desc>
        Sets values for a group of properties in one call.

        The names of the properties to set are passed in the @a names
        array along with the new values for them in the @a values array. Both
        arrays have the same number of elements with each elemend at the given
        index in the first array corresponding to an element at the same index
        in the second array.

        If there is at least one property name in @a names that is not valid,
        the method will fail before changing the values of any other properties
        from the @a names array.

        Using this method over <link to="#setProperty()"/> is preferred if you
        need to set several properties at once since it will result into less
        IPC calls.

        The list of all properties supported by the given hard disk format can
        be obtained with <link to="IHardDiskFormat::describeProperties()"/>.

        Note that setting the property value to <tt>null</tt> is equivalent to
        deleting the existing value. A default value (if it is defined for this
        property) will be used by the format backend in this case.
      </desc>
      <param name="names" type="wstring" safearray="yes" dir="in">
        <desc>Names of properties to set.</desc>
      </param>
      <param name="values" type="wstring" safearray="yes" dir="in">
        <desc>Values of properties to set.</desc>
      </param>
    </method>

    <!-- storage methods -->

    <method name="createDynamicStorage">
      <desc>
        Starts creating a dynamically expanding hard disk storage unit in the
        background. The previous storage unit created for this object, if
        any, must first be deleted using <link to="#deleteStorage"/>, otherwise
        the operation will fail.

        Before the operation starts, the hard disk is placed in
        <link to="MediaState_Creating"/> state. If the create operation
        fails, the media will be placed back in <link to="MediaState_NotCreated"/>
        state.

        After the returned progress object reports that the operation has
        successfully completed, the media state will be set to <link
        to="MediaState_Created"/>, the hard disk will be remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <result name="VBOX_E_NOT_SUPPORTED">
          Dynamic storage creation operation is not supported. See <link
          to="IHardDiskFormat::capabilities"/>.
        </result>
      </desc>
      <param name="logicalSize" type="unsigned long long" dir="in">
        <desc>Maximum logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="createFixedStorage">
      <desc>
        Starts creating a fixed-size hard disk storage unit in the background.
        The previous storage unit created for this object, if
        any, must be first deleted using <link to="#deleteStorage"/>, otherwise
        the operation will fail.

        Before the operation starts, the hard disk is placed to
        <link to="MediaState_Creating"/> state. If the create operation
        fails, the media will placed back to <link to="MediaState_NotCreated"/>
        state.

        After the returned progress object reports that the operation is
        successfully complete, the media state will be set to <link
        to="MediaState_Created"/>, the hard disk will be remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <result name="VBOX_E_NOT_SUPPORTED">
          Fixed storage creation operation is not supported. See
          <link to="IHardDiskFormat::capabilities"/>.
        </result>
      </desc>
      <param name="logicalSize" type="unsigned long long" dir="in">
        <desc>Logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteStorage">
      <desc>
        Starts deleting the storage unit of this hard disk.

        The hard disk must not be attached to any known virtual machine and must
        not have any known child hard disks, otherwise the operation will fail.
        It will also fail if there is no storage unit to delete or if deletion
        is already in progress, or if the hard disk is being in use (locked for
        read or for write) or inaccessible. Therefore, the only valid state for
        this operation to succeed is <link to="MediaState_Created"/>.

        Before the operation starts, the hard disk is placed to
        <link to="MediaState_Deleting"/> state and gets removed from the list
        of remembered hard disks (media registry). If the delete operation
        fails, the media will be remembered again and placed back to
        <link to="MediaState_Created"/> state.

        After the returned progress object reports that the operation is
        complete, the media state will be set to
        <link to="MediaState_NotCreated"/> and you will be able to use one of
        the storage creation methods to create it again.

        <see>#close()</see>

        <result name="VBOX_E_OBJECT_IN_USE">
          Hard disk is attached to a virtual machine.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Storage deletion is not allowed because neither of storage creation
          operations are supported. See
          <link to="IHardDiskFormat::capabilities"/>.
        </result>

        <note>
          If the deletion operation fails, it is not guaranteed that the storage
          unit still exists. You may check the <link to="IMedium::state"/> value
          to answer this question.
        </note>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- diff methods -->

    <method name="createDiffStorage">
      <desc>
        Starts creating an empty differencing storage unit based on this hard
        disk in the format and at the location defined by the @a target
        argument.

        The target hard disk must be in <link to="MediaState_NotCreated"/>
        state (i.e. must not have an existing storage unit). Upon successful
        completion, this operation will set the type of the target hard disk to
        <link to="HardDiskType_Normal"/> and create a storage unit necessary to
        represent the differencing hard disk data in the given format (according
        to the storage format of the target object).

        After the returned progress object reports that the operation is
        successfully complete, the target hard disk gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          The hard disk will be set to <link to="MediaState_LockedRead"/>
          state for the duration of this operation.
        </note>
        <result name="VBOX_E_OBJECT_IN_USE">
          Hard disk not in NotCreated state.
        </result>
      </desc>
      <param name="target" type="IHardDisk2" dir="in">
        <desc>Target hard disk.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="mergeTo">
      <desc>
        Starts merging the contents of this hard disk and all intermediate
        differencing hard disks in the chain to the given target hard disk.

        The target hard disk must be either a descendant of this hard disk or
        its ancestor (otherwise this method will immediately return a failure).
        It follows that there are two logical directions of the merge operation:
        from ancestor to descendant (<i>forward merge</i>) and from descendant to
        ancestor (<i>backward merge</i>). Let us consider the following hard disk
        chain:

        <pre>Base &lt;- Diff_1 &lt;- Diff_2</pre>

        Here, calling this method on the <tt>Base</tt> hard disk object with
        <tt>Diff_2</tt> as an argument will be a forward merge; calling it on
        <tt>Diff_2</tt> with <tt>Base</tt> as an argument will be a backward
        merge. Note that in both cases the contents of the resulting hard disk
        will be the same, the only difference is the hard disk object that takes
        the result of the merge operation. In case of the forward merge in the
        above example, the result will be written to <tt>Diff_2</tt>; in case of
        the backward merge, the result will be written to <tt>Base</tt>. In
        other words, the result of the operation is always stored in the target
        hard disk.

        Upon successful operation completion, the storage units of all hard
        disks in the chain between this (source) hard disk and the target hard
        disk, including the source hard disk itself, will be automatically
        deleted and the relevant hard disk objects (including this hard disk)
        will become uninitialized. This means that any attempt to call any of
        their methods or attributes will fail with the
        <tt>"Object not ready" (E_ACCESSDENIED)</tt> error. Applied to the above
        example, the forward merge of <tt>Base</tt> to <tt>Diff_2</tt> will
        delete and uninitialize both <tt>Base</tt> and <tt>Diff_1</tt> hard
        disks. Note that <tt>Diff_2</tt> in this case will become a base hard
        disk itself since it will no longer be based on any other hard disk.

        Considering the above, all of the following conditions must be met in
        order for the merge operation to succeed:
        <ul>
          <li>
            Neither this (source) hard disk nor any intermediate
            differencing hard disk in the chain between it and the target
            hard disk is attached to any virtual machine.
          </li>
          <li>
            Neither the source hard disk nor the target hard disk is an
            <link to="HardDiskType_Immutable"/> hard disk.
          </li>
          <li>
            The part of the hard disk tree from the source hard disk to the
            target hard disk is a linear chain, i.e. all hard disks in this
            chain have exactly one child which is the next hard disk in this
            chain. The only exception from this rule is the target hard disk in
            the forward merge operation; it is allowed to have any number of
            child hard disks because the merge operation will hot change its
            logical contents (as it is seen by the guest OS or by children).
          </li>
          <li>
            None of the involved hard disks are in
            <link to="MediaState_LockedRead"/> or
            <link to="MediaState_LockedWrite"/> state.
          </li>
        </ul>

        <note>
          This (source) hard disk and all intermediates will be placed to <link
          to="MediaState_Deleting"/> state and the target hard disk will be
          placed to <link to="MediaState_LockedWrite"/> state and for the
          duration of this operation.
        </note>
      </desc>
      <param name="targetId" type="uuid" dir="in">
        <desc>UUID of the target ancestor or descendant hard disk.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- clone methods -->

    <method name="cloneTo">
      <desc>
        Starts creating a clone of this hard disk in the format and at the
        location defined by the @a target argument.

        The target hard disk must be in <link to="MediaState_NotCreated"/>
        state (i.e. must not have an existing storage unit). Upon successful
        completion, the cloned hard disk will contain exactly the same sector
        data as the hard disk being cloned, except that a new UUID for the clone
        will be randomly generated.

        After the returned progress object reports that the operation is
        successfully complete, the target hard disk gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          If the cloned hard disk is a differencing hard disk, it will inherit
          parent dependency of the original hard disk.
        </note>
        <note>
          This hard disk will be placed to <link to="MediaState_LockedRead"/>
          state for the duration of this operation.
        </note>
      </desc>
      <param name="target" type="IHardDisk2" dir="in">
        <desc>Target hard disk.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="flattenTo">
      <desc>
        Starts creating a deep (independent) clone of this hard disk in the
        format and at the location defined by the @a target argument.

        This operation is similar to <link to="#cloneTo()"/> except that when
        applied to a differencing hard disk, it will also copy missing hard disk
        data from all parent hard disks it is linked to. This will make the
        created clone an independent base hard disk that contains all hard disk
        data and does not need any other hard disks to operate.

        After the returned progress object reports that the operation is
        successfully complete, the target hard disk gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          For base hard disks, this operation is identical to
          <link to="#cloneTo()"/>.
        </note>
        <note>
          This hard disk and all its parent hard disks will be placed to <link
          to="MediaState_LockedRead"/> state for the duration of this
          operation.
        </note>
      </desc>
      <param name="target" type="IHardDisk2" dir="in">
        <desc>Target hard disk.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="compact">
      <desc>
        Starts compacting of this hard disk. This means that the disk is
        transformed into a possibly more compact storage representation.
        This potentially creates temporary images, which can require a
        substantial amount of additional disk space.

        After the returned progress object reports that the operation is
        successfully complete, the media state will be set back to the
        current state.

        <note>
          This hard disk and all its parent hard disks will be placed to <link
          to="MediaState_LockedRead"/> state for the duration of this
          operation.
        </note>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IHardDiskFormat
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="DataType"
    uuid="d90ea51e-a3f1-4a01-beb1-c1723c0d3ba7"
  >
    <const name="Int32" value="0"/>
    <const name="Int8" value="1"/>
    <const name="String" value="2"/>
  </enum>

  <enum
    name="DataFlags"
    uuid="86884dcf-1d6b-4f1b-b4bf-f5aa44959d60"
  >
    <const name="None" value="0x00"/>
    <const name="Mandatory" value="0x01"/>
    <const name="Expert" value="0x02"/>
    <const name="Array" value="0x04"/>
    <const name="FlagMask" value="0x07"/>
  </enum>

  <enum
    name="HardDiskFormatCapabilities"
    uuid="1df1e4aa-d25a-4ba6-b2a2-02f60eb5903b"
  >
    <desc>
       Hard disk format capability flags.
    </desc>

    <const name="Uuid" value="0x01">
      <desc>
        Supports UUIDs as expected by VirtualBox code.
      </desc>
    </const>

    <const name="CreateFixed" value="0x02">
      <desc>
        Supports creating fixed size images, allocating all space instantly.
      </desc>
    </const>

    <const name="CreateDynamic" value="0x04">
      <desc>
        Supports creating dynamically growing images, allocating space on
        demand.
      </desc>
    </const>

    <const name="CreateSplit2G" value="0x08">
      <desc>
        Supports creating images split in chunks of a bit less than 2 GBytes.
      </desc>
    </const>

    <const name="Differencing" value="0x10">
      <desc>
        Supports being used as a format for differencing hard disks (see <link
        to="IHardDisk2::createDiffStorage"/>).
      </desc>
    </const>

    <const name="Asynchronous" value="0x20">
      <desc>
        Supports asynchronous I/O operations for at least some configurations.
      </desc>
    </const>

    <const name="File" value="0x40">
      <desc>
        The format backend operates on files (the <link to="IMedium::location"/>
        attribute of the hard disk specifies a file used to store hard disk
        data; for a list of supported file extensions see
        <link to="IHardDiskFormat::fileExtensions"/>).
      </desc>
    </const>

    <const name="Properties" value="0x80">
      <desc>
        The format backend uses the property interface to configure the storage
        location and properties (the <link to="IHardDiskFormat::describeProperties"/>
        method is used to get access to properties supported by the given hard
        disk format).
      </desc>
    </const>

    <const name="CapabilityMask" value="0xFF"/>
  </enum>

  <interface
     name="IHardDiskFormat" extends="$unknown"
     uuid="7f3ba790-3a0b-4a8a-bac2-bb50150123c5"
     wsmap="managed"
     >
    <desc>
        The IHardDiskFormat interface represents a virtual hard disk format.

        Each hard disk format has an associated backend which is used to handle
        hard disks stored in this format. This interface provides information
        about the properties of the associated backend.

        Each hard disk format is identified by a string represented by the
        <link to="#id"/> attribute. This string is used in calls like
        <link to="IVirtualBox::createHardDisk2()"/> to specify the desired
        format.

        The list of all supported hard disk formats can be obtained using
        <link to="ISystemProperties::hardDiskFormats"/>.

        <see>IHardDisk2</see>
    </desc>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>
        Identifier of this format.

        This string is used in methods of other interfaces where it is necessary
        to specify a hard disk format, such as
        <link to="IVirtualBox::createHardDisk2()"/>.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Human readable description of this format.

        Mainly for use in file open dialogs.
      </desc>
    </attribute>

    <attribute name="fileExtensions" type="wstring" safearray="yes" readonly="yes">
      <desc>
        Array of strings containing the supported file extensions.

        The first extension in the array is the extension preferred by the
        backend. It is recommended to use this extension when specifying a
        location of the storage unit for a new hard disk.

        Note that some backends do not work on files, so this array may be
        empty.

        <see>IHardDiskFormat::capabilities</see>
      </desc>
    </attribute>

    <attribute name="capabilities" type="unsigned long" readonly="yes">
      <desc>
        Capabilities of the format as a set of bit flags.

        For the meaning of individual capability flags see
        <link to="HardDiskFormatCapabilities"/>.
      </desc>
    </attribute>

    <method name="describeProperties">
      <desc>
        Returns several arrays describing the properties supported by this
        format.

        An element with the given index in each array describes one
        property. Thus, the number of elements in each returned array is the
        same and corresponds to the number of supported properties.

        The returned arrays are filled in only if the
        <link to="HardDiskFormatCapabilities_Properties"/> flag is set.
        All arguments must be non-NULL.

        <see>DataType</see>
        <see>DataFlags</see>
      </desc>

      <param name="names" type="wstring" safearray="yes" dir="out">
        <desc>Array of property names.</desc>
      </param>
      <param name="description" type="wstring" safearray="yes" dir="out">
        <desc>Array of property descriptions.</desc>
      </param>
      <param name="types" type="DataType" safearray="yes" dir="out">
        <desc>Array of property types.</desc>
      </param>
      <param name="flags" type="unsigned long" safearray="yes" dir="out">
        <desc>Array of property flags.</desc>
      </param>
      <param name="defaults" type="wstring" safearray="yes" dir="out">
        <desc>Array of default property values.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IFloppyImage2
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IFloppyImage2" extends="IMedium"
    uuid="fcdee8f0-03f9-11dd-95ff-0800200c9a66"
    wsmap="managed"
  >
    <desc>
      The IFloppyImage2 interface represents a medium containing the image
      of a floppy disk.
    </desc>

  </interface>


  <!--
  // IDVDImage2
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IDVDImage2" extends="IMedium"
    uuid="1c5165f1-9543-478d-a117-84a1d2317068"
    wsmap="managed"
  >
    <desc>
      The IDVDImage2 interface represents a medium containing the image
      of a CD or DVD disk in the ISO format.
    </desc>

  </interface>


  <!--
  // IDVDDrive
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IDVDDrive" extends="$unknown"
    uuid="d650ef30-be9b-4dae-b463-11d5824681a5"
    wsmap="managed"
  >
    <desc>
      The IDVDDrive interface represents the virtual CD/DVD drive of the
      virtual machine. An object of this type is returned by
      <link to="IMachine::DVDDrive"/>.
    </desc>

    <attribute name="state" type="DriveState" readonly="yes">
      <desc>Current drive state.</desc>
    </attribute>

    <attribute name="passthrough" type="boolean">
      <desc>
        When a host drive is mounted and passthrough is enabled
        the guest OS will be able to directly send SCSI commands to
        the host drive. This enables the guest OS to use CD/DVD writers
        but is potentially dangerous.
      </desc>
    </attribute>

    <method name="mountImage">
      <desc>Mounts a CD/DVD image with the specified UUID.

        <result name="VBOX_E_FILE_ERROR">
          Invalid image file location.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Could not find a CD/DVD image matching @a imageID.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid media state.
        </result>

      </desc>
      <param name="imageId" type="uuid" dir="in"/>
    </method>

    <method name="captureHostDrive">
      <desc>Captures the specified host CD/DVD drive.</desc>
      <param name="drive" type="IHostDVDDrive" dir="in"/>
    </method>

    <method name="unmount">
      <desc>Unmounts the currently mounted image or host drive.</desc>
    </method>

    <method name="getImage">
      <desc>Returns the currently mounted CD/DVD image.</desc>
      <param name="image" type="IDVDImage2" dir="return"/>
    </method>

    <method name="getHostDrive">
      <desc>Returns the currently mounted host CD/DVD drive.</desc>
      <param name="drive" type="IHostDVDDrive" dir="return"/>
    </method>

  </interface>


  <!--
  // IFloppyDrive
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IFloppyDrive" extends="$unknown"
     uuid="159412cd-bab8-452e-8097-218a020825a6"
     wsmap="managed"
  >
    <desc>
      The IFloppyDrive interface represents the virtual floppy drive of the
      virtual machine. An object of this type is returned by
      <link to="IMachine::floppyDrive" />.
    </desc>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the floppy drive is enabled. If it is disabled,
        the floppy drive will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="state" type="DriveState" readonly="yes">
      <desc>Current drive state.</desc>
    </attribute>

    <method name="mountImage">
      <desc>Mounts a floppy image with the specified UUID.

        <result name="VBOX_E_FILE_ERROR">
          Invalid image file location.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Could not find a floppy image matching @a imageID.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid media state.
        </result>

      </desc>
      <param name="imageId" type="uuid" dir="in"/>
    </method>

    <method name="captureHostDrive">
      <desc>Captures the specified host floppy drive.</desc>
      <param name="drive" type="IHostFloppyDrive" dir="in"/>
    </method>

    <method name="unmount">
      <desc>Unmounts the currently mounted image or host drive.</desc>
    </method>

    <method name="getImage">
      <desc>Returns the currently mounted floppy image.</desc>
      <param name="image" type="IFloppyImage2" dir="return"/>
    </method>

    <method name="getHostDrive">
      <desc>Returns the currently mounted host floppy drive.</desc>
      <param name="drive" type="IHostFloppyDrive" dir="return"/>
    </method>

  </interface>


  <!--
  // IKeyboard
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IKeyboard" extends="$unknown"
     uuid="2d1a531b-4c6e-49cc-8af6-5c857b78b5d7"
     wsmap="managed"
     >
    <desc>
      The IKeyboard interface represents the virtual machine's keyboard. Used
      in <link to="IConsole::keyboard"/>.

      Use this interface to send keystrokes or the Ctrl-Alt-Del sequence
      to the virtual machine.

    </desc>
    <method name="putScancode">
      <desc>Sends a scancode to the keyboard.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send scan code to virtual keyboard.
        </result>

      </desc>
      <param name="scancode" type="long" dir="in"/>
    </method>

    <method name="putScancodes">
      <desc>Sends an array of scancodes to the keyboard.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send all scan codes to virtual keyboard.
        </result>

      </desc>
      <param name="scancodes" type="long" dir="in" safearray="yes"/>
      <param name="codesStored" type="unsigned long" dir="return"/>
    </method>

    <method name="putCAD">
      <desc>Sends the Ctrl-Alt-Del sequence to the keyboard. This
      function is nothing special, it is just a convenience function
      calling <link to="IKeyboard::putScancodes"/> with the proper scancodes.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send all scan codes to virtual keyboard.
        </result>

      </desc>
    </method>

  </interface>


  <!--
  // IMouse
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MouseButtonState"
    uuid="03131722-2EC5-4173-9794-0DACA46673EF"
  >
    <desc>
      Mouse button state.
    </desc>

    <const name="LeftButton"        value="0x01"/>
    <const name="RightButton"       value="0x02"/>
    <const name="MiddleButton"      value="0x04"/>
    <const name="WheelUp"           value="0x08"/>
    <const name="WheelDown"         value="0x10"/>
    <const name="MouseStateMask"    value="0x1F"/>
  </enum>

  <interface
     name="IMouse" extends="$unknown"
     uuid="FD443EC1-0006-4F5B-9282-D72760A66916"
     wsmap="managed"
     >
    <desc>
      The IMouse interface represents the virtual machine's mouse. Used in
      <link to="IConsole::mouse"/>.

      Through this interface, the virtual machine's virtual mouse can be
      controlled.
    </desc>

    <attribute name="absoluteSupported" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS supports absolute mouse pointer positioning
        or not.
        <note>
          VirtualBox Guest Tools need to be installed to the guest OS
          in order to enable absolute mouse positioning support.
          You can use the <link to="IConsoleCallback::onMouseCapabilityChange"/>
          callback to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEventAbsolute"/></see>
      </desc>
    </attribute>

    <method name="putMouseEvent">
      <desc>
        Initiates a mouse event using relative pointer movements
        along x and y axis.

        <result name="E_ACCESSDENIED">
          Console not powered up.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not send mouse event to virtual mouse.
        </result>

      </desc>

      <param name="dx" type="long" dir="in">
        <desc>
          Amount of pixels the mouse should move to the right.
          Negative values move the mouse to the left.
        </desc>
      </param>
      <param name="dy" type="long" dir="in">
        <desc>
          Amount of pixels the mouse should move downwards.
          Negative values move the mouse upwards.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwise wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of <tt>1</tt> means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

    <method name="putMouseEventAbsolute">
      <desc>
        Positions the mouse pointer using absolute x and y coordinates.
        These coordinates are expressed in pixels and
        start from <tt>[1,1]</tt> which corresponds to the top left
        corner of the virtual display.

        <result name="E_ACCESSDENIED">
          Console not powered up.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not send mouse event to virtual mouse.
        </result>

        <note>
          This method will have effect only if absolute mouse
          positioning is supported by the guest OS.
        </note>

        <see><link to="#absoluteSupported"/></see>
      </desc>

      <param name="x" type="long" dir="in">
        <desc>
          X coordinate of the pointer in pixels, starting from <tt>1</tt>.
        </desc>
      </param>
      <param name="y" type="long" dir="in">
        <desc>
          Y coordinate of the pointer in pixels, starting from <tt>1</tt>.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwise wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of <tt>1</tt> means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

  </interface>

  <!--
  // IDisplay
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="FramebufferAccelerationOperation"
    uuid="f0e5ebbe-dc8e-4e2d-916e-53baa3844df8"
  >
    <desc>
      Frame buffer acceleration operation.
    </desc>

    <const name="SolidFillAcceleration"   value="1"/>
    <const name="ScreenCopyAcceleration"  value="2"/>
  </enum>

  <enum
    name="FramebufferPixelFormat"
    uuid="6b27d1fc-4f2c-4e9c-a166-01d06540305d"
  >
    <desc>
      Format of the video memory buffer. Constants represented by this enum can
      be used to test for particular values of <link
      to="IFramebuffer::pixelFormat"/>. See also <link
      to="IFramebuffer::requestResize()"/>.

      See also www.fourcc.org for more information about FOURCC pixel formats.
    </desc>

    <const name="Opaque"                  value="0xFFFFFFFF">
      <desc>
        Unknown buffer format (the user may not assume any particular format of
        the buffer).
      </desc>
    </const>
    <const name="FOURCC_RGB"              value="0x32424752">
      <desc>
        Basic RGB format (<link to="IFramebuffer::bitsPerPixel"/> determines the
        bit layout).
      </desc>
    </const>
  </enum>

  <interface
     name="IFramebuffer" extends="$unknown"
     uuid="af431304-5b09-40e2-94da-3c3cb03822c1"
     wsmap="suppress"
     >
    <attribute name="address" type="octet" mod="ptr" readonly="yes">
      <desc>Address of the start byte of the frame buffer.</desc>
    </attribute>

    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>Frame buffer width, in pixels.</desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>Frame buffer height, in pixels.</desc>
    </attribute>

    <attribute name="bitsPerPixel" type="unsigned long" readonly="yes">
      <desc>
        Color depth, in bits per pixel. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat_FOURCC_RGB">FOURCC_RGB</link>, valid values
        are: 8, 15, 16, 24 and 32.
      </desc>
    </attribute>

    <attribute name="bytesPerLine" type="unsigned long" readonly="yes">
      <desc>
        Scan line size, in bytes. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat_FOURCC_RGB">FOURCC_RGB</link>, the
        size of the scan line must be aligned to 32 bits.
      </desc>
    </attribute>

    <attribute name="pixelFormat" type="unsigned long" readonly="yes">
      <desc>
        Frame buffer pixel format. It's either one of the values defined by <link
        to="FramebufferPixelFormat"/> or a raw FOURCC code.
        <note>
          This attribute must never return <link
          to="FramebufferPixelFormat_Opaque"/> -- the format of the buffer
          <link to="#address"/> points to must be always known.
        </note>
      </desc>
    </attribute>

    <attribute name="usesGuestVRAM" type="boolean" readonly="yes">
      <desc>
        Defines whether this frame buffer uses the virtual video card's memory
        buffer (guest VRAM) directly or not. See <link
        to="IFramebuffer::requestResize()"/> for more information.
      </desc>
    </attribute>

    <attribute name="heightReduction" type="unsigned long" readonly="yes">
      <desc>
        Hint from the frame buffer about how much of the standard
        screen height it wants to use for itself. This information is
        exposed to the guest through the VESA BIOS and VMMDev interface
        so that it can use it for determining its video mode table. It
        is not guaranteed that the guest respects the value.
      </desc>
    </attribute>

    <attribute name="overlay" type="IFramebufferOverlay" readonly="yes">
      <desc>
        An alpha-blended overlay which is superposed over the frame buffer.
        The initial purpose is to allow the display of icons providing
        information about the VM state, including disk activity, in front
        ends which do not have other means of doing that.  The overlay is
        designed to controlled exclusively by IDisplay.  It has no locking
        of its own, and any changes made to it are not guaranteed to be
        visible until the affected portion of IFramebuffer is updated.  The
        overlay can be created lazily the first time it is requested.  This
        attribute can also return NULL to signal that the overlay is not
        implemented.
      </desc>
    </attribute>

    <attribute name="winId" type="unsigned long long" readonly="yes">
      <desc>
        Platform-dependent identifier of the window where context of this
        frame buffer is drawn, or zero if there's no such window.
      </desc>
    </attribute>

    <method name="lock">
      <desc>
        Locks the frame buffer.
        Gets called by the IDisplay object where this frame buffer is
        bound to.
      </desc>
    </method>

    <method name="unlock">
      <desc>
        Unlocks the frame buffer.
        Gets called by the IDisplay object where this frame buffer is
        bound to.
      </desc>
    </method>

    <method name="notifyUpdate">
      <desc>
        Informs about an update.
        Gets called by the display object where this buffer is
        registered.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="finished" type="boolean" dir="return"/>
    </method>

    <method name="requestResize">
      <desc>
        Requests a size and pixel format change.

        There are two modes of working with the video buffer of the virtual
        machine. The <i>indirect</i> mode implies that the IFramebuffer
        implementation allocates a memory buffer for the requested display mode
        and provides it to the virtual machine. In <i>direct</i> mode, the
        IFramebuffer implementation uses the memory buffer allocated and owned
        by the virtual machine. This buffer represents the video memory of the
        emulated video adapter (so called <i>guest VRAM</i>). The direct mode is
        usually faster because the implementation gets a raw pointer to the
        guest VRAM buffer which it can directly use for visualizing the contents
        of the virtual display, as opposed to the indirect mode where the
        contents of guest VRAM are copied to the memory buffer provided by
        the implementation every time a display update occurs.

        It is important to note that the direct mode is really fast only when
        the implementation uses the given guest VRAM buffer directly, for
        example, by blitting it to the window representing the virtual machine's
        display, which saves at least one copy operation comparing to the
        indirect mode. However, using the guest VRAM buffer directly is not
        always possible: the format and the color depth of this buffer may be
        not supported by the target window, or it may be unknown (opaque) as in
        case of text or non-linear multi-plane VGA video modes. In this case,
        the indirect mode (that is always available) should be used as a
        fallback: when the guest VRAM contents are copied to the
        implementation-provided memory buffer, color and format conversion is
        done automatically by the underlying code.

        The @a pixelFormat parameter defines whether the direct mode is
        available or not. If @a pixelFormat is <link
        to="FramebufferPixelFormat_Opaque"/> then direct access to the guest
        VRAM buffer is not available -- the @a VRAM, @a bitsPerPixel and @a
        bytesPerLine parameters must be ignored and the implementation must use
        the indirect mode (where it provides its own buffer in one of the
        supported formats). In all other cases, @a pixelFormat together with @a
        bitsPerPixel and @a bytesPerLine define the format of the video memory
        buffer pointed to by the @a VRAM parameter and the implementation is
        free to choose which mode to use. To indicate that this frame buffer uses
        the direct mode, the implementation of the <link to="#usesGuestVRAM"/>
        attribute must return <tt>true</tt> and <link to="#address"/> must
        return exactly the same address that is passed in the @a VRAM parameter
        of this method; otherwise it is assumed that the indirect strategy is
        chosen.

        The @a width and @a height parameters represent the size of the
        requested display mode in both modes. In case of indirect mode, the
        provided memory buffer should be big enough to store data of the given
        display mode. In case of direct mode, it is guaranteed that the given @a
        VRAM buffer contains enough space to represent the display mode of the
        given size. Note that this frame buffer's <link to="#width"/> and <link
        to="#height"/> attributes must return exactly the same values as
        passed to this method after the resize is completed (see below).

        The @a finished output parameter determines if the implementation has
        finished resizing the frame buffer or not. If, for some reason, the
        resize cannot be finished immediately during this call, @a finished
        must be set to @c false, and the implementation must call
        <link to="IDisplay::resizeCompleted()"/> after it has returned from
        this method as soon as possible. If @a finished is @c false, the
        machine will not call any frame buffer methods until
        <link to="IDisplay::resizeCompleted()"/> is called.

        Note that if the direct mode is chosen, the <link to="#bitsPerPixel"/>,
        <link to="#bytesPerLine"/> and <link to="#pixelFormat"/> attributes of
        this frame buffer must return exactly the same values as specified in the
        parameters of this method, after the resize is completed. If the
        indirect mode is chosen, these attributes must return values describing
        the format of the implementation's own memory buffer <link
        to="#address"/> points to. Note also that the <link to="#bitsPerPixel"/>
        value must always correlate with <link to="#pixelFormat"/>. Note that
        the <link to="#pixelFormat"/> attribute must never return <link
        to="FramebufferPixelFormat_Opaque"/> regardless of the selected mode.

        <note>
          This method is called by the IDisplay object under the
          <link to="#lock()"/> provided by this IFramebuffer
          implementation. If this method returns @c false in @a finished, then
          this lock is not released until
          <link to="IDisplay::resizeCompleted()"/> is called.
        </note>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Logical screen number. Must be used in the corresponding call to
          <link to="IDisplay::resizeCompleted()"/> if this call is made.
        </desc>
      </param>
      <param name="pixelFormat" type="unsigned long" dir="in">
        <desc>
          Pixel format of the memory buffer pointed to by @a VRAM.
          See also <link to="FramebufferPixelFormat"/>.
        </desc>
      </param>
      <param name="VRAM" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the virtual video card's VRAM (may be @c null).</desc>
      </param>
      <param name="bitsPerPixel" type="unsigned long" dir="in">
        <desc>Color depth, bits per pixel.</desc>
      </param>
      <param name="bytesPerLine" type="unsigned long" dir="in">
        <desc>Size of one scan line, in bytes.</desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>Width of the guest display, in pixels.</desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>Height of the guest display, in pixels.</desc>
      </param>
      <param name="finished" type="boolean" dir="return">
        <desc>
          Can the VM start using the new frame buffer immediately
          after this method returns or it should wait for
          <link to="IDisplay::resizeCompleted()"/>.
        </desc>
      </param>
    </method>

    <method name="operationSupported">
      <desc>
        Returns whether the given acceleration operation is supported
        by the IFramebuffer implementation. If not, the display object
        will not attempt to call the corresponding IFramebuffer entry
        point. Even if an operation is indicated as supported, the
        IFramebuffer implementation always has the option to return non
        supported from the corresponding acceleration method in which
        case the operation will be performed by the display engine. This
        allows for reduced IFramebuffer implementation complexity where
        only common cases are handled.
      </desc>
      <param name="operation" type="FramebufferAccelerationOperation" dir="in"/>
      <param name="supported" type="boolean" dir="return"/>
    </method>

    <method name="videoModeSupported">
      <desc>
        Returns whether the frame buffer implementation is willing to
        support a given video mode. In case it is not able to render
        the video mode (or for some reason not willing), it should
        return false. Usually this method is called when the guest
        asks the VMM device whether a given video mode is supported
        so the information returned is directly exposed to the guest.
        It is important that this method returns very quickly.
      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bpp" type="unsigned long" dir="in"/>
      <param name="supported" type="boolean" dir="return"/>
    </method>

    <method name="solidFill">
      <desc>
        Fills the specified rectangle on screen with a solid color.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="color" type="unsigned long" dir="in"/>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="copyScreenBits">
      <desc>
        Copies specified rectangle on the screen.
      </desc>
      <param name="xDst" type="unsigned long" dir="in"/>
      <param name="yDst" type="unsigned long" dir="in"/>
      <param name="xSrc" type="unsigned long" dir="in"/>
      <param name="ySrc" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="getVisibleRegion">
      <desc>
        Returns the visible region of this frame buffer.

        If the @a rectangles parameter is <tt>NULL</tt> then the value of the
        @a count parameter is ignored and the number of elements necessary to
        describe the current visible region is returned in @a countCopied.

        If @a rectangles is not <tt>NULL</tt> but @a count is less
        than the required number of elements to store region data, the method
        will report a failure. If @a count is equal or greater than the
        required number of elements, then the actual number of elements copied
        to the provided array will be returned in @a countCopied.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          Method not yet implemented.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the <tt>RTRECT</tt> array to receive region data.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of <tt>RTRECT</tt> elements in the @a rectangles array.</desc>
      </param>
      <param name="countCopied" type="unsigned long" dir="return">
        <desc>Number of elements copied to the @a rectangles array.</desc>
      </param>
    </method>

    <method name="setVisibleRegion">
      <desc>
        Suggests a new visible region to this frame buffer.  This region
        represents the area of the VM display which is a union of regions of
        all top-level windows of the guest operating system running inside the
        VM (if the Guest Additions for this system support this
        functionality). This information may be used by the frontends to
        implement the seamless desktop integration feature.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          The IFramebuffer implementation must make a copy of the provided
          array of rectangles.
        </note>
        <note>
          Method not yet implemented.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the <tt>RTRECT</tt> array.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of <tt>RTRECT</tt> elements in the @a rectangles array.</desc>
      </param>
    </method>

  </interface>

  <interface
     name="IFramebufferOverlay" extends="IFrameBuffer"
     uuid="0bcc1c7e-e415-47d2-bfdb-e4c705fb0f47"
     wsmap="suppress"
     >
    <desc>
      The IFramebufferOverlay interface represents an alpha blended overlay
      for displaying status icons above an IFramebuffer.  It is always created
      not visible, so that it must be explicitly shown.  It only covers a
      portion of the IFramebuffer, determined by its width, height and
      co-ordinates.  It is always in packed pixel little-endian 32bit ARGB (in
      that order) format, and may be written to directly.  Do re-read the
      width though, after setting it, as it may be adjusted (increased) to
      make it more suitable for the front end.
    </desc>
    <attribute name="x" type="unsigned long" readonly="yes">
      <desc>X position of the overlay, relative to the frame buffer.</desc>
    </attribute>

    <attribute name="y" type="unsigned long" readonly="yes">
      <desc>Y position of the overlay, relative to the frame buffer.</desc>
    </attribute>

    <attribute name="visible" type="boolean" readonly="no">
      <desc>
        Whether the overlay is currently visible.
      </desc>
    </attribute>

    <attribute name="alpha" type="unsigned long" readonly="no">
      <desc>
        The global alpha value for the overlay.  This may or may not be
        supported by a given front end.
      </desc>
    </attribute>

    <method name="move">
      <desc>
        Changes the overlay's position relative to the IFramebuffer.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
    </method>

  </interface>

  <interface
     name="IDisplay" extends="$unknown"
     uuid="09789f63-4525-48e5-a5e4-1080453b0eab"
     wsmap="suppress"
     >
    <desc>
      The IDisplay interface represents the virtual machine's display.

      The object implementing this interface is contained in each
      <link to="IConsole::display"/> attribute and represents the visual
      output of the virtual machine.

      The virtual display supports pluggable output targets represented by the
      IFramebuffer interface. Examples of the output target are a window on
      the host computer or an RDP session's display on a remote computer.
    </desc>
    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>Current display width.</desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>Current display height.</desc>
    </attribute>

    <attribute name="bitsPerPixel" type="unsigned long" readonly="yes">
      <desc>
        Current guest display color depth. Note that this may differ
        from <link to="IFramebuffer::bitsPerPixel"/>.
      </desc>
    </attribute>

    <method name="setupInternalFramebuffer">
      <desc>
        Prepares an internally managed frame buffer.
      </desc>
      <param name="depth" type="unsigned long" dir="in"/>
    </method>

    <method name="lockFramebuffer">
      <desc>
        Requests access to the internal frame buffer.

        <result name="VBOX_E_NOT_SUPPORTED">
          Attempt to lock a non-internal frame buffer.
        </result>

      </desc>
      <param name="address" type="octet" mod="ptr" dir="return"/>
    </method>

    <method name="unlockFramebuffer">
      <desc>
        Releases access to the internal frame buffer.

        <result name="VBOX_E_NOT_SUPPORTED">
          Attempt to unlock a non-internal frame buffer.
        </result>

      </desc>
    </method>

    <method name="registerExternalFramebuffer">
      <desc>
        Registers an external frame buffer.
      </desc>
      <param name="framebuffer" type="IFramebuffer" dir="in"/>
    </method>

    <method name="setFramebuffer">
      <desc>
        Sets the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="in"/>
    </method>

    <method name="getFramebuffer">
      <desc>
        Queries the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="out"/>
      <param name="xOrigin" type="long" dir="out"/>
      <param name="yOrigin" type="long" dir="out"/>
    </method>

    <method name="setVideoModeHint">
      <desc>
        Asks VirtualBox to request the given video mode from
        the guest. This is just a hint and it cannot be guaranteed
        that the requested resolution will be used. Guest Additions
        are required for the request to be seen by guests. The caller
        should issue the request and wait for a resolution change and
        after a timeout retry.

        Specifying <tt>0</tt> for either @a width, @a height or @a bitsPerPixel
        parameters means that the corresponding values should be taken from the
        current video mode (i.e. left unchanged).

        If the guest OS supports multi-monitor configuration then the @a display
        parameter specifies the number of the guest display to send the hint to:
        <tt>0</tt> is the primary display, <tt>1</tt> is the first secondary and
        so on. If the multi-monitor configuration is not supported, @a display
        must be <tt>0</tt>.

        <result name="E_INVALIDARG">
          The @a display is not associated with any monitor.
        </result>

      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bitsPerPixel" type="unsigned long" dir="in"/>
      <param name="display" type="unsigned long" dir="in"/>
    </method>

    <method name="setSeamlessMode">
      <desc>
        Enables or disables seamless guest display rendering (seamless desktop
        integration) mode.
        <note>
          Calling this method has no effect if <link
          to="IGuest::supportsSeamless"/> returns <tt>false</tt>.
        </note>
      </desc>
      <param name="enabled" type="boolean" dir="in"/>
    </method>

    <method name="takeScreenShot">
      <desc>
        Takes a screen shot of the requested size and copies it to the
        32-bpp buffer allocated by the caller.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not take a screenshot.
        </result>

      </desc>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="drawToScreen">
      <desc>
        Draws a 32-bpp image of the specified size from the given buffer
        to the given point on the VM display.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not draw to screen.
        </result>

      </desc>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="invalidateAndUpdate">
      <desc>
        Does a full invalidation of the VM display and instructs the VM
        to update it.

        <result name="VBOX_E_IPRT_ERROR">
          Could not invalidate and update screen.
        </result>

      </desc>
    </method>

    <method name="resizeCompleted">
      <desc>
        Signals that a framebuffer has completed the resize operation.

        <result name="VBOX_E_NOT_SUPPORTED">
          Operation only valid for external frame buffers.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
    </method>

    <method name="updateCompleted">
      <desc>
        Signals that a framebuffer has completed the update operation.

        <result name="VBOX_E_NOT_SUPPORTED">
          Operation only valid for external frame buffers.
        </result>

      </desc>
    </method>

  </interface>

  <!--
  // INetworkAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="NetworkAttachmentType"
    uuid="8730d899-d036-4925-bc63-e58f3486f4bf"
  >
    <desc>
      Network attachment type.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value, also means "not attached".</desc>
    </const>
    <const name="NAT"                   value="1"/>
    <const name="HostInterface"         value="2"/>
    <const name="Internal"              value="3"/>
  </enum>

  <enum
    name="NetworkAdapterType"
    uuid="156b17b9-5d61-4d54-be90-62e37dda848d"
  >
    <desc>
      Network adapter type.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Am79C970A"             value="1"/>
    <const name="Am79C973"              value="2"/>
    <const name="I82540EM"              value="3"/>
    <const name="I82543GC"              value="4"/>
  </enum>

  <interface
     name="INetworkAdapter" extends="$unknown"
     uuid="a876d9b1-68d9-43b1-9c68-ddea0a473663"
     wsmap="managed"
     >
    <attribute name="adapterType" type="NetworkAdapterType">
      <desc>
        Type of the virtual network adapter. Depending on this value,
        VirtualBox will provide a different virtual network hardware
        to the guest.
      </desc>
    </attribute>

    <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this adapter is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getNetworkAdapter"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the network adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain this network adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>

    <attribute name="MACAddress" type="wstring">
      <desc>
        Ethernet MAC address of the adapter, 12 hexadecimal characters. When setting
        it to NULL, VirtualBox will generate a unique MAC address.
      </desc>
    </attribute>

    <attribute name="attachmentType" type="NetworkAttachmentType" readonly="yes"/>

    <attribute name="hostInterface" type="wstring">
      <desc>
        Name of the host network interface the VM is attached to.
      </desc>
    </attribute>

    <attribute name="internalNetwork" type="wstring">
      <desc>
        Name of the internal network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="NATNetwork" type="wstring">
      <desc>
        Name of the NAT network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="cableConnected" type="boolean">
      <desc>
        Flag whether the adapter reports the cable as connected or not.
        It can be used to report offline situations to a VM.
      </desc>
    </attribute>

    <attribute name="lineSpeed" type="unsigned long">
      <desc>
        Line speed reported by custom drivers, in units of 1 kbps.
      </desc>
    </attribute>

    <attribute name="traceEnabled" type="boolean">
      <desc>
        Flag whether network traffic from/to the network card should be traced.
        Can only be toggled when the VM is turned off.
      </desc>
    </attribute>

    <attribute name="traceFile" type="wstring">
      <desc>
        Filename where a network trace will be stored. If not set, VBox-pid.pcap
        will be used.
      </desc>
    </attribute>

    <method name="attachToNAT">
      <desc>
        Attach the network adapter to the Network Address Translation (NAT) interface.
      </desc>
    </method>

    <method name="attachToHostInterface">
      <desc>
        Attach the network adapter to a host interface.
      </desc>
    </method>

    <method name="attachToInternalNetwork">
      <desc>
        Attach the network adapter to an internal network.
      </desc>
    </method>

    <method name="detach">
      <desc>
        Detach the network adapter
      </desc>
    </method>
  </interface>


  <!--
  // ISerialPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="PortMode"
    uuid="b266f43c-2e93-46b3-812b-c20e600e867b"
  >
    <desc>
      The PortMode enumeration represents possible communication modes for
      the virtual serial port device.
    </desc>

    <const name="Disconnected"        value="0">
      <desc>Virtual device is not attached to any real host device.</desc>
    </const>
    <const name="HostPipe"            value="1">
      <desc>Virtual device is attached to a host pipe.</desc>
    </const>
    <const name="HostDevice"          value="2">
      <desc>Virtual device is attached to a host device.</desc>
    </const>
  </enum>

  <interface
     name="ISerialPort" extends="$unknown"
     uuid="937f6970-5103-4745-b78e-d28dcf1479a8"
     wsmap="managed"
     >

    <desc>
      The ISerialPort interface represents the virtual serial port device.

      The virtual serial port device acts like an ordinary serial port
      inside the virtual machine. This device communicates to the real
      serial port hardware in one of two modes: host pipe or host device.

      In host pipe mode, the #path attribute specifies the path to the pipe on
      the host computer that represents a serial port. The #server attribute
      determines if this pipe is created by the virtual machine process at
      machine startup or it must already exist before starting machine
      execution.

      In host device mode, the #path attribute specifies the name of the
      serial port device on the host computer.

      There is also a third communication mode: the disconnected mode. In this
      mode, the guest OS running inside the virtual machine will be able to
      detect the serial port, but all port write operations will be discarded
      and all port read operations will return no data.

      <see>IMachine::getSerialPort</see>
    </desc>

     <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this serial port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getSerialPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the serial port is enabled. If disabled,
        the serial port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the serial port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the serial port.</desc>
    </attribute>

    <attribute name="hostMode" type="PortMode">
      <desc>
        How is this port connected to the host.
        <note>
          Changing this attribute may fail if the conditions for
          <link to="#path"/> are not met.
        </note>
      </desc>
    </attribute>

    <attribute name="server" type="boolean">
      <desc>
        Flag whether this serial port acts as a server (creates a new pipe on
        the host) or as a client (uses the existing pipe). This attribute is
        used only when <link to="#hostMode"/> is PortMode_HostPipe.
      </desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Path to the serial port's pipe on the host when <link to="#hostMode"/> is
        PortMode_HostPipe, or the host serial device name when
        <link to="#hostMode"/> is PortMode_HostDevice. In either of the above
        cases, setting a @c  null or an empty string as the attribute's value
        will result into an error. Otherwise, the value of this property is
        ignored.
      </desc>
    </attribute>

  </interface>

  <!--
  // IParallelPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IParallelPort" extends="$unknown"
     uuid="0c925f06-dd10-4b77-8de8-294d738c3214"
     wsmap="managed"
     >

    <desc>
      The IParallelPort interface represents the virtual parallel port device.

      The virtual parallel port device acts like an ordinary parallel port
      inside the virtual machine. This device communicates to the real
      parallel port hardware using the name of the parallel device on the host
      computer specified in the #path attribute.

      Each virtual parallel port device is assigned a base I/O address and an
      IRQ number that will be reported to the guest operating system and used
      to operate the given parallel port from within the virtual machine.

      <see>IMachine::getParallelPort</see>
    </desc>

     <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this parallel port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getParallelPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the parallel port is enabled. If disabled,
        the parallel port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the parallel port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the parallel port.</desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Host parallel device name. If this parallel port is enabled, setting a
        @c null or an empty string as this attribute's value will result into
        an error.
      </desc>
    </attribute>

  </interface>


  <!--
  // IMachineDebugger
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IMachineDebugger" extends="$unknown"
     uuid="b0b2a2dd-0627-4502-91c2-ddc5e77609e0"
     wsmap="suppress"
     >
    <method name="resetStats">
      <desc>
        Reset VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="dumpStats">
      <desc>
        Dumps VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="getStats">
      <desc>
        Get the VM statistics in a XMLish format.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
      <param name="withDescriptions" type="boolean" dir="in">
        <desc>Whether to include the descriptions.</desc>
      </param>
      <param name="stats" type="wstring" dir="out">
        <desc>The XML document containing the statistics.</desc>
      </param>
    </method>

    <method name="injectNMI">
      <desc>
        Inject an NMI into a running VT-x/AMD-V VM.
      </desc>
    </method>

    <attribute name="singlestep" type="boolean">
      <desc>Switch for enabling singlestepping.</desc>
    </attribute>

    <attribute name="recompileUser" type="boolean">
      <desc>Switch for forcing code recompilation for user mode code.</desc>
    </attribute>

    <attribute name="recompileSupervisor" type="boolean">
      <desc>Switch for forcing code recompilation for supervisor mode code.</desc>
    </attribute>

    <attribute name="PATMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the PATM component.</desc>
    </attribute>

    <attribute name="CSAMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the CSAM component.</desc>
    </attribute>

    <attribute name="logEnabled" type="boolean">
      <desc>Switch for enabling and disabling logging.</desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of CPU hardware
        virtualization extensions.
      </desc>
    </attribute>

    <attribute name="HWVirtExNestedPagingEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the nested paging
        CPU hardware virtualization extension.
      </desc>
    </attribute>

    <attribute name="HWVirtExVPIDEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the VPID
        VT-x extension.
      </desc>
    </attribute>

    <attribute name="PAEEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the Physical
        Address Extension CPU feature.
      </desc>
    </attribute>

    <attribute name="virtualTimeRate" type="unsigned long">
      <desc>
        The rate at which the virtual time runs expressed as a percentage.
        The accepted range is 2% to 20000%.
      </desc>
    </attribute>

    <!-- @todo method for setting log flags, groups and destination! -->

    <attribute name="VM" type="unsigned long long" readonly="yes">
      <desc>
        Gets the VM handle. This is only for internal use while
        we carve the details of this interface.
      </desc>
    </attribute>

  </interface>

  <!--
  // IUSBController
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IUSBController" extends="$unknown"
     uuid="f4c2d3dc-f109-4da7-93b1-ec28973ac89f"
     wsmap="managed"
     >
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the USB controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any USB controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="enabledEhci" type="boolean">
      <desc>
        Flag whether the USB EHCI controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain a USB EHCI controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="USBStandard" type="unsigned short" readonly="yes">
      <desc>
        USB standard version which the controller implements.
        This is a BCD which means that the major version is in the
        high byte and minor version is in the low byte.
      </desc>
    </attribute>

    <attribute name="deviceFilters" type="IUSBDeviceFilterCollection" readonly="yes">
      <desc>
        List of USB device filters associated with the machine.

        If the machine is currently running, these filters are activated
        every time a new (supported) USB device is attached to the host
        computer that was not ignored by global filters
        (<link to="IHost::USBDeviceFilters"/>).

        These filters are also activated when the machine is powered up.
        They are run against a list of all currently available USB
        devices (in states
        <link to="USBDeviceState_Available"/>,
        <link to="USBDeviceState_Busy"/>,
        <link to="USBDeviceState_Held"/>) that were not previously
        ignored by global filters.

        If at least one filter matches the USB device in question, this
        device is automatically captured (attached to) the virtual USB
        controller of this machine.

        <see>IUSBDeviceFilter, ::IUSBController</see>
      </desc>
    </attribute>

    <method name="createDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to <tt>null</tt> (any match),
        <i>active</i> is <tt>false</tt> (the filter is not active).

        The created filter can then be added to the list of filters using
        <link to="#insertDeviceFilter()"/>.

        <result name="VBOX_E_INVALID_VM_STATE">
          The virtual machine is not mutable.
        </result>

        <see>#deviceFilters</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from <tt>0</tt>. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added to the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter that is already in the collection, will return an
          error.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_INVALIDARG">
          USB device filter not created within this VirtualBox instance.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          USB device filter already in list.
        </result>

        <see>#deviceFilters</see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from <tt>0</tt>. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <see>#deviceFilters</see>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_INVALIDARG">
          USB device filter list empty or invalid @a position.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Removed USB device filter.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IUSBDeviceEnumerator" type="IUSBDevice"
     uuid="aefe00f7-eb8a-454b-9ea4-fd5ad93c0e99"
     />

  <collection
     name="IUSBDeviceCollection" type="IUSBDevice"
     enumerator="IUSBDeviceEnumerator"
     uuid="e31f3248-90dd-4ca2-95f0-6b36042d96a2"
     readonly="yes"
     >
    <method name="findById">
      <desc>
        Searches this collection for a USB device with the given UUID.
        <note>
          The method returns an error if the given UUID does not
          correspond to any USB device in the collection.
        </note>
        <see>IUSBDevice::id</see>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findByAddress">
      <desc>
        Searches this collection for a USB device with the given
        host address.
        <note>
          The method returns an error if the given address does not
          correspond to any USB device in the collection.
        </note>
        <see>IUSBDevice::address</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

  </collection>

  <interface
     name="IUSBDevice" extends="$unknown"
     uuid="850af07b-9ee8-48c2-b6b0-f6d0acbf63c3"
     wsmap="managed"
     >
    <desc>
      The IUSBDevice interface represents a virtual USB device attached to the
      virtual machine.

      A collection of objects implementing this interface is stored in the
      <link to="IConsole::USBDevices"/> attribute which lists all USB devices
      attached to a running virtual machine's USB controller.
    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>
        Unique USB device ID. This ID is built from #vendorId,
        #productId, #revision and #serialNumber.
      </desc>
    </attribute>

    <attribute name="vendorId" type="unsigned short" readonly="yes">
      <desc>Vendor ID.</desc>
    </attribute>

    <attribute name="productId" type="unsigned short" readonly="yes">
      <desc>Product ID.</desc>
    </attribute>

    <attribute name="revision" type="unsigned short" readonly="yes">
      <desc>
        Product revision number. This is a packed BCD represented as
        unsigned short. The high byte is the integer part and the low
        byte is the decimal.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring" readonly="yes">
      <desc>Manufacturer string.</desc>
    </attribute>

    <attribute name="product" type="wstring" readonly="yes">
      <desc>Product string.</desc>
    </attribute>

    <attribute name="serialNumber" type="wstring" readonly="yes">
      <desc>Serial number string.</desc>
    </attribute>

    <attribute name="address" type="wstring" readonly="yes">
      <desc>Host specific address of the device.</desc>
    </attribute>

    <attribute name="port" type="unsigned short" readonly="yes">
      <desc>
        Host USB port number the device is physically
        connected to.
      </desc>
    </attribute>

    <attribute name="version" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the device - 1 or 2.
      </desc>
    </attribute>

    <attribute name="portVersion" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the host USB port the device is
        physically connected to - 1 or 2. For devices not connected to
        anything this will have the same value as the version attribute.
      </desc>
    </attribute>

    <attribute name="remote" type="boolean" readonly="yes">
      <desc>
        Whether the device is physically connected to a remote VRDP
        client or to a local host machine.
      </desc>
    </attribute>

  </interface>


  <!--
  // IUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IUSBDeviceFilterEnumerator" type="IUSBDeviceFilter"
     uuid="d5109c61-93e7-4726-926b-0dee1020da56"
     />

  <collection
     name="IUSBDeviceFilterCollection" type="IUSBDeviceFilter"
     enumerator="IUSBDeviceFilterEnumerator"
     uuid="4fa3fc99-ceb1-4bf5-a9cb-e962d825c1ef"
     readonly="yes"
     />

  <interface
     name="IUSBDeviceFilter" extends="$unknown"
     uuid="d6831fb4-1a94-4c2c-96ef-8d0d6192066d"
     wsmap="managed"
     >
    <desc>
      The IUSBDeviceFilter interface represents an USB device filter used
      to perform actions on a group of USB devices.

      This type of filters is used by running virtual machines to
      automatically capture selected USB devices once they are physically
      attached to the host computer.

      A USB device is matched to the given device filter if and only if all
      attributes of the device match the corresponding attributes of the
      filter (that is, attributes are joined together using the logical AND
      operation). On the other hand, all together, filters in the list of
      filters carry the semantics of the logical OR operation. So if it is
      desirable to create a match like "this vendor id OR this product id",
      one needs to create two filters and specify "any match" (see below)
      for unused attributes.

      All filter attributes used for matching are strings. Each string
      is an expression representing a set of values of the corresponding
      device attribute, that will match the given filter. Currently, the
      following filtering expressions are supported:

      <ul>
        <li><i>Interval filters</i>. Used to specify valid intervals for
          integer device attributes (Vendor ID, Product ID and Revision).
          The format of the string is:

          <tt>int:((m)|([m]-[n]))(,(m)|([m]-[n]))*</tt>

          where <tt>m</tt> and <tt>n</tt> are integer numbers, either in octal
          (starting from <tt>0</tt>), hexadecimal (starting from <tt>0x</tt>)
          or decimal (otherwise) form, so that <tt>m &lt; n</tt>. If <tt>m</tt>
          is omitted before a dash (<tt>-</tt>), the minimum possible integer
          is assumed; if <tt>n</tt> is omitted after a dash, the maximum
          possible integer is assumed.
        </li>
        <li><i>Boolean filters</i>. Used to specify acceptable values for
          boolean device attributes. The format of the string is:

          <tt>true|false|yes|no|0|1</tt>

        </li>
        <li><i>Exact match</i>. Used to specify a single value for the given
          device attribute. Any string that doesn't start with <tt>int:</tt>
          represents the exact match. String device attributes are compared to
          this string including case of symbols. Integer attributes are first
          converted to a string (see individual filter attributes) and then
          compared ignoring case.

        </li>
        <li><i>Any match</i>. Any value of the corresponding device attribute
          will match the given filter. An empty or <tt>null</tt> string is
          used to construct this type of filtering expressions.

        </li>
      </ul>

      <note>
        On the Windows host platform, interval filters are not currently
        available. Also all string filter attributes
        (<link to="#manufacturer"/>, <link to="#product"/>,
        <link to="#serialNumber"/>) are ignored, so they behave as
        <i>any match</i> no matter what string expression is specified.
      </note>

      <see>IUSBController::deviceFilters, IHostUSBDeviceFilter</see>
    </desc>

    <attribute name="name" type="wstring">
      <desc>
        Visible name for this filter.
        This name is used to visually distinguish one filter from another,
        so it can neither be <tt>null</tt> nor an empty string.
      </desc>
    </attribute>

    <attribute name="active" type="boolean">
      <desc>Whether this filter active or has been temporarily disabled.</desc>
    </attribute>

    <attribute name="vendorId" type="wstring">
      <desc>
        <link to="IUSBDevice::vendorId">Vendor ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="productId" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="revision" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product revision number</link>
        filter. The string representation for the <i>exact matching</i>
        has the form <tt>IIFF</tt>, where <tt>I</tt> is the decimal digit
        of the integer part of the revision, and <tt>F</tt> is the
        decimal digit of its fractional part (including leading and
        trailing zeros).
        Note that for interval filters, it's best to use the hexadecimal
        form, because the revision is stored as a 16 bit packed BCD value;
        so the expression <tt>int:0x0100-0x0199</tt> will match any
        revision from <tt>1.0</tt> to <tt>1.99</tt>.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring">
      <desc>
        <link to="IUSBDevice::manufacturer">Manufacturer</link> filter.
      </desc>
    </attribute>

    <attribute name="product" type="wstring">
      <desc>
        <link to="IUSBDevice::product">Product</link> filter.
      </desc>
    </attribute>

    <attribute name="serialNumber" type="wstring">
      <desc>
        <link to="IUSBDevice::serialNumber">Serial number</link> filter.
      </desc>
    </attribute>

    <attribute name="port" type="wstring">
      <desc>
        <link to="IUSBDevice::port">Host USB port</link> filter.
      </desc>
    </attribute>

    <attribute name="remote" type="wstring">
      <desc>
        <link to="IUSBDevice::remote">Remote state</link> filter.
        <note>
          This filter makes sense only for machine USB filters,
          i.e. it is ignored by IHostUSBDeviceFilter objects.
        </note>
      </desc>
    </attribute>

    <attribute name="maskedInterfaces" type="unsigned long">
      <desc>
       This is an advanced option for hiding one or more USB interfaces
       from the guest. The value is a bit mask where the bits that are set
       means the corresponding USB interface should be hidden, masked off
       if you like.
       This feature only works on Linux hosts.
      </desc>
    </attribute>

  </interface>


  <!--
  // IHostUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
     name="USBDeviceState"
     uuid="b99a2e65-67fb-4882-82fd-f3e5e8193ab4"
     >
    <desc>
      USB device state. This enumeration represents all possible states
      of the USB device physically attached to the host computer regarding
      its state on the host computer and availability to guest computers
      (all currently running virtual machines).

      Once a supported USB device is attached to the host, global USB
      filters (<link to="IHost::USBDeviceFilters"/>) are activated. They can
      either ignore the device, or put it to USBDeviceState_Held state, or do
      nothing. Unless the device is ignored by global filters, filters of all
      currently running guests (<link to="IUSBController::deviceFilters"/>) are
      activated that can put it to USBDeviceState_Captured state.

      If the device was ignored by global filters, or didn't match
      any filters at all (including guest ones), it is handled by the host
      in a normal way. In this case, the device state is determined by
      the host and can be one of USBDeviceState_Unavailable, USBDeviceState_Busy
      or USBDeviceState_Available, depending on the current device usage.

      Besides auto-capturing based on filters, the device can be manually
      captured by guests (<link to="IConsole::attachUSBDevice()"/>) if its
      state is USBDeviceState_Busy, USBDeviceState_Available or
      USBDeviceState_Held.

      <note>
        Due to differences in USB stack implementations in Linux and Win32,
        states USBDeviceState_Busy and USBDeviceState_vailable are applicable
        only to the Linux version of the product. This also means that (<link
        to="IConsole::attachUSBDevice()"/>) can only succeed on Win32 if the
        device state is USBDeviceState_Held.
      </note>

      <see>IHostUSBDevice, IHostUSBDeviceFilter</see>
    </desc>

    <const name="NotSupported"          value="0">
      <desc>
        Not supported by the VirtualBox server, not available to guests.
      </desc>
    </const>
    <const name="Unavailable"           value="1">
      <desc>
        Being used by the host computer exclusively,
        not available to guests.
      </desc>
    </const>
    <const name="Busy"                  value="2">
      <desc>
        Being used by the host computer, potentially available to guests.
      </desc>
    </const>
    <const name="Available"             value="3">
      <desc>
        Not used by the host computer, available to guests (the host computer
        can also start using the device at any time).
      </desc>
    </const>
    <const name="Held"                  value="4">
      <desc>
        Held by the VirtualBox server (ignored by the host computer),
        available to guests.
      </desc>
    </const>
    <const name="Captured"              value="5">
      <desc>
        Captured by one of the guest computers, not available
        to anybody else.
      </desc>
    </const>
  </enum>

  <enumerator
     name="IHostUSBDeviceEnumerator" type="IHostUSBDevice"
     uuid="a0c55136-939f-4d20-b9d3-4d406f08bfa5"
     />

  <collection
     name="IHostUSBDeviceCollection" type="IHostUSBDevice"
     enumerator="IHostUSBDeviceEnumerator"
     uuid="f9d3f96d-b027-4994-b589-70bb9ee0d364"
     readonly="yes"
     >
    <method name="findById">
      <desc>
        Searches this collection for a USB device with the given UUID.
        <note>
          The method returns an error if the given UUID does not
          correspond to any USB device in the collection.
        </note>
        <see>IHostUSBDevice::id</see>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findByAddress">
      <desc>
        Searches this collection for a USB device with the given
        host address.
        <note>
          The method returns an error if the given address does not
          correspond to any USB device in the collection.
        </note>
        <see>IHostUSBDevice::address</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

  </collection>

  <interface
     name="IHostUSBDevice" extends="IUSBDevice"
     uuid="173b4b44-d268-4334-a00d-b6521c9a740a"
     wsmap="managed"
     >
    <desc>
      The IHostUSBDevice interface represents a physical USB device attached
      to the host computer.

      Besides properties inherited from IUSBDevice, this interface adds the
      <link to="#state"/> property that holds the current state of the USB
      device.

      <see>IHost::USBDevices, IHost::USBDeviceFilters</see>
    </desc>

    <attribute name="state" type="USBDeviceState" readonly="yes">
      <desc>
        Current state of the device.
      </desc>
    </attribute>

    <!-- @todo add class, subclass, bandwidth, configs, interfaces endpoints and such later. -->

  </interface>


  <!--
  // IHostUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="USBDeviceFilterAction"
    uuid="cbc30a49-2f4e-43b5-9da6-121320475933"
  >
    <desc>
      Actions for host USB device filters.
      <see>IHostUSBDeviceFilter, USBDeviceState</see>
    </desc>

    <const name="Null"          value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Ignore"        value="1">
      <desc>Ignore the matched USB device.</desc>
    </const>
    <const name="Hold"          value="2">
      <desc>Hold the matched USB device.</desc>
    </const>
  </enum>

  <enumerator
     name="IHostUSBDeviceFilterEnumerator" type="IHostUSBDeviceFilter"
     uuid="ff735211-903e-4642-9c37-189eb44579fe"
     />

  <collection
     name="IHostUSBDeviceFilterCollection" type="IHostUSBDeviceFilter"
     enumerator="IHostUSBDeviceFilterEnumerator"
     uuid="1a80458b-87f1-4a74-995d-04e2330119e0"
     readonly="yes"
     />

  <interface
     name="IHostUSBDeviceFilter" extends="IUSBDeviceFilter"
     uuid="4cc70246-d74a-400f-8222-3900489c0374"
     wsmap="managed"
     >
    <desc>
      The IHostUSBDeviceFilter interface represents a global filter for a
      physical USB device used by the host computer. Used indirectly in
      <link to="IHost::USBDeviceFilters"/>.

      Using filters of this type, the host computer determines the initial
      state of the USB device after it is physically attached to the
      host's USB controller.

      <note>
        The <link to="#remote"/> attribute is ignored by this type of
        filters, because it makes sense only for
        <link to="IUSBController::deviceFilters">machine USB filters</link>.
      </note>

      <see>IHost::USBDeviceFilters</see>
    </desc>

    <attribute name="action" type="USBDeviceFilterAction">
      <desc>
        Action performed by the host when an attached USB device
        matches this filter.
      </desc>
    </attribute>

  </interface>

  <!--
  // IAudioAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="AudioDriverType"
    uuid="4bcc3d73-c2fe-40db-b72f-0c2ca9d68496"
  >
    <desc>
      Host audio driver type.
    </desc>

    <const name="Null"          value="0">
      <desc>Null value, also means "dummy audio driver".</desc>
    </const>
    <const name="WinMM"         value="1"/>
    <const name="OSS"           value="2"/>
    <const name="ALSA"          value="3"/>
    <const name="DirectSound"   value="4"/>
    <const name="CoreAudio"     value="5"/>
    <const name="MMPM"          value="6"/>
    <const name="Pulse"         value="7"/>
    <const name="SolAudio"      value="8"/>
  </enum>

  <enum
    name="AudioControllerType"
    uuid="7afd395c-42c3-444e-8788-3ce80292f36c"
  >
    <desc>
      Virtual audio controller type.
    </desc>

    <const name="AC97" value="0"/>
    <const name="SB16" value="1"/>
  </enum>

  <interface
     name="IAudioAdapter" extends="$unknown"
     uuid="921873db-5f3f-4b69-91f9-7be9e535a2cb"
     wsmap="managed"
     >
    <desc>
        The IAudioAdapter interface represents the virtual audio adapter of
        the virtual machine. Used in <link to="IMachine::audioAdapter"/>.
    </desc>
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the audio adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any audio adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>
    <attribute name="audioController" type="AudioControllerType">
      <desc>
        The audio hardware we emulate.
      </desc>
    </attribute>
    <attribute name="audioDriver" type="AudioDriverType">
      <desc>
        Audio driver the adapter is connected to. This setting
        can only be changed when the VM is not running.
      </desc>
    </attribute>
  </interface>

  <!--
  // IVRDPServer
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="VRDPAuthType"
    uuid="3d91887a-b67f-4b33-85bf-2da7ab1ea83a"
  >
    <desc>
      VRDP authentication type.
    </desc>

    <const name="Null"            value="0">
      <desc>Null value, also means "no authentication".</desc>
    </const>
    <const name="External"        value="1"/>
    <const name="Guest"           value="2"/>
  </enum>

  <interface
     name="IVRDPServer" extends="$unknown"
     uuid="f4584ae7-6bce-474b-83d6-17d235e6aa89"
     wsmap="managed"
     >
    <attribute name="enabled" type="boolean">
      <desc>VRDP server status.</desc>
    </attribute>

    <attribute name="port" type="unsigned long">
      <desc>
        VRDP server port number.
        <note>
          Setting the value of this property to <tt>0</tt> will reset the port
          number to the default value which is
          currently <tt>3389</tt>. Reading this property will always return a
          real port number, even after it has been set to <tt>0</tt> (in which
          case the default port is returned).
        </note>
      </desc>
    </attribute>

    <attribute name="netAddress" type="wstring">
      <desc>VRDP server address.</desc>
    </attribute>

    <attribute name="authType" type="VRDPAuthType">
      <desc>VRDP authentication method.</desc>
    </attribute>

    <attribute name="authTimeout" type="unsigned long">
      <desc>Timeout for guest authentication. Milliseconds.</desc>
    </attribute>

    <attribute name="allowMultiConnection" type="boolean">
      <desc>
        Flag whether multiple simultaneous connections to the VM are permitted.
        Note that this will be replaced by a more powerful mechanism in the future.
      </desc>
    </attribute>

    <attribute name="reuseSingleConnection" type="boolean">
      <desc>
        Flag whether the existing connection must be dropped and a new connection
        must be established by the VRDP server, when a new client connects in single
        connection mode.
      </desc>
    </attribute>

  </interface>


  <!--
  // ISharedFolder
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="ISharedFolderEnumerator" type="ISharedFolder"
     uuid="1d420fd8-e7c1-4511-abf4-a504dc6d0cbf"
     />

  <collection
     name="ISharedFolderCollection" type="ISharedFolder"
     enumerator="ISharedFolderEnumerator"
     uuid="9c7e2282-bb16-4fa7-9138-f383c5e02353"
     readonly="yes">

    <method name="findByName">
      <desc>
        Searches this collection for a shared folder with the given logical
        name.
        <note>
          The method returns an error if the given name does not correspond to
          any shared folder in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to search for</desc>
      </param>
      <param name="sharedFolder" type="ISharedFolder" dir="return">
        <desc>Found shared folder object</desc>
      </param>
    </method>

  </collection>

  <interface
     name="ISharedFolder" extends="$unknown"
     uuid="8b0c5f70-9139-4f97-a421-64d5e9c335d5"
     wsmap="struct"
     >
    <desc>
      The ISharedFolder interface represents a folder in the host computer's
      file system accessible from the guest OS running inside a virtual
      machine using an associated logical name.

      There are three types of shared folders:
      <ul>
        <li><i>Global</i> (<link to="IVirtualBox::sharedFolders"/>), shared
        folders available to all virtual machines.</li>
        <li><i>Permanent</i> (<link to="IMachine::sharedFolders"/>),
        VM-specific shared folders available to the given virtual machine at
        startup.</li>
        <li><i>Transient</i> (<link to="IConsole::sharedFolders"/>),
        VM-specific shared folders created in the session context (for
        example, when the virtual machine is running) and automatically
        discarded when the session is closed (the VM is powered off).</li>
      </ul>

      Logical names of shared folders must be unique within the given scope
      (global, permanent or transient). However, they do not need to be unique
      across scopes. In this case, the definition of the shared folder in a
      more specific scope takes precedence over definitions in all other
      scopes. The order of precedence is (more specific to more general):
      <ol>
        <li>Transient definitions</li>
        <li>Permanent definitions</li>
        <li>Global definitions</li>
      </ol>

      For example, if MyMachine has a shared folder named
      <tt>C_DRIVE</tt> (that points to <tt>C:\\</tt>), then creating a
      transient shared folder named <tt>C_DRIVE</tt> (that points
      to <tt>C:\\\\WINDOWS</tt>) will change the definition
      of <tt>C_DRIVE</tt> in the guest OS so
      that <tt>\\\\VBOXSVR\\C_DRIVE</tt> will give access
      to <tt>C:\\WINDOWS</tt> instead of <tt>C:\\</tt> on the host
      PC. Removing the transient shared folder <tt>C_DRIVE</tt> will restore
      the previous (permanent) definition of <tt>C_DRIVE</tt> that points
      to <tt>C:\\</tt> if it still exists.

      Note that permanent and transient shared folders of different machines
      are in different name spaces, so they don't overlap and don't need to
      have unique logical names.

      <note>
        Global shared folders are not implemented in the current version of the
        product.
      </note>
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>Logical name of the shared folder.</desc>
    </attribute>

    <attribute name="hostPath" type="wstring" readonly="yes">
      <desc>Full path to the shared folder in the host file system.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is currently
        accessible or not.
        For example, the folder can be unaccessible if it is placed
        on the network share that is not available by the time
        this property is read.
      </desc>
    </attribute>

    <attribute name="writable" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is writable or
        not.
      </desc>
    </attribute>

  </interface>

  <!--
  // ISession
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IInternalSessionControl" extends="$unknown"
     uuid="2581845a-5a9d-45fb-bc3b-2476552dd970"
     internal="yes"
     wsmap="suppress"
     >
    <method name="getPID">
      <desc>PID of the process that has created this Session object.
      </desc>
      <param name="pid" type="unsigned long" dir="return"/>
    </method>

    <method name="getRemoteConsole">
      <desc>Returns the console object suitable for remote control.</desc>
      <param name="console" type="IConsole" dir="return"/>
    </method>

    <method name="assignMachine">
      <desc>
        Assigns the machine object associated with this direct-type
        session or informs the session that it will be a remote one
        (if machine = NULL).
      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="assignRemoteMachine">
      <desc>
        Assigns the machine and the (remote) console object associated with
        this remote-type session.
      </desc>
      <param name="machine" type="IMachine" dir="in"/>
      <param name="console" type="IConsole" dir="in"/>
    </method>

    <method name="updateMachineState">
      <desc>
        Updates the machine state in the VM process.
        Must be called only in certain cases
        (see the method implementation).
      </desc>
      <param name="aMachineState" type="MachineState" dir="in"/>
    </method>

    <method name="uninitialize">
      <desc>
        Uninitializes (closes) this session. Used by VirtualBox to close
        the corresponding remote session when the direct session dies
        or gets closed.
      </desc>
    </method>

    <method name="onDVDDriveChange">
      <desc>
        Triggered when settings of the DVD drive object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onFloppyDriveChange">
      <desc>
        Triggered when settings of the floppy drive object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Triggered when settings of a network adapter of the
        associated virtual machine have changed.
      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in"/>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Triggered when settings of a serial port of the
        associated virtual machine have changed.
      </desc>
      <param name="serialPort" type="ISerialPort" dir="in"/>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Triggered when settings of a parallel port of the
        associated virtual machine have changed.
      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in"/>
    </method>

    <method name="onVRDPServerChange">
      <desc>
        Triggered when settings of the VRDP server object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Triggered when settings of the USB controller object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Triggered when a permanent (global or machine) shared folder has been
        created or removed.
        <note>
          We don't pass shared folder parameters in this notification because
          the order in which parallel notifications are delivered is not defined,
          therefore it could happen that these parameters were outdated by the
          time of processing this notification.
        </note>
      </desc>
      <param name="global" type="boolean" dir="in"/>
    </method>

    <method name="onUSBDeviceAttach">
      <desc>
        Triggered when a request to capture a USB device (as a result
        of matched USB filters or direct call to
        <link to="IConsole::attachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
        describes a failure.
      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
      <param name="maskedInterfaces" type="unsigned long" dir="in"/>
    </method>

    <method name="onUSBDeviceDetach">
      <desc>
        Triggered when a request to release the USB device (as a result
        of machine termination or direct call to
        <link to="IConsole::detachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
      </desc>
      <param name="id" type="uuid" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
    </method>

    <method name="onShowWindow">
      <desc>
        Called by <link to="IMachine::canShowConsoleWindow()"/> and by
        <link to="IMachine::showConsoleWindow()"/> in order to notify
        console callbacks
        <link to="IConsoleCallback::onCanShowWindow()"/>
        and <link to="IConsoleCallback::onShowWindow()"/>.
      </desc>
      <param name="check" type="boolean" dir="in"/>
      <param name="canShow" type="boolean" dir="out"/>
      <param name="winId" type="unsigned long long" dir="out"/>
    </method>

    <method name="accessGuestProperty">
      <desc>
        Called by <link to="IMachine::getGuestProperty()"/> and by
        <link to="IMachine::setGuestProperty()"/> in order to read and
        modify guest properties.
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="value" type="wstring" dir="in"/>
      <param name="flags" type="wstring" dir="in"/>
      <param name="isSetter" type="boolean" dir="in"/>
      <param name="retValue" type="wstring" dir="out"/>
      <param name="retTimestamp" type="unsigned long long" dir="out"/>
      <param name="retFlags" type="wstring" dir="out"/>
    </method>

    <method name="enumerateGuestProperties">
      <desc>
        Return a list of the guest properties matching a set of patterns along
        with their values, time stamps and flags.
      </desc>
      <param name="patterns" type="wstring" dir="in">
        <desc>
          The patterns to match the properties against as a comma-separated
          string.  If this is empty, all properties currently set will be
          returned.
        </desc>
      </param>
      <param name="key" type="wstring" dir="out" safearray="yes">
        <desc>
          The key names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a key array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a key array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a key array.
        </desc>
      </param>
    </method>

  </interface>

  <interface
     name="ISession" extends="$dispatched"
     uuid="12F4DCDB-12B2-4ec1-B7CD-DDD9F6C5BF4D"
     wsmap="managed"
     >
    <desc>
      The ISession interface represents a serialization primitive for virtual
      machines.

      With VirtualBox, every time one wishes to manipulate a virtual machine
      (e.g. change its settings or start execution), a session object is
      required. Such an object must be passed to one of the session methods
      that open the given session, which then initiates the machine manipulation.

      A session serves several purposes: it identifies to the inter-process VirtualBox
      code which process is currently working with the virtual machine, and it ensures
      that there are no incompatible requests from several processes for the
      same virtual machine. Session objects can therefore be thought of as mutex
      semaphores that lock virtual machines to prevent conflicting accesses from
      several processes.

      How sessions objects are used depends on whether you use the Main API
      via COM or via the webservice:

      <ul>
      <li>When using the COM API directly, an object of the Session class from the
      VirtualBox type library needs to be created. In regular COM C++ client code,
      this can be done by calling <tt>createLocalObject()</tt>, a standard COM API.
      This object will  then act as a local session object in further calls to open
      a session.
      </li>

      <li>In the webservice, the session manager (IWebsessionManager) instead creates
      one session object automatically when <link to="IWebsessionManager::logon" />
      is called. A managed object reference to that session object can be retrieved by
      calling <link to="IWebsessionManager::getSessionObject" />. This session object
      reference can then be used to open sessions.
      </li>
      </ul>

      Sessions are mainly used in two variations:

      <ul>
      <li>
      To start a virtual machine in a separate process, one would call
      <link to="IVirtualBox::openRemoteSession"/>, which requires a session
      object as its first parameter. This session then identifies the caller
      and lets him control the started machine (for example, pause machine
      execution or power it down) as well as be notified about machine
      execution state changes.
      </li>

      <li>To alter machine settings, or to start machine execution within the
      current process, one needs to open a direct session for the machine first by
      calling <link to="IVirtualBox::openSession"/>. While a direct session
      is open within one process, no any other process may open another direct
      session for the same machine. This prevents the machine from being changed
      by other processes while it is running or while the machine is being configured.
      </li>
      </ul>

      One also can attach to an existing direct session already opened by
      another process (for example, in order to send a control request to the
      virtual machine such as the pause or the reset request). This is done by
      calling <link to="IVirtualBox::openExistingSession"/>.

      <note>
        Unless you are trying to write a new VirtualBox front-end that
        performs direct machine execution (like the VirtualBox or VBoxSDL
        front-ends), don't call <link to="IConsole::powerUp"/> in a direct
        session opened by <link to="IVirtualBox::openSession"/> and use this
        session only to change virtual machine settings. If you simply want to
        start virtual machine execution using one of the existing front-ends
        (for example the VirtualBox GUI or headless server), simply use
        <link to="IVirtualBox::openRemoteSession"/>; these front-ends
        will power up the machine automatically for you.
      </note>
    </desc>

    <attribute name="state" type="SessionState" readonly="yes">
      <desc>Current state of this session.</desc>
    </attribute>

    <attribute name="type" type="SessionType" readonly="yes">
      <desc>
        Type of this session. The value of this attribute is valid only
        if the session is currently open (i.e. its #state is
        SessionType_SessionOpen), otherwise an error will be returned.
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>Machine object associated with this session.</desc>
    </attribute>

    <attribute name="console" type="IConsole" readonly="yes">
      <desc>Console object associated with this session.</desc>
    </attribute>

    <method name="close">
      <desc>
        Closes a session that was previously opened.

        It is recommended that every time an "open session" method (such as
        <link to="IVirtualBox::openRemoteSession" /> or
        <link to="IVirtualBox::openSession" />) has been called to
        manipulate a virtual machine, the caller invoke
        ISession::close() when it's done doing so. Since sessions are
        serialization primitives much like ordinary mutexes, they are
        best used the same way: for each "open" call, there should be
        a matching "close" call, even when errors occur.

        Otherwise, if a direct session for a machine opened with
        <link to="IVirtualBox::openSession()"/> is not explicitly closed
        when the application terminates, the state of the machine will
        be set to <link to="MachineState_Aborted" /> on the server.

        Generally, it is recommended to close all open sessions explicitly
        before terminating the application (no matter what is the reason of
        the termination).

        <note>
          Do not expect the session state (<link to="ISession::state" />
          to return to "Closed" immediately after you invoke
          ISession::close(), particularly if you have started a remote
          session to execute the VM in a new process. The session state will
          automatically return to "Closed" once the VM is no longer executing,
          which can of course take a very long time.
        </note>
      </desc>
    </method>

  </interface>

  <!--
  // ISATAController
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="ISATAController" extends="$unknown"
    uuid="9a4b868b-1376-4533-8ef5-065b8e8cedff"
    wsmap="managed"
  >
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the SATA controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any SATA controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="portCount" type="unsigned long">
      <desc>
        The number of usable ports on the SATA controller.
        It ranges from 1 to 30.
      </desc>
    </attribute>

    <method name="GetIDEEmulationPort">
      <desc>Gets the corresponding port number which is emulated as an IDE device.</desc>
      <param name="devicePosition" type="long" dir="in"/>
      <param name="portNumber" type="long" dir="return"/>
    </method>

    <method name="SetIDEEmulationPort">
      <desc>Sets the port number which is emulated as an IDE device.</desc>
      <param name="devicePosition" type="long" dir="in"/>
      <param name="portNumber" type="long" dir="in"/>
    </method>

  </interface>

<if target="wsdl">

  <!--
  // IManagedObjectRef
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IManagedObjectRef" extends="$unknown"
     uuid="9474d09d-2313-46de-b568-a42b8718e8ed"
     internal="yes"
     wsmap="managed"
     wscpp="hardcoded"
     >
    <desc>
      Managed object reference.

      Only within the webservice, a managed object reference (which is really
      an opaque number) allows a webservice client to address an object
      that lives in the address space of the webservice server.

      Behind each managed object reference, there is a COM object that lives
      in the webservice server's address space. The COM object is not freed
      until the managed object reference is released, either by an explicit
      call to  <link to="IManagedObjectRef::release" /> or by logging off from
      the webservice (<link to="IWebsessionManager::logoff" />), which releases
      all objects created during the webservice session.

      Whenever a method call of the VirtualBox API returns a COM object, the
      webservice representation of that method will instead return a
      managed object reference, which can then be used to invoke methods
      on that object.
    </desc>

    <method name="getInterfaceName">
      <desc>
        Returns the name of the interface that this managed object represents,
        for example, "IMachine", as a string.
      </desc>
      <param name="return" type="wstring" dir="return"/>
    </method>

    <method name="release">
      <desc>
        Releases this managed object reference and frees the resources that
        were allocated for it in the webservice server process. After calling
        this method, the identifier of the reference can no longer be used.
      </desc>
    </method>

  </interface>

  <!--
  // IWebsessionManager
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IWebsessionManager" extends="$unknown"
     uuid="dea1b4c7-2de3-418a-850d-7868617f7733"
     internal="yes"
     wsmap="global"
     wscpp="hardcoded"
     >
    <desc>
      Websession manager. This provides essential services
      to webservice clients.
    </desc>
    <method name="logon">
      <desc>
        Logs a new client onto the webservice and returns a managed object reference to
        the IVirtualBox instance, which the client can then use as a basis to further
        queries, since all calls to the VirtualBox API are based on the IVirtualBox
        interface, in one way or the other.
      </desc>
      <param name="username" type="wstring" dir="in"/>
      <param name="password" type="wstring" dir="in"/>
      <param name="return" type="IVirtualBox" dir="return"/>
    </method>

    <method name="getSessionObject">
      <desc>
        Returns a managed object reference to the internal ISession object that was created
        for this web service session when the client logged on.

        <see>ISession</see>
      </desc>
      <param name="refIVirtualBox" type="IVirtualBox" dir="in"/>
      <param name="return" type="ISession" dir="return"/>
    </method>

    <method name="logoff">
      <desc>
        Logs off the client who has previously logged on with <link to="IWebsessionManager::logoff" />
        and destroys all resources associated with the session (most importantly, all
        managed objects created in the server while the session was active).
      </desc>
      <param name="refIVirtualBox" type="IVirtualBox" dir="in"/>
    </method>

  </interface>

</if>

  <!--
  // IPerformanceCollector & friends
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IPerformanceMetric" extends="$unknown"
    uuid="2a1a60ae-9345-4019-ad53-d34ba41cbfe9" wsmap="managed"
  >
    <desc>
      The IPerformanceMetric interface represents parameters of the given
      performance metric.
    </desc>

    <attribute name="metricName" type="wstring" readonly="yes">
      <desc>
        Name of the metric.
      </desc>
    </attribute>

    <attribute name="object" type="$unknown" readonly="yes">
      <desc>
        Object this metric belongs to.
      </desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Textual description of the metric.
      </desc>
    </attribute>

    <attribute name="period" type="unsigned long" readonly="yes">
      <desc>
        Time interval between samples, measured in seconds.
      </desc>
    </attribute>

    <attribute name="count" type="unsigned long" readonly="yes">
      <desc>
        Number of recent samples retained by the performance collector for this
        metric.

        When the collected sample count exceeds this number, older samples
        are discarded.
      </desc>
    </attribute>

    <attribute name="unit" type="wstring" readonly="yes">
      <desc>
        Unit of measurement.
      </desc>
    </attribute>

    <attribute name="minimumValue" type="long" readonly="yes">
      <desc>
        Minimum possible value of this metric.
      </desc>
    </attribute>

    <attribute name="maximumValue" type="long" readonly="yes">
      <desc>
        Maximum possible value of this metric.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IPerformanceCollector" extends="$unknown"
    uuid="e22e1acb-ac4a-43bb-a31c-17321659b0c6"
    wsmap="managed"
  >
    <desc>
      The IPerformanceCollector interface represents a service that collects and
      stores performance metrics data.

      Performance metrics are associated with objects like IHost and
      IMachine. Each object has a distinct set of performance metrics.
      The set can be obtained with <link to="IPerformanceCollector::getMetrics"/>.

      Metric data are collected at the specified intervals and are retained
      internally. The interval and the number of samples retained can be set
      with <link to="IPerformanceCollector::setupMetrics" />.

      Metrics are organized hierarchically, each level separated by slash (/).
      General scheme for metric name is
      "Category/Metric[/SubMetric][:aggregation]". For example CPU/Load/User:avg
      metric name stands for: CPU category, Load metric, User submetric, average
      aggregate. An aggregate function is computed over all retained data. Valid
      aggregate functions are:

      <ul>
      <li>avg -- average</li>
      <li>min -- minimum</li>
      <li>max -- maximum</li>
      </ul>

      "Category/Metric" together form base metric name. A base metric is the
      smallest unit for which a sampling interval and the number of retained
      samples can be set. Only base metrics can be enabled and disabled. All
      sub-metrics are collected when their base metric is collected.
      Collected values for any set of sub-metrics can be queried with
      <link to="IPerformanceCollector::queryMetricsData" />. When setting up
      metric parameters, querying metric data, enabling or disabling metrics
      wildcards can be used in metric names to specify a subset of metrics. For
      example, to select all CPU-related metrics use <tt>CPU/*</tt>, all
      averages can be queried using <tt>*:avg</tt> and so on. To query metric
      values without aggregates <tt>*:</tt> can be used.

      The valid names for base metrics are:

      <ul>
      <li>CPU/Load</li>
      <li>CPU/MHz</li>
      <li>RAM/Usage</li>
      </ul>

      The general sequence for collecting and retrieving the metrics is:
      <ul>
        <li>
          Obtain an instance of IPerformanceCollector with
          <link to="IVirtualBox::performanceCollector" />
        </li>
        <li>
          Allocate and populate an array with references to objects the metrics
          will be collected for. Use references to IHost and IMachine objects.
        </li>
        <li>
          Allocate and populate an array with base metric names the data will be
          collected for.
        </li>
        <li>
          Call <link to="IPerformanceCollector::setupMetrics" />. From now on the
          metric data will be collected and stored.
        </li>
        <li>
          Wait for the data to get collected.
        </li>
        <li>
          Allocate and populate an array with references to objects the metric
          values will be queried for. You can re-use the object array used for
          setting base metrics.
        </li>
        <li>
          Allocate and populate an array with metric names the data will be
          collected for. Note that metric names differ from base metric names.
        </li>
        <li>
          Call <link to="IPerformanceCollector::queryMetricsData" />. The data that
          have been collected so far are returned. Note that the values are still
          retained internally and data collection continues.
        </li>
      </ul>

      For an example of usage refer to the following files in VirtualBox SDK:
      <ul>
        <li>
          Java: <tt>bindings/webservice/java/jax-ws/samples/metrictest.java</tt>
        </li>
        <li>
          Python: <tt>bindings/xpcom/python/sample/shellcommon.py</tt>
        </li>
      </ul>
    </desc>

    <attribute name="metricNames" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of unique names of metrics.

        This array represents all metrics supported by the performance
        collector. Individual objects do not necessarily support all of them.
        <link to="IPerformanceCollector::getMetrics"/> can be used to get the
        list of supported metrics for a particular object.
      </desc>
    </attribute>

    <method name="getMetrics">
      <desc>
        Returns parameters of specified metrics for a set of objects.
        <note>
          @c Null metrics array means all metrics. @c Null object array means
          all existing objects.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Currently, only a comma-separated list of metrics
          is supported.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to return metric parameters for.
        </desc>
      </param>
      <param name="metrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of returned metric parameters.
        </desc>
      </param>
    </method>

    <method name="setupMetrics">
      <desc>
        Sets parameters of specified base metrics for a set of objects. Returns
        an array of <link to="IPerformanceMetric" /> describing the metrics have
        been affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or empty
          object array means all existing objects. If metric name array contains
          a single element and object array contains many, the single metric
          name array element is applied to each object array element to form
          metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to setup metric parameters for.
        </desc>
      </param>
      <param name="period" type="unsigned long" dir="in">
        <desc>
          Time interval in seconds between two consecutive samples of performance
          data.
        </desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>
          Number of samples to retain in performance data history. Older samples
          get discarded.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="enableMetrics">
      <desc>
        Turns on collecting specified base metrics. Returns an array of
        <link to="IPerformanceMetric" /> describing the metrics have been
        affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or empty
          object array means all existing objects. If metric name array contains
          a single element and object array contains many, the single metric
          name array element is applied to each object array element to form
          metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to enable metrics for.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="disableMetrics">
      <desc>
        Turns off collecting specified base metrics. Returns an array of
        <link to="IPerformanceMetric" /> describing the metrics have been
        affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or empty
          object array means all existing objects. If metric name array contains
          a single element and object array contains many, the single metric
          name array element is applied to each object array element to form
          metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to disable metrics for.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="queryMetricsData">
      <desc>
        Queries collected metrics data for a set of objects.

        The data itself and related metric information are returned in seven
        parallel and one flattened array of arrays. Elements of
        <tt>returnMetricNames, returnObjects, returnUnits, returnScales,
        returnSequenceNumbers, returnDataIndices and returnDataLengths</tt> with
        the same index describe one set of values corresponding to a single
        metric.

        The <tt>returnData</tt> parameter is a flattened array of arrays. Each
        start and length of a sub-array is indicated by
        <tt>returnDataIndices</tt> and <tt>returnDataLengths</tt>. The first
        value for metric <tt>metricNames[i]</tt> is at
        <tt>returnData[returnIndices[i]]</tt>.

        <note>
          @c Null or empty metric name array means all metrics. @c Null or empty
          object array means all existing objects. If metric name array contains
          a single element and object array contains many, the single metric
          name array element is applied to each object array element to form
          metric/object pairs.
        </note>
        <note>
          Data collection continues behind the scenes after call to @c
          queryMetricsData. The return data can be seen as the snapshot of
          the current state at the time of @c queryMetricsData call. The
          internally kept metric values are not cleared by the call. This makes
          possible querying different subsets of metrics or aggregates with
          subsequent calls. If periodic querying is needed it is highly
          suggested to query the values with @c interval*count period to avoid
          confusion. This way a completely new set of data values will be
          provided by each query.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to query metrics for.
        </desc>
      </param>
      <param name="returnMetricNames" type="wstring" dir="out" safearray="yes">
        <desc>
          Names of metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnObjects" type="$unknown" dir="out" safearray="yes">
        <desc>
          Objects associated with metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnUnits" type="wstring" dir="out" safearray="yes">
         <desc>
           Units of measurement for each returned metric.
         </desc>
       </param>
       <param name="returnScales" type="unsigned long" dir="out" safearray="yes">
         <desc>
           Divisor that should be applied to return values in order to get
           floating point values. For example:
           <tt>(double)returnData[returnDataIndices[0]+i] / returnScales[0]</tt>
           will retrieve the floating point value of i-th sample of the first
           metric.
         </desc>
       </param>
       <param name="returnSequenceNumbers" type="unsigned long" dir="out" safearray="yes">
         <desc>
           Sequence numbers of the first elements of value sequences of particular metrics
           returned in @c returnData. For aggregate metrics it is the sequence number of
           the sample the aggregate started calculation from.
         </desc>
       </param>
      <param name="returnDataIndices" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Indices of the first elements of value sequences of particular metrics
          returned in @c returnData.
        </desc>
      </param>
      <param name="returnDataLengths" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Lengths of value sequences of particular metrics.
        </desc>
      </param>
      <param name="returnData" type="long" dir="return" safearray="yes">
        <desc>
          Flattened array of all metric data containing sequences of values for
          each metric.
        </desc>
      </param>
    </method>

  </interface>

  <module name="VBoxSVC" context="LocalServer">
    <class name="VirtualBox" uuid="B1A7A4F2-47B9-4A1E-82B2-07CCD5323C3F"
           namespace="virtualbox.org">
      <interface name="IVirtualBox" default="yes"/>
    </class>
  </module>

  <module name="VBoxC" context="InprocServer" threadingModel="Free">
    <class name="Session" uuid="3C02F46D-C9D2-4f11-A384-53F0CF917214"
           namespace="virtualbox.org">
      <interface name="ISession" default="yes"/>
    </class>
  </module>

</library>

</idl>

<!-- vim: set shiftwidth=2 tabstop=2 expandtab: -->
