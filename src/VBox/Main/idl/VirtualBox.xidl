<?xml version="1.0" ?>

<!--
 * Master declaration for VirtualBox's public COM/XPCOM API.
 * From this document, the build system generates several files
 * that are then used during the build process:
 *
 *   -  out/<platform>/bin/sdk/idl/VirtualBox[_XPCOM].idl, a
 *      pseudo-IDL file that represents the interfaces in IDL;
 *
 *   -  out/<platform>/bin/sdk/include/VirtualBox[_XPCOM].h, which
 *      gets included from the include/VBox/com/VirtualBox.h
 *      wrapper, to allow clients to access the API;
 *
 *   -  also, another intermediate file that is then used to
 *      produce the official Doxygen documentation of the API.
 *
 * Copyright (C) 2006 InnoTek Systemberatung GmbH
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation,
 * in version 2 as it comes in the "COPYING" file of the VirtualBox OSE
 * distribution. VirtualBox OSE is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY of any kind.
 *
 * If you received this file as part of a commercial VirtualBox
 * distribution, then only the terms of your commercial VirtualBox
 * license agreement apply instead of the previous paragraph.
-->

<idl>

<if target="midl">
    <cpp line="enum {"/>
    <cpp line="    kTypeLibraryMajorVersion = 1,"/>
    <cpp line="    kTypeLibraryMinorVersion = 0"/>
    <cpp line="};"/>
</if>

<if target="xpidl">
    <!-- NS_IMPL_THREADSAFE_ISUPPORTSxx_CI macros are placed here, for convenience -->
    <cpp>
// currenty, nsISupportsImpl.h lacks the below-like macros
#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_CI
#define NS_IMPL_THREADSAFE_ISUPPORTS1_CI(_class, _interface)                  \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_QUERY_INTERFACE1_CI(_class, _interface)                             \
  NS_IMPL_CI_INTERFACE_GETTER1(_class, _interface)
#endif
#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_CI
#define NS_IMPL_THREADSAFE_ISUPPORTS2_CI(_class, _i1, _i2)                    \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_QUERY_INTERFACE2_CI(_class, _i1, _i2)                               \
  NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif
    </cpp>
</if>

<module
    name="VirtualBox"
    uuid="46137EEC-703B-4fe5-AFD4-7C9BBBBA0259"
    version="1.3"
    desc="InnoTek VirtualBox Type Library"
    supportsErrorInfo="yes"
>

    <!--
    // all common enums
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="TriStateBool"
        uuid="523ff64d-842a-4b1a-80e7-c311b028cb3a"
    >
        <desc>
            This represents a boolean variable having a third state, default.
        </desc>

        <const name="False"   value="0"/>
        <const name="True"    value="1"/>
        <const name="Default" value="2"/>
    </enum>

    <enum
        name="MachineState"
        uuid="b8bb15f7-4fa2-4e84-87a8-b4677dd87deb"
    >
        <desc>
            Virtual machine execution state. This enumeration represents possible
            values of the <link to="IMachine::state"/> attribute.
        </desc>

        <const name="InvalidMachineState"   value="0"/>
        <const name="PoweredOff"            value="1">
            <desc>
                The machine is not running.
            </desc>
        </const>
        <const name="Saved"                 value="2">
            <desc>
                The machine is not currently running, but the execution state
                of the machine has been saved to an external file when it
                was running.
                <note>
                    No any machine settings can be altered when the machine
                    is in this state.
                </note>
            </desc>
        </const>
        <const name="Aborted"               value="3">
            <desc>
                A process that run the machine has abnormally terminated.
                Other than that, this value is equivalent to #PoweredOff.
            </desc>
        </const>
        <const name="Running"               value="4">
            <desc>
                The machine is currently being executed.
                <note>
                    This value can be used in comparison expressions:
                    all state values below it describe a virtual machine that is
                    not currently being executed (i.e., it is completely out of
                    action).
                </note>
            </desc>
        </const>
        <const name="Paused"                value="5">
            <desc>
                The execution of the machine has been paused.
                <note>
                    This value can be used in comparison expressions:
                    all state values above it represent unstable states of the
                    virtual machine. No any settings can be altered when the
                    VM is in one of the unstable sates.
                </note>
            </desc>
        </const>
        <const name="Starting"              value="6">
            <desc>
                The machine is being started after
                <link to="IConsole::powerUp">powering it on</link> from a
                zero execution state.
            </desc>
        </const>
        <const name="Stopping"              value="7">
            <desc>
                The machine is being normally stopped
                (after explicitly <link to="IConsole::powerDown">powering it off</link>,
                or after the guest OS has initiated a shutdown sequence).
            </desc>
        </const>
        <const name="Saving"                value="8">
            <desc>
                The machine is saving its execution state to a file as a
                result of calling <link to="IConsole::saveState"/> or an online
                snapshot of the machine is being taken using
                <link to="IConsole::takeSnapshot"/>.
            </desc>
        </const>
        <const name="Restoring"             value="9">
            <desc>
                The execution state of the machine is being restored from a file
                after <link to="IConsole::powerUp">powering it on</link> from
                a saved execution state.
            </desc>
        </const>
        <const name="Discarding"            value="10">
            <desc>
                A snapshot of the machine is being discarded after calling
                <link to="IConsole::discardSnapshot"/> or its current state is
                being discarded after <link to="IConsole::discardCurrentState"/>.
            </desc>
        </const>
    </enum>

    <enum
        name="SessionState"
        uuid="CF2700C0-EA4B-47ae-9725-7810114B94D8"
    >
        <desc>
            Session state. This enumeration represents possible values of
            <link to="IMachine::sessionState"/> and <link to="ISession::state"/>
            attributes. Idividual value descriptions contain the appropriate
            meaning for every case.
        </desc>

        <const name="InvalidSessionState"   value="0"/>
        <const name="SessionClosed"         value="1">
            <desc>
                The machine has no open sessions (<link to="IMachine::sessionState"/>);
                the session is closed (<link to="ISession::state"/>)
            </desc>
        </const>
        <const name="SessionOpen"           value="2">
            <desc>
                The machine has an open direct session (<link to="IMachine::sessionState"/>);
                the session is open (<link to="ISession::state"/>)
            </desc>
        </const>
        <const name="SessionSpawning"       value="3">
            <desc>
                A new (direct) session is being opened for the machine
                as a result of <link to="IVirtualBox::openRemoteSession()"/>
                call (<link to="IMachine::sessionState"/>);
                the session is currently being opened
                as a result of <link to="IVirtualBox::openRemoteSession()"/>
                call (<link to="ISession::state"/>)
            </desc>
        </const>
        <const name="SessionClosing"       value="4">
            <desc>
                The direct session is being closed (<link to="IMachine::sessionState"/>);
                the session is being closed (<link to="ISession::state"/>)
            </desc>
        </const>
    </enum>

    <enum
        name="SessionType"
        uuid="A13C02CB-0C2C-421E-8317-AC0E8AAA153A"
    >
        <desc>
            Session type. This enumeration represents possible values of the
            <link to="ISession::type"/> attribute.
        </desc>

        <const name="InvalidSessionType"    value="0"/>
        <const name="DirectSession"         value="1">
            <desc>
                Direct session
                (opened by <link to="IVirtualBox::openSession()"/>)
            </desc>
        </const>
        <const name="RemoteSession"         value="2">
            <desc>
                Remote session
                (opened by <link to="IVirtualBox::openRemoteSession()"/>)
            </desc>
        </const>
        <const name="ExistingSession"       value="3">
            <desc>
                Existing session
                (opened by <link to="IVirtualBox::openExistingSession()"/>)
            </desc>
        </const>
    </enum>

    <enum
        name="DeviceType"
        uuid="8B7F8ADE-E8F7-42a4-9661-9F5092C4DB4C"
    >
        <desc>
            Device type.
        </desc>
        <const name="NoDevice"          value="0">
            <desc>
                No Device. This value is not used by
                <link to="IConsole::getDeviceActivity"/>
            </desc>
        </const>
        <const name="FloppyDevice"      value="1">
            <desc>Floppy device.</desc>
        </const>
        <const name="DVDDevice"         value="2">
            <desc>CD/DVD-ROM device.</desc>
        </const>
        <const name="HardDiskDevice"    value="3">
            <desc>Hard disk device.</desc>
        </const>
        <const name="NetworkDevice"     value="4">
            <desc>Network device.</desc>
        </const>
        <const name="USBDevice"         value="5">
            <desc>USB device.</desc>
        </const>
    </enum>

    <enum
        name="DeviceActivity"
        uuid="6FC8AEAA-130A-4eb5-8954-3F921422D707"
    >
        <const name="InvalidActivity"   value="0"/>
        <const name="DeviceIdle"        value="1"/>
        <const name="DeviceReading"     value="2"/>
        <const name="DeviceWriting"     value="3"/>
    </enum>

    <enum
        name="ResourceUsage"
        uuid="FC56E4B6-B195-48e2-A5E1-A667B0D9F809"
    >
        <desc>
            Usage type constants for
            <link to="IVirtualBox::getDVDImageUsage"/> and
            <link to="IVirtualBox::getFloppyImageUsage"/>.
        </desc>
        <const name="InvalidUsage"      value="0"/>
        <const name="PermanentUsage"    value="1">
            <desc>
                Scopes the VMs that use the resource permanently
                (the information about this usage is stored in the VM
                settings file).
            </desc>
        </const>
        <const name="TemporaryUsage"    value="2">
            <desc>
                Scopes the VMs that are temporarily using the resource
                (the information about the usage is not yet saved in the VM
                settings file). Temporary usage can take place only in the
                context of an open session.
            </desc>
        </const>
        <const name="AllUsage"          value="3">
            <desc>
                Combines PermanentUsage and TemporaryUsage.
            </desc>
        </const>
    </enum>

    <enum
        name="DiskControllerType"
        uuid="1115b810-2ee7-4ebd-8b39-92e98c9a2b48"
    >
        <const name="InvalidController"  value="0"/>
        <const name="IDE0Controller"     value="1"/>
        <const name="IDE1Controller"     value="2"/>
    </enum>

    <enum
        name="ClipboardMode"
        uuid="33364716-4008-4701-8f14-be0fa3d62950"
    >
        <const name="ClipDisabled"         value="0"/>
        <const name="ClipHostToGuest"      value="1"/>
        <const name="ClipGuestToHost"      value="2"/>
        <const name="ClipBidirectional"    value="3"/>
    </enum>

    <!--
    // IVirtualBoxErrorInfo
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IVirtualBoxErrorInfo" extends="$errorinfo"
        uuid="37EDE76D-6E16-4CE4-9D48-2C5A87AFFEA2"
        supportsErrorInfo="no"
        wsmap="struct"
    >
        <desc>
            The IVirtualBoxErrorInfo interface represents extended error information
            that can be set by components after unsuccessful method invocation and
            returned to the client in addition to the result code.

            In MS COM, this interface extends the IErrorInfo interface,
            in XPCOM, it extends the nsIException interface. In both cases,
            it provides a set of common attributes to retrieve error information.
        </desc>

        <attribute name="resultCode" type="result" readonly="yes">
            <desc>
                Result code of the error.
                Usually, it will be the same as the result code returned
                by the method that provided this error information, but not
                always. For example, on Win32, CoCreateInstance() will most
                likely return E_NOINTERFACE upon unsuccessful component
                instantiation attempt, but not the value the component factory
                returned.
                <note>
                    In MS COM, there is no equivalent.
                    In XPCOM, it is the same as to nsIException::result.
                </note>
            </desc>
        </attribute>

        <attribute name="interfaceID" type="uuid" readonly="yes">
            <desc>
                UUID of the interface that defined the error.
                <note>
                    In MS COM, it is the same as  to IErrorInfo::GetGUID.
                    In XPCOM, there is no equivalent.
                </note>
            </desc>
        </attribute>

        <attribute name="component" type="wstring" readonly="yes">
            <desc>
                Name of the component that generated the error.
                <note>
                    In MS COM, it is the same as to IErrorInfo::GetSource.
                    In XPCOM, there is no eqiuvalent.
                </note>
            </desc>
        </attribute>

        <attribute name="text" type="wstring" readonly="yes">
            <desc>
                Text description of the error.
                <note>
                    In MS COM, it is the same as IErrorInfo::GetDescription.
                    In XPCOM, it is the same as to nsIException::message.
                </note>
            </desc>
        </attribute>

    </interface>


    <!--
    // IVirtualBox
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IVirtualBoxCallback" extends="$unknown"
        uuid="1293842f-0380-47cf-80b5-e4f821861b26"
        wsmap="suppress"
    >
        <method name="onMachineStateChange">
            <desc>
                The execution state of the given machine has changed.
                <see>IMachine::state</see>
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
            <param name="state" type="MachineState" dir="in">
                <desc>New execution state.</desc>
            </param>
        </method>

        <method name="onMachineDataChange">
            <desc>
                Any of the settings of the given machine has changed.
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
        </method>

        <method name="onExtraDataCanChange">
            <desc>
                Notification when someone tries to change extra data for
                either the given machine or (if null) global extra data.
                This gives the chance to veto against changes.
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>
                    ID of the machine this event relates to.
                    Nul for global extra data change requests.
                </desc>
            </param>
            <param name="key" type="wstring" dir="in">
                <desc>
                    Extra data key for the attempted write.
                </desc>
            </param>
            <param name="value" type="wstring" dir="in">
                <desc>
                    Extra data value for the given key.
                </desc>
            </param>
            <param name="allowChange" type="boolean" dir="return">
                <desc>
                    Flag to indicate whether the callee agrees (true)
                    or vetoes against the change (false).
                </desc>
            </param>
        </method>

        <method name="onExtraDataChange">
            <desc>
                Notification when machine specific or global extra data
                has changed.
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>
                    ID of the machine this event relates to.
                    Null for global extra data changes.
                </desc>
            </param>
            <param name="key" type="wstring" dir="in">
                <desc>
                    Extra data key that has changed.
                </desc>
            </param>
            <param name="value" type="wstring" dir="in">
                <desc>
                    Extra data value for the given key.
                </desc>
            </param>
        </method>

        <method name="onMediaRegistered">
            <desc>
                The given media was registered or unregistered
                within this VirtualBox installation.

                The @a mediaType parameter describes what type of
                media the specified @a mediaId refers to. Possible
                values are:

                - <link to="HardDiskDevice"/>: the media is a hard disk
                  that, if registered, can be obtained using the
                  <link to="IVirtualBox::getHardDisk"/> call.
                - <link to="DVDDevice"/>: the media is a CD/DVD image
                  that, if registered, can be obtained using the
                  <link to="IVirtualBox::getDVDImage"/> call.
                - <link to="FloppyDevice"/>: the media is a Floppy image
                  that, if registered, can be obtained using the
                  <link to="IVirtualBox::getFloppyImage"/> call.

                Note that if this is a deregistration notification,
                there is no way to access the object representing the
                unregistered media. It is supposed that the
                application will do required cleanup based on the @a
                mediaId value.
            </desc>
            <param name="mediaId" type="uuid" dir="in">
                <desc>ID of the media this event relates to.</desc>
            </param>
            <param name="mediaType" type="DeviceType" dir="in">
                <desc>Type of the media this event relates to.</desc>
            </param>
            <param name="registered" type="boolean" dir="in">
                <desc>
                    If true, the media was registered, otherwise it was
                    unregistered.
                </desc>
            </param>
        </method>

        <method name="onMachineRegistered">
            <desc>
                The given machine was registered or unregistered
                within this VirtualBox installation.
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
            <param name="registered" type="boolean" dir="in">
                <desc>
                    If true, the machine was registered, otherwise it was
                    unregistered.
                </desc>
            </param>
        </method>

        <method name="onSessionStateChange">
            <desc>
                The state of the session for the given machine was changed.
                <see>IMachine::sessionState</see>
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
            <param name="state" type="SessionState" dir="in">
                <desc>New session state.</desc>
            </param>
        </method>

        <method name="onSnapshotTaken">
            <desc>
                A new snapshot of the machine has been taken.
                <see>ISnapshot</see>
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
            <param name="snapshotId" type="uuid" dir="in">
                <desc>ID of the new snapshot.</desc>
            </param>
        </method>

        <method name="onSnapshotDiscarded">
            <desc>
                Snapshot of the given machine has been discarded.

                <note>
                    This notification is delivered <b>after</b> the snapshot
                    object has been uninitialized on the server (so that any
                    attempt to call its methods will return an error).
                </note>

                <see>ISnapshot</see>
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
            <param name="snapshotId" type="uuid" dir="in">
                <desc>
                    ID of the discarded snapshot. <tt>null</tt> means the
                    current machine state has been discarded (restored from
                    the current snapshot).
                </desc>
            </param>
        </method>

        <method name="onSnapshotChange">
            <desc>
                Snapshot properties (name and/or description) have been changed.
                <see>ISnapshot</see>
            </desc>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the machine this event relates to.</desc>
            </param>
            <param name="snapshotId" type="uuid" dir="in">
                <desc>ID of the changed snapshot.</desc>
            </param>
        </method>

    </interface>

    <interface
        name="IVirtualBox" extends="$dispatched"
        uuid="ce54ff3d-0e46-41ae-a0de-202ed0c3c668"
        wsmap="global"
    >
      <desc> The main interface exposed by the product that provides virtual
      machine management.

      An instance of IVirtualBox is required for the product to do anything
      useful. Even though the interface does not expose this, internally, IVirtualBox
      is implemented as a singleton and actually lives in the process of the
      VirtualBox server (VBoxSVC.exe). This makes sure that IVirtualBox can
      track the state of all virtual machines on a particular host, regardless
      of which frontend started them.

      To enumerate all the virtual machines on the host, use the <link to="IVirtualBox::machines" />
      attribute.</desc>

        <attribute name="version" type="wstring" readonly="yes">
            <desc>
                A string representing the version number of the product. The
                format is 3 integer numbers divided by dots (e.g. 1.0.1). The
                last number represents the build number and will frequently change.
            </desc>
        </attribute>

        <attribute name="homeFolder" type="wstring" readonly="yes">
            <desc>
                Full path to the directory where the global settings file,
                <tt>VirtualBox.xml</tt>, is stored.

                In this version of VirtualBox, the value of this property is
                always <tt>&lt;user_dir&gt;/.VirtualBox</tt> (where
                <tt>&lt;user_dir&gt;</tt> is the path to the user directory,
                as determined by the host OS), and cannot be changed.

                This path is also used as the base to resolve relative paths in
                places where relative paths are allowed (unless otherwise
                expressly indicated).
            </desc>
        </attribute>

        <attribute name="host" type="IHost" readonly="yes">
            <desc>Associated host object.</desc>
        </attribute>

        <attribute name="systemProperties" type="ISystemProperties" readonly="yes">
            <desc>Associated system information object.</desc>
        </attribute>

        <attribute name="machines" type="IMachineCollection" readonly="yes"/>

        <attribute name="hardDisks" type="IHardDiskCollection" readonly="yes">
            <desc>
                A collection of hard disk objects registered within this
                VirtualBox instance.
                This collection contains only "top-level" (basic or independent)
                hard disk images, but not differencing ones. All differencing
                images of the given top-level image (i.e. all its children) can
                be enumerated using <link to="IHardDisk::children"/>.
            </desc>
        </attribute>

        <attribute name="DVDImages" type="IDVDImageCollection" readonly="yes"/>

        <attribute name="FloppyImages" type="IFloppyImageCollection" readonly="yes"/>

        <attribute name="progressOperations" type="IProgressCollection" readonly="yes"/>

        <attribute name="guestOSTypes" type="IGuestOSTypeCollection" readonly="yes"/>

        <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
            <desc>
                Collection of globally shared folders. These folders
                are shared automatically upon VirtualBox server startup and
                available only to every virtual machine.

                New folders to share are added to the collection using
                <link to="#createSharedFolder"/>. An existing shared folder can
                be removed using <link to="#removeSharedFolder"/>.
            </desc>
        </attribute>

        <method name="createMachine">
            <desc>
                Creates a new virtual machine.

                Every machine has a <i>settings file</i> that is used to store
                the machine configuration. This file is stored in the directory
                called <i>machine settings subfolder</i>. Both the subfolder
                and the settings file have the same name that corresponds to the
                name of the virtual machine. You can specify where
                to create the machine settings subfolder using the @a
                baseFolder argument. The base folder can be absolute (full path)
                or relative to the <link to="IVirtualBox::homeFolder">
                VirtualBox home directory</link>.

                If a null or empty string is given as the base folder (which is
                recommended), the <link to="ISystemProperties::defaultMachineFolder">
                default machine settings folder</link> will be used as the base
                folder to create the machine settings subfolder and file. In
                any case, the full path to the settings file will look like:
                <pre>
    &lt;base_folder&gt;/&lt;machine_name&gt;/&lt;machine_name&gt;.xml</pre>

                Note that the configuration of the newly created machine is not
                saved to disk (and therefore no settings subfolder and file are
                created) until <link to="IMachine::saveSettings()"/> is called.

                You should also specify a valid name for the machine.
                See the <link to="IMachine::name"/> property
                description for more details about the machine name.

                The created machine remains
                unregistered until you call <link to="#registerMachine()"/>.

                <note>
                    There is no way to change the name of the settings file or
                    subfolder of the created machine directly.
                </note>
            </desc>
            <param name="baseFolder" type="wstring" dir="in">
                <desc>
                    Name of the folder where to create the machine settings
                    subfolder containing the settings file.
                </desc>
            </param>
            <param name="name" type="wstring" dir="in">
                <desc>Machine name.</desc>
            </param>
            <param name="machine" type="IMachine" dir="return">
                <desc>Created machine object.</desc>
            </param>
        </method>

        <method name="createLegacyMachine">
            <desc>
                Creates a new virtual machine in "legacy" mode, using the
                specified settings file to store machine settings.

                As opposed to machines created by <link to="#createMachine()"/>,
                the settings file of the machine created in "legacy" mode
                is not authomatically renamed when the machine name is
                changed -- it will always remain the same as specified in this
                method call.

                The specified settings file name can be absolute
                (full path) or relative to the <link to="IVirtualBox::homeFolder">
                VirtualBox home directory</link>. If the file name doesn't
                contain an extension, the default extension (.xml) will be
                appended.

                Note that the configuration of the newly created machine is not
                saved to disk (and therefore no settings file is created)
                until <link to="IMachine::saveSettings()"/> is called. If the
                specified settings file already exists,
                <link to="IMachine::saveSettings()"/> will return an error.

                You should also specify a valid name for the machine.
                See the <link to="IMachine::name"/> property
                description for more details about the machine name.

                The created machine remains
                unregistered until you call <link to="#registerMachine()"/>.

                @deprecated This method may be removed later. It is better
                to use <link to="IVirtualBox::createMachine()"/>.

                <note>
                    There is no way to change the name of the settings file
                    of the created machine.
                </note>
            </desc>
            <param name="settingsFile" type="wstring" dir="in">
                <desc>
                    Name of the file where to store machine settings.
                </desc>
            </param>
            <param name="name" type="wstring" dir="in">
                <desc>Machine name.</desc>
            </param>
            <param name="machine" type="IMachine" dir="return">
                <desc>Created machine object.</desc>
            </param>
        </method>

        <method name="openMachine">
            <desc>
                Opens a virtual machine from the existing settings file.
                The opened machine remains unregistered until you call
                <link to="#registerMachine()"/>.

                The specified settings file name can be absolute
                (full path) or relative to the <link to="IVirtualBox::homeFolder">
                VirtualBox home directory</link>. This file must exist
                and must be a valid machine settings file whose contents
                will be used to construct the machine object.

                @deprecated Will be removed soon.
            </desc>
            <param name="settingsFile" type="wstring" dir="in">
                <desc>
                    Name of the machine settings file.
                </desc>
            </param>
            <param name="machine" type="IMachine" dir="return">
                <desc>Opened machine object.</desc>
            </param>
            <note>
                <link to="IMachine::settingsModified"/> will return
                false for the created machine, until any of machine settigs
                are changed.
            </note>
        </method>

        <method name="registerMachine">
            <desc>

                Registers the machine previously created using <link
                to="#createMachine()"/> or opened using <link to="#openMachine()"/>
                within this VirtualBox installation. After successful method
                invocation, the <link
                to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
                to all registered callbacks.

                <note>This method implicitly calls <link
                to="IMachine::saveSettings"/> to save all current machine
                settings before registering it.</note>

            </desc>
            <param name="machine" type="IMachine" dir="in"/>
        </method>

        <method name="getMachine">
            <param name="id" type="uuid" dir="in"/>
            <param name="machine" type="IMachine" dir="return"/>
        </method>

        <method name="findMachine">
            <param name="name" type="wstring" dir="in"/>
            <param name="machine" type="IMachine" dir="return"/>
        </method>

        <method name="unregisterMachine">
            <desc>

                Unregisters the machine previously registered using <link
                to="#registerMachine"/>. After successful method invocation, the
                <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is
                sent to all registered callbacks.

                <note> The specified machine must not be in the Saved state,
                have an open (or a spawning) direct session associated with it,
                have snapshots or have hard disks attached.</note>

                <note>This method implicitly calls <link
                to="IMachine::saveSettings"/> to save all current machine
                settings before unregistering it.</note>

                <note>If the given machine is inaccessible (see
                <link to="IMachine::accessible"/>), it will be unregistered
                and fully uninitialized right afterwards. As a result, the
                returned machine object will be unusable and an attempt to call
                <b>any</b> method will return the "Object not ready" error.
                </note>

            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the machine to unregister.</desc>
            </param>
            <param name="machine" type="IMachine" dir="return">
                <desc>Unregistered machine object.</desc>
            </param>
        </method>

        <method name="createHardDisk">
            <desc>

                Creates a new unregistered hard disk that will use the given
                storage type.

                Most properties of the created hard disk object are
                uninitialized. Valid values must be assigned to them (and
                probalby some actions performed) to make the actual usage of
                this hard disk (<link to="#registerHardDisk()">register</link>,
                attach to a virtual machine, etc.). See the description of <link
                to="IHardDisk"/> and descriptions of storage type specific
                interfaces for more information.

                <note>For hard disks using the <link
                to="HardDiskStorageType::VirtualDiskImage">VirtualDiskImage</link>
                storage type, an image file is not actually created until you
                call <link to="IVirtualDiskImage::createDynamicImage()"/> or
                <link to="IVirtualDiskImage::createFixedImage()"/>.</note>

            </desc>

            <param name="storageType" type="HardDiskStorageType" dir="in">
                <desc>Storage type of the hard disk image to create.</desc>
            </param>
            <param name="hardDisk" type="IHardDisk" dir="return">
                <desc>Created hard disk object of the given storage type.</desc>
            </param>

        </method>

        <method name="openHardDisk">
            <desc>

                Opens a hard disk from an existing location.

                This method tries to guess the
                <link to="HardDiskStorageType">hard disk storage
                type</link>
                from the format of the location string and from the
                contens of the resource the location points
                to. Currently, a <i>file path</i> is the only supported
                format for the location string which must point to
                either a VDI file or to a VMDK file. On success,
                an IHardDisk object will be returned that also
                implements the corresponding interface (IVirtualDiskImage
                or IVMDKImage, respectively). The <link
                to="IHardDisk::storageType"/> property may also be
                used to determine the storage type of the returned
                object (instead of trying to query one of these interfaces).

                <note>The specified file path can be absolute (full path) or
                relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
                home directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to the image
                file.</note>

                The opened hard disk remains unregistered
                until <link to="#registerHardDisk()"/> is called.

            </desc>

            <param name="location" type="wstring" dir="in">
                <desc>
                    Location of the resource that contains a valid hard disk.
                </desc>
            </param>
            <param name="hardDisk" type="IHardDisk" dir="return">
                <desc>Opened hard disk object.</desc>
            </param>
        </method>

        <method name="openVirtualDiskImage">
            <desc>

                Opens a hard disk from an existing Virtual Disk Image file.
                The opened hard disk remains unregistered
                until <link to="#registerHardDisk()"/> is called.

                @deprecated Use <link to="#openHardDisk()"/> instead.

                <note>Opening differencing images is not supported.</note>

                <note>The specified file path can be absolute (full path) or
                relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
                home directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to the image
                file.</note>

            </desc>

            <param name="filePath" type="wstring" dir="in">
                <desc>
                    Name of the file that contains a valid Virtual Disk Image.
                </desc>
            </param>
            <param name="image" type="IVirtualDiskImage" dir="return">
                <desc>Opened hard disk object.</desc>
            </param>
        </method>

        <method name="registerHardDisk">
            <desc>

                Registers the given hard disk within this VirtualBox
                installation. The hard disk must not be registered, must be
                <link to="IHardDisk::accessible"/> and must not be a
                differencing hard disk, otherwise the registration will fail.

            </desc>
            <param name="hardDisk" type="IHardDisk" dir="in">
                <desc>Hard disk object to register.</desc>
            </param>
        </method>

        <method name="getHardDisk" const="yes">
            <desc>
                Returns the registered hard disk with the given UUID.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the hard disk to look for.</desc>
            </param>
            <param name="hardDisk" type="IHardDisk" dir="return">
                <desc>Found hard disk object.</desc>
            </param>
        </method>

        <method name="findHardDisk">
            <desc>

                Returns a registered hard disk that uses the given location to
                store data. The search is done by comparing the
                value of the @a location argument to the
                <link to="IHardDisk::location"/> attribute of each registered
                hard disk.

                For locations repesented by file paths (such as VDI and VMDK
                images), the specified location can be either an absolute file
                path or a path relative to
                the <link to="IVirtualBox::homeFolder"> VirtualBox home
                directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to construct
                the absolute image file name to search for. Note that on host
                systems with case sensitive filesystems, a case sensitive
                comparison is performed, otherwise the case of symbols in the
                file path is ignored.

            </desc>
            <param name="location" type="wstring" dir="in">
                <desc>Hard disk location specification to search for.</desc>
            </param>
            <param name="hardDisk" type="IHardDisk" dir="return">
                <desc>Found hard disk object.</desc>
            </param>
        </method>

        <method name="findVirtualDiskImage">
            <desc>

                Returns a registered hard disk that uses the given image file.

                @deprecated Use <link to="#findHardDisk()"/> instead.

                <note>The specified file path can be absolute (full path) or
                relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
                home directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to the image
                file.</note>

                <note>On host systems with case sensitive filesystems, a case
                sensitive comparison is performed, otherwise the case of symbols
                in the file path is ignored.</note>

            </desc>
            <param name="filePath" type="wstring" dir="in">
                <desc>Virtual Disk Image file path to look for.</desc>
            </param>
            <param name="image" type="IVirtualDiskImage" dir="return">
                <desc>Found hard disk object.</desc>
            </param>
        </method>

        <method name="unregisterHardDisk">
            <desc>
                Unregisters a hard disk previously registered using
                <link to="#registerHardDisk()"/>.
                <note>
                    The specified hard disk must not be attached to any of
                    the existing virtual machines and must not have children
                    (differencing) hard disks.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the hard disk to unregister.</desc>
            </param>
            <param name="hardDisk" type="IHardDisk" dir="return">
                <desc>Unregistered hard disk object.</desc>
            </param>
        </method>

        <method name="openDVDImage">
            <desc>
                Opens the CD/DVD image contained in the specified file of
                the supported format and assigns it the given UUID. The opened
                image remains unregistered
                until <link to="#registerDVDImage()"/> is called.
            </desc>
            <param name="filePath" type="wstring" dir="in">
                <desc>
                    Full name of the file that contains a valid
                    CD/DVD image. Currently, only ISO images are supported.
                    <note>
                        The specified file name can be absolute or relative
                        to the <link to="IVirtualBox::homeFolder">
                        VirtualBox home directory</link>.
                    </note>
                </desc>
            </param>
            <param name="id" type="uuid" dir="in">
                <desc>
                    UUID to assign to the given image file within this
                    VirtualBox installation. If an empty (null) UUID is
                    specified, the system will randomly generate an UUID.
                </desc>
            </param>
            <param name="image" type="IDVDImage" dir="return">
                <desc>Opened CD/DVD image object.</desc>
            </param>
        </method>

        <method name="registerDVDImage">
            <desc>
                Registers a CD/DVD image within this VirtualBox
                installation. The image must not be registered and must not
                be associated with the same image file as any of the already
                registered images, otherwise the registration will fail.
            </desc>
            <param name="image" type="IDVDImage" dir="in">
                <desc>CD/DVD image object to register.</desc>
            </param>
        </method>

        <method name="getDVDImage">
            <desc>
                Returns a registered CD/DVD image with the given UUID.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the image to look for.</desc>
            </param>
            <param name="image" type="IDVDImage" dir="return">
                <desc>Found CD/DVD image object.</desc>
            </param>
        </method>

        <method name="findDVDImage">
            <desc>
                Returns a registered CD/DVD image with the given image file.
                <note>
                    On host systems with case sensitive filesystems, a case
                    sensitive comparison is performed, otherwise the case of
                    symbols in the file path is ignored.
                </note>
            </desc>
            <param name="filePath" type="wstring" dir="in">
                <desc>CD/DVD image file path to look for.</desc>
            </param>
            <param name="image" type="IDVDImage" dir="return">
                <desc>Found CD/DVD image object.</desc>
            </param>
        </method>

        <method name="getDVDImageUsage">
            <desc>
                Returns the list of of UUIDs of all virtual machines that use
                the given CD/DVD image.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the image to get the usage information for.</desc>
            </param>
            <param name="usage" type="ResourceUsage" dir="in">
                <desc>Type of the usage (permanent, temporary or all).</desc>
            </param>
            <param name="machineIDs" type="wstring" dir="return">
                <desc>
                    List of UUIDs of all machines that use the given image
                    in the way specified by the usage parameter.
                    The list is returned as a string containing UUIDs separated
                    by spaces. A null string means that the image is not used.
                    <note>
                        When the usage type is <link to="ResourceUsage::AllUsage"/>
                        and the image is used by the VM both permanently
                        and temporarily, the VM's UUID will be present only
                        once in the list.
                    </note>
                </desc>
            </param>
        </method>

        <method name="unregisterDVDImage">
            <desc>
                Unregisters the CD/DVD image previously registered using
                <link to="#registerDVDImage()"/>.
                <note>
                    The specified image must not be mounted to any of
                    the existing virtual machines.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the CD/DVD image to unregister.</desc>
            </param>
            <param name="image" type="IDVDImage" dir="return">
                <desc>Unregistered image object.</desc>
            </param>
        </method>

        <method name="openFloppyImage">
            <desc>
                Opens a floppy image contained in the specified file of
                the supported format and assigns it the given UUID. The opened
                image remains unregistered
                until <link to="#registerFloppyImage()"/> is called.
            </desc>
            <param name="filePath" type="wstring" dir="in">
                <desc>
                    Full name of the file that contains a valid
                    floppy image.
                    <note>
                        The specified file name can be absolute or relative
                        to the <link to="IVirtualBox::homeFolder">
                        VirtualBox home directory</link>.
                    </note>
                </desc>
            </param>
            <param name="id" type="uuid" dir="in">
                <desc>
                    UUID to assign to the given image file within this
                    VirtualBox installation. If an empty (null) UUID is
                    specified, the system will randomly generate an UUID.
                </desc>
            </param>
            <param name="image" type="IFloppyImage" dir="return">
                <desc>Opened CD/DVD image object.</desc>
            </param>
        </method>

        <method name="registerFloppyImage">
            <desc>
                Registers a floppy image within this VirtualBox
                installation. The image must not be registered and must not
                be associated with the same image file as any of the already
                registered images, otherwise the registration will fail.
            </desc>
            <param name="image" type="IFloppyImage" dir="in">
                <desc>Floppy image object to register.</desc>
            </param>
        </method>

        <method name="getFloppyImage">
            <desc>
                Returns a registered floppy image with the given UUID.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the image to look for.</desc>
            </param>
            <param name="image" type="IFloppyImage" dir="return">
                <desc>Found floppy image object.</desc>
            </param>
        </method>

        <method name="findFloppyImage">
            <desc>
                Returns a registered floppy image with the given image file.
                <note>
                    On host systems with case sensitive filesystems, a case
                    sensitive comparison is performed, otherwise the case of
                    symbols in the file path is ignored.
                </note>
            </desc>
            <param name="filePath" type="wstring" dir="in">
                <desc>Floppy image file path to look for.</desc>
            </param>
            <param name="image" type="IFloppyImage" dir="return">
                <desc>Found floppy image object.</desc>
            </param>
        </method>

        <method name="getFloppyImageUsage">
            <desc>
                Returns the list of of UUIDs of all virtual machines that use
                the given floppy image.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the image to get the usage information for.</desc>
            </param>
            <param name="usage" type="ResourceUsage" dir="in">
                <desc>Type of the usage (permanent, temporary or all).</desc>
            </param>
            <param name="machineIDs" type="wstring" dir="return">
                <desc>
                    List of UUIDs of all machines that use the given image
                    in the way specified by the usage parameter.
                    The list is returned as a string containing UUIDs separated
                    by spaces. A null string means that the image is not used.
                    <note>
                        When the usage type is <link to="ResourceUsage::AllUsage"/>
                        and the image is used by the VM both permanently
                        and temporarily, the VM's UUID will be present only
                        once in the list.
                    </note>
                </desc>
            </param>
        </method>

        <method name="unregisterFloppyImage">
            <desc>
                Unregisters the floppy image previously registered using
                <link to="#registerFloppyImage()"/>.
                <note>
                    The specified image must not be mounted to any of
                    the existing virtual machines.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the floppy image to unregister.</desc>
            </param>
            <param name="image" type="IFloppyImage" dir="return">
                <desc>Unregistered image object.</desc>
            </param>
        </method>

        <method name="findGuestOSType">
            <param name="id" type="wstring" dir="in"/>
            <param name="type" type="IGuestOSType" dir="return"/>
        </method>

        <method name="createSharedFolder">
            <desc>
                Creates a new shared folder by associating the given logical
                name with the given host path, adds it to the collection of
                shared folders and starts sharing it.
                Refer to the description of <link to="ISharedFolder"/> to read
                about logical name unicity.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Unique logical name of the shared folder.</desc>
            </param>
            <param name="hostPath" type="wstring" dir="in">
                <desc>Full path to the shared folder in the host file system.</desc>
            </param>
        </method>

        <method name="removeSharedFolder">
            <desc>
                Removes a shared folder with the given name previously created
                by <link to="#createSharedFolder"/> from the collection of
                shared folders and stops sharing it.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Logical name of the shared folder to remove.</desc>
            </param>
        </method>

        <method name="getNextExtraDataKey">
            <desc>
                Returns the extra data key name following the supplied key.
                An error is returned if the supplied key does not exist.
                NULL is returned if the supplied key is the last key.
                When supplying NULL for the key, the first item is returned.
                NextValue is an optional parameter and if supplied, the next
                key's value is returned as well.
            </desc>
            <param name="key" type="wstring" dir="in"/>
            <param name="nextKey" type="wstring" dir="out"/>
            <param name="nextValue" type="wstring" dir="out"/>
        </method>

        <method name="getExtraData">
            <desc>Returns associated extra data.</desc>
            <param name="key" type="wstring" dir="in"/>
            <param name="value" type="wstring" dir="return"/>
        </method>

        <method name="setExtraData">
            <desc>Sets associated extra data.</desc>
            <param name="key" type="wstring" dir="in"/>
            <param name="value" type="wstring" dir="in"/>
        </method>

        <method name="openSession">
            <desc>
                <p>Opens a new direct session with the given virtual machine.
                Within the direct session context, it is possible to change
                all VM settings, as well as to execute the VM in the process
                space of the session object. There can be only one direct
                session open at a time for every virtual machine.</p>
                <p>Upon successful return, the session object can be used to
                get access to the machine and to the VM console.
                </p>
            </desc>
            <param name="session" type="ISession" dir="in">
                <desc>
                    Session object that will represent the opened session after
                    successful method invocation. This object must not represent
                    the already open session.
                    <note>
                        This session will be automatically closed if the
                        VirtualBox server is terminated for some reason.
                    </note>
                </desc>
            </param>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the virtual machine to open a session with.</desc>
            </param>
        </method>

        <method name="openRemoteSession">
            <desc>
                <p>Opens a new remote session with the given virtual
                machine. Opening the remote session causes the server to start
                a new process that opens a direct session with the given VM.
                The remote session provides some level of control over the VM
                execution (using the IConsole interface) to the caller. Within
                the remote session context, it is not possible to change any
                static VM settings (such as name, HDD configuration, etc.).</p>
                <p>This operation can take some time, so the progress object
                is returned to let the caller be informed when the session is
                actually open. Until then, the remote session object remains in
                the closed state and accessing the machine or its console through
                it is invalid.
                </p>

                Currently supported session types (values of the @a type
                parameter) are:
                <ul>
                    <li><tt>gui</tt>: VirtualBox Qt GUI session</li>
                    <li><tt>vrdp</tt>: VirtualBox VRDP Server session</li>
                </ul>

                <note>
                    It is impossible to open a remote session with the machine
                    that already has an open direct session or waits until the
                    previous request to open the remote session is completed
                    (see <link to="IMachine::sessionState"/>).
                </note>

                <note>
                    The opened @a session will be automatically closed when
                    the corresponding direct session dies or gets closed.
                </note>

                <see>openExistingSession</see>
            </desc>
            <param name="session" type="ISession" dir="in">
                <desc>
                    Session object that will represent the opened remote session
                    after successful method invocation (this object must not
                    represent an already open session).
                </desc>
            </param>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the virtual machine to open a session with.</desc>
            </param>
            <param name="type" type="wstring" dir="in">
                <desc>
                    Type of the remote session (case sensitive).
                </desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="openExistingSession">
            <desc>
                <p>Opens a new remote session with the virtual machine for
                which a direct session is already open.
                The remote session provides some level of control over the VM
                execution (using the IConsole interface) to the caller. Within
                the remote session context, it is not possible to change any
                static VM settings (such as name, HDD configuration, etc.).</p>
                <p>As opposed to <link to="#openRemoteSession()"/>, the number of
                remote sessions opened this way is not limited by the API.</p>
                <note>
                    It is impossible to open a remote session with the machine
                    that doesn't have an open direct session.
                </note>
                <see>openRemoteSession</see>
            </desc>
            <param name="session" type="ISession" dir="in">
                <desc>
                    Session object that will represent the open remote session
                    after successful method invocation. This object must not
                    represent an already open session.
                    <note>
                        This session will be automatically closed when the peer
                        (direct) session dies or gets closed.
                    </note>
                </desc>
            </param>
            <param name="machineId" type="uuid" dir="in">
                <desc>ID of the virtual machine to open a session with.</desc>
            </param>
        </method>

        <method name="registerCallback">
            <param name="callback" type="IVirtualBoxCallback" dir="in"/>
        </method>

        <method name="unregisterCallback">
            <param name="callback" type="IVirtualBoxCallback" dir="in"/>
        </method>

    </interface>

    <class name="VirtualBox" uuid="B1A7A4F2-47B9-4A1E-82B2-07CCD5323C3F"
           namespace="virtualbox.org">
        <interface name="IVirtualBox" default="yes"/>
    </class>

    <!--
    // IMachine
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="IMachineEnumerator" type="IMachine"
        uuid="1b554149-be0a-4465-9252-9ff8f420af55"
    />

    <collection
        name="IMachineCollection" type="IMachine" enumerator="IMachineEnumerator"
        uuid="FD443EC1-3007-4F5B-9282-D72760A66916"
        readonly="yes"
    />

    <interface
        name="IInternalMachineControl" extends="$unknown"
        uuid="F466BF2E-BD6B-4af0-9C08-46DD42B28A44"
        internal="yes"
        wsmap="suppress"
    >
        <method name="updateState">
            <desc>
                Updates the VM state.
                <note>
                    This operation will also update the settings file with
                    the correct information about the saved state file
                    and delete this file from disk when appropriate.
                </note>
            </desc>
            <param name="state" type="MachineState" dir="in"/>
        </method>

        <method name="getIPCId">
            <param name="id" type="wstring" dir="return"/>
        </method>

        <method name="getLogFolder">
            <desc>
                Returns the full name of the directory where to store
                log files created during this machine's executoin.
            </desc>
            <param name="logFolder" type="wstring" dir="return"/>
        </method>

        <method name="runUSBDeviceFilters">
            <desc>
                Asks the server to run USB devices filters of the associated
                machine against the given USB device and tell if there is
                a match.
                <note>
                    Intended to be used only for remote USB devices. Local
                    ones don't require to call this method (this is done
                    implicitly by the Host and USBProxyService).
                </note>
            </desc>
            <param name="device" type="IUSBDevice" dir="in"/>
            <param name="matched" type="boolean" dir="return"/>
        </method>

        <method name="captureUSBDevice">
            <desc>
                Requests a capture of the given host USB device, and returns
                the captured device (as IUSBDevice) to the caller.
                <note>
                    The server must mark the device as USBDeviceCaptured
                    during this call.

                    This method must return extended error info in case of any
                    eroror (<link to="IConsole::detachUSBDevice()"/>) relies
                    on this.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in"/>
            <param name="hostDevice" type="IUSBDevice" dir="return"/>
        </method>

        <method name="releaseUSBDevice">
            <desc>
                Releases the given USB device.
                <note>
                    The server must run its own filters and filters of all VMs
                    but this one on the given device as if it were just attached
                    to the host computer.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in"/>
        </method>

        <method name="autoCaptureUSBDevices">
            <desc>
                Queries the list of available devices that must be auto-captured
                according to this VM's filters. Devices returned as IUSBDevice
                instances.
                <note>
                    The server must mark all returned devices as USBDeviceCaptured
                    during this call.
                </note>
            </desc>
            <param name="hostDevices" type="IUSBDeviceCollection" dir="return"/>
        </method>

        <method name="releaseAllUSBDevices">
            <desc>
                Releases all USB devices that are captured by this VM because
                the VM has been terminated.
                <note>
                    The server must run its own filters and filters of all VMs
                    but this one on all released devices as if they were just
                    attached to the host computer.
                </note>
            </desc>
        </method>

        <method name="onSessionEnd">
            <desc>
                Triggered by the given session object when the session is about
                to close normally.
            </desc>
            <param name="session" type="ISession" dir="in">
                <desc>Session that is being closed</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>
                    Used to wait until the corresponding machine is actually
                    deassociated from the given session on the server.
                    Returned only when this session is a direct one.
                </desc>
            </param>
        </method>

        <method name="beginSavingState">
            <desc>
                Called by the VM process to inform the server it wants to
                save the current state and stop the VM execution.
            </desc>
            <param name="progress" type="IProgress" dir="in">
                <desc>
                    Progress object created by the VM process to wait until
                    the state is saved.
                </desc>
            </param>
            <param name="stateFilePath" type="wstring" dir="out">
                <desc>
                    File path the VM process must save the execution state to.
                </desc>
            </param>
        </method>

        <method name="endSavingState">
            <desc>
                Called by the VM process to inform the server that saving
                the state previously requested by #beginSavingState is either
                successfully finished or there was a failure.
            </desc>

            <param name="success" type="boolean" dir="in">
                <desc><tt>true</tt> to indicate success and <tt>false</tt> otherwise</desc>
            </param>
        </method>

        <method name="beginTakingSnapshot">
            <desc>
                Called by the VM process to inform the server it wants to
                take a snapshot.
            </desc>
            <param name="initiator" type="IConsole" dir="in">
                <desc>The console object that initiated this call.</desc>
            </param>
            <param name="name" type="wstring" dir="in">
                <desc>Snapshot name</desc>
            </param>
            <param name="description" type="wstring" dir="in">
                <desc>Snapshot description</desc>
            </param>
            <param name="progress" type="IProgress" dir="in">
                <desc>
                    Progress object created by the VM process to wait until
                    the state is saved (only for online snapshots).
                </desc>
            </param>
            <param name="stateFilePath" type="wstring" dir="out">
                <desc>
                    File path the VM process must save the execution state to.
                </desc>
            </param>
            <param name="serverProgress" type="IProgress" dir="out">
                <desc>
                    Progress object created by the server process to wait until
                    the snapshot is taken (VDI diff creation, etc.).
                </desc>
            </param>
        </method>

        <method name="endTakingSnapshot">
            <desc>
                Called by the VM process to inform the server that the snapshot
                previously requested by #beginTakingSnapshot is either
                successfully taken or there was a failure.
            </desc>

            <param name="success" type="boolean" dir="in">
                <desc><tt>true</tt> to indicate success and <tt>false</tt> otherwise</desc>
            </param>
        </method>

        <method name="discardSnapshot">
            <desc>
                Gets called by IConsole::discardSnapshot.
            </desc>
            <param name="initiator" type="IConsole" dir="in">
                <desc>The console object that initiated this call.</desc>
            </param>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the snapshot to discard.</desc>
            </param>
            <param name="machineState" type="MachineState" dir="out">
                <desc>New machine state after this operation is started.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="discardCurrentState">
            <desc>
                Gets called by IConsole::discardCurrentState.
            </desc>
            <param name="initiator" type="IConsole" dir="in">
                <desc>The console object that initiated this call.</desc>
            </param>
            <param name="machineState" type="MachineState" dir="out">
                <desc>New machine state after this operation is started.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="discardCurrentSnapshotAndState">
            <desc>
                Gets called by IConsole::discardCurrentSnapshotAndState.
            </desc>
            <param name="initiator" type="IConsole" dir="in">
                <desc>The console object that initiated this call.</desc>
            </param>
            <param name="machineState" type="MachineState" dir="out">
                <desc>New machine state after this operation is started.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

    </interface>

    <enum
        name="BIOSBootMenuMode"
        uuid="ae4fb9f7-29d2-45b4-b2c7-d579603135d5"
    >
        <desc>
            This represents the BIOS boot menu state.
        </desc>

        <const name="Disabled"       value="0"/>
        <const name="MenuOnly"       value="1"/>
        <const name="MessageAndMenu" value="2"/>
    </enum>

    <interface
        name="IBIOSSettings" extends="$unknown"
        uuid="00fff9d7-983e-462d-a1aa-4cc26de4f0d4"
        wsmap="struct"
    >
        <attribute name="LogoFadeIn" type="boolean">
            <desc>Fade in flag for BIOS logo animation.</desc>
        </attribute>

        <attribute name="LogoFadeOut" type="boolean">
            <desc>Fade out flag for BIOS logo animation.</desc>
        </attribute>

        <attribute name="LogoDisplayTime" type="unsigned long">
            <desc>BIOS logo display time in milliseconds (0 = default).</desc>
        </attribute>

        <attribute name="LogoImagePath" type="wstring">
            <desc>Local file system path for external BIOS image.</desc>
        </attribute>

        <attribute name="BootMenuMode" type="BIOSBootMenuMode">
            <desc>Mode of the BIOS boot device menu.</desc>
        </attribute>

        <attribute name="ACPIEnabled" type="boolean">
            <desc>ACPI support flag.</desc>
        </attribute>

        <attribute name="IOAPICEnabled" type="boolean">
            <desc>
                IO APIC support flag. If set, VirtualBox will provide an IO APIC
                and support IRQs above 15.
            </desc>
        </attribute>

    </interface>

    <interface
        name="IMachine" extends="$unknown"
        uuid="50fa9181-d2d4-45ca-bf0e-742677b9c707"
        wsmap="uuid"
    >
        <attribute name="parent" type="IVirtualBox" readonly="yes">
            <desc>Associated parent obect.</desc>
        </attribute>

        <attribute name="accessible" type="boolean" readonly="yes">
            <desc>
                Whether this virtual machine is currently accessible or not.

                The machine is considered to be inaccessible when:
                <ul>
                    <li>It is a registered virtual machine, and
                    </li>
                    <li>Its settings file is inaccessible (for example, it is
                    located on a network share that is not accessible during
                    VirtualBox startup, or becomes inaccessible later, or if
                    the settings file can be read but is invalid).
                    </li>
                </ul>

                Otherwise, the value of this property is always <tt>true</tt>.

                Every time this property is read, the accessibility state of
                this machine is re-evaluated. If the returned value is |false|,
                the <link to="#accessError"/> property may be used to get the
                detailed error information describing the reason of
                inaccessibility.

                When the machine is inaccessible, only the following properties
                can be used on it:
                <ul>
                    <li><link to="#parent"/></li>
                    <li><link to="#id"/></li>
                    <li><link to="#settingsFilePath"/></li>
                    <li><link to="#accessible"/></li>
                    <li><link to="#accessError"/></li>
                </ul>

                An attempt to access any other property or method will return
                an error.

                The only possible action you can perform on an inaccessible
                machine is to unregister it using the
                <link to="IVirtualBox::unregisterMachine"/> call (or, to check
                for the accessibility state once more by querying this
                property).

                <note>
                    In the current implementation, once this property returns
                    <tt>true</tt>, the machine will never become inaccessible
                    later, even if its settings file cannot be successfully
                    read/written any more (at least, until the VirtualBox
                    server is restarted). This limitation may be removed in
                    future releases.
                </note>
            </desc>
        </attribute>

        <attribute name="accessError" type="IVirtualBoxErrorInfo" readonly="yes">
            <desc>
                Error information describing the reason of machine
                inaccessibility.

                Reading this property is only valid after the last call to
                <link to="#accessible"/> returned <tt>false</tt> (i.e. the
                machine is currently unaccessible). Otherwise, a null
                IVirtualBoxErrorInfo object will be returned.
            </desc>
        </attribute>

        <attribute name="name" type="wstring">
            <desc>
                Name of the virtual machine.

                Besides being used for human-readable identification purposes
                everywhere in VirtualBox, the virtual machine name is also used
                as a name of the machine's settings file and as a name of the
                subdirectory this settings file resides in. Thus, every time you
                change the value of this property, the settings file will be
                renamed once you call <link to="#saveSettings()"/> to confirm the
                change. The containing subdirectory will be also renamed, but
                only if it has exactly the same name as the settings file
                itself prior to changing this property (for backward compatibility
                with previous API releases). The above implies the following
                limitations:
                <ul>
                <li>The machine name cannot be empty.</li>
                <li>The machine name can contain only characters that are valid
                    file name characters according to the rules of the file
                    system used to store VirtualBox configuration.</li>
                <li>You cannot have two or more machines with the same name
                    if they use the same subdirectory for storing the machine
                    settings files.</li>
                <li>You cannot change the name of the machine if it is running,
                    or if any file in the directory containing the settings file
                    is being used by another running machine or by any other
                    process in the host operating system at a time when
                    <link to="#saveSettings()"/> is called.
                </li>
                </ul>
                If any of the above limitations are hit, <link to="#saveSettings()"/>
                will return an appropriate error message explaining the exact
                reason and the changes you made to this machine will not be
                saved.
                <note>
                    For "legacy" machines created using the
                    <link to="IVirtualBox::createLegacyMachine()"/> call,
                    the above naming limitations do not apply because the
                    machine name does not affect the settings file name.
                    The settings file name remains the same as it was specified
                    during machine creation and never changes.
                </note>
            </desc>
        </attribute>

        <attribute name="description" type="wstring">
            <desc>
                Description of the virtual machine.

                The description attribute can contain any text and is
                typically used to describe the hardware and software
                configuration of the virtual machine in detail (i.e. network
                settings, versions of the installed software and so on).
            </desc>
        </attribute>

        <attribute name="id" type="uuid" readonly="yes">
            <desc>UUID of the virtual machine.</desc>
        </attribute>

        <attribute name="OSType" type="IGuestOSType">
            <desc>
                Guest OS type configured by the user.
                <note>
                    This value may differ from the value returned by
                    <link to="IGuest::OSType"/> if Guest Additions are
                    installed to the guest OS.
                </note>
            </desc>
        </attribute>

        <attribute name="memorySize" type="unsigned long">
            <desc>Sytem memory size in megabytes.</desc>
        </attribute>

        <attribute name="VRAMSize" type="unsigned long">
            <desc>Video memory size in megabytes.</desc>
        </attribute>

        <attribute name="MonitorCount" type="unsigned long">
            <desc>
                Number of virtual monitors.
                <note>
                    Only effective on Windows XP and later guests with
                    Guest Additions installed.
                </note>
            </desc>
        </attribute>

        <attribute name="BIOSSettings" type="IBIOSSettings" readonly="yes">
            <desc>Object containing all BIOS settings.</desc>
        </attribute>

        <attribute name="HWVirtExEnabled" type="TriStateBool">
            <desc>
                This setting determines whether VirtualBox will try to make use of
                the host CPU's hardware virtualization extensions such as Intel VT-x
                and AMD SVM. Note that in case such extensions are not available,
                they will not be used.
            </desc>
        </attribute>

        <attribute name="snapshotFolder" type="wstring">
            <desc>
                Full path to the directory used to store snapshot data
                (difrerencing hard disks and saved state files) of this machine.

                The initial value of this property is
                <tt>&lt;</tt><link to="#settingsFilePath">
                path_to_settings_file</link><tt>&gt;/&lt;</tt>
                <link to="#id">machine_uuid</link>
                <tt>&gt;</tt>.

                Currently, it is an error to try to change this property on
                a machine that has snapshots (because this would require to
                move possibly large files to a different location).
                A separate method will be available for this purpose later.

                <note>
                    Setting this property to <tt>null</tt> will restore the
                    initial value.
                </note>
                <note>
                    When setting this property, the specified path can be
                    absolute (full path) or relative to the directory where the
                    <link to="#settingsFilePath">machine settings file</link>
                    is located. When reading this property, a full path is
                    always returned.
                </note>
                <note>
                    The specified path may not exist, it will be created
                    when necessary.
                </note>
            </desc>
        </attribute>

        <attribute name="VRDPServer" type="IVRDPServer" readonly="yes">
            <desc>VRDP server object.</desc>
        </attribute>

        <attribute name="hardDiskAttachments" type="IHardDiskAttachmentCollection" readonly="yes">
            <desc>Collection of hard disks attached to the machine.</desc>
        </attribute>

        <attribute name="DVDDrive" type="IDVDDrive" readonly="yes">
            <desc>Associated DVD drive object.</desc>
        </attribute>

        <attribute name="FloppyDrive" type="IFloppyDrive" readonly="yes">
            <desc>Associated floppy drive object.</desc>
        </attribute>

        <attribute name="USBController" type="IUSBController" readonly="yes">
            <desc>Associated USB controller object.</desc>
        </attribute>

        <attribute name="audioAdapter" type="IAudioAdapter" readonly="yes">
            <desc>Associated audio adapter, always present.</desc>
        </attribute>

        <attribute name="settingsFilePath" type="wstring" readonly="yes">
            <desc>
                Full name of the file containing machine settings data.
            </desc>
        </attribute>

        <attribute name="settingsModified" type="boolean" readonly="yes">
            <desc>
                Whether the settings of this machine have been modified
                (but neither yet saved nor discarded).
                <note>
                    Reading this property is only valid on instances returned
                    by <link to="ISession::machine"/> and on new machines
                    created by <link to="IVirtualBox::createMachine"/> or opened
                    by <link to="IVirtualBox::openMachine"/> but not
                    yet registered, or on unregistered machines after calling
                    <link to="IVirtualBox::unregisterMachine"/>. For all other
                    cases, the settigs can never be modified.
                </note>
                <note>
                    For newly created unregistered machines, the value of this
                    property is always TRUE until <link to="#saveSettings"/>
                    is called (no matter if any machine settings have been
                    changed after the creation or not). For opened machines
                    the value is set to FALSE (and then follows to normal rules).
                </note>
            </desc>
        </attribute>

        <attribute name="sessionState" type="SessionState" readonly="yes">
            <desc>Current session state for this machine.</desc>
        </attribute>

        <attribute name="sessionType" type="wstring" readonly="yes">
            <desc>
                Type of the session.  If <link to="#sessionState"/> is
                SessionSpawning or SessionOpen, this attribute contains the
                same value as passed to the
                <link to="IVirtualBox::openRemoteSession()"/> method in the @a
                type parameter. If the session was opened directly using
                <link to="IVirtualBox::openSession()"/>, or if
                <link to="#sessionState"/> is SessionClosed, the value of this
                attribute is @c null.
            </desc>
        </attribute>

        <attribute name="sessionPid" type="unsigned long" readonly="yes">
            <desc>
                Identifier of the session process. This attribute contains the
                platform-dependent identifier of the process that has opened a
                direct session for this machine using the
                <link to="IVirtualBox::openSession()"/> call. The returned value
                is only valid if <link to="#sessionState"/> is SessionOpen or
                SessionClosing (i.e. a session is currently open or being
                closed) by the time this property is read.
            </desc>
        </attribute>

        <attribute name="state" type="MachineState" readonly="yes">
            <desc>Current execution state of this machine.</desc>
        </attribute>

        <attribute name="lastStateChange" type="long long" readonly="yes">
            <desc>
                Time stamp of the last execution state change,
                in milliseconds since 1970-01-01 UTC.
            </desc>
        </attribute>

        <attribute name="stateFilePath" type="wstring" readonly="yes">
            <desc>
                Full path to the file that stores the execution state of
                the machine when it is in the <link to="MachineState::Saved"/>
                state.
                <note>
                    When the machine is not in the Saved state, this attribute
                    <tt>null</tt>.
                </note>
            </desc>
        </attribute>

        <attribute name="currentSnapshot" type="ISnapshot" readonly="yes">
            <desc>
                Current snapshot of this machine.
                <note>
                    A <tt>null</tt> object is returned if the machine doesn't
                    have snapshots.
                </note>
                <see><link to="ISnapshot"/></see>
            </desc>
        </attribute>

        <attribute name="snapshotCount" type="unsigned long" readonly="yes">
            <desc>
                Number of snapshots taken on this machine. Zero means the
                machine doesn't have any snapshots.
            </desc>
        </attribute>

        <attribute name="currentStateModified" type="boolean" readonly="yes">
            <desc>
                Returns <tt>true</tt> if the current state of the machine is not
                identical to the state stored in the current snapshot.

                The current state is identical to the current snapshot right
                after one of the following calls are made:
                <ul>
                    <li><link to="IConsole::discardCurrentState"/> or
                        <link to="IConsole::discardCurrentSnapshotAndState"/>
                    </li>
                    <li><link to="IConsole::takeSnapshot"/> (issued on a
                         powered off or saved machine, for which
                         <link to="#settingsModified"/> returns <tt>false</tt>)
                    </li>
                    <li><link to="IMachine::setCurrentSnapshot"/>
                    </li>
                </ul>

                The current state remains identical until one of the following
                happens:
                <ul>
                    <li>settings of the machine are changed</li>
                    <li>the saved state is discarded</li>
                    <li>the current snapshot is discarded</li>
                    <li>an attempt to execute the machine is made</li>
                </ul>

                <note>
                   For machines that don't have snapshots, this property is
                   always <tt>false</tt>.
                </note>
            </desc>
        </attribute>

        <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
            <desc>
                Collection of shared folders for this machine. These folders
                are shared automatically upon machine startup and available only
                to the guest OS installed within this machine.

                New folders to share are added to the collection using
                <link to="#createSharedFolder"/>. An existing shared folder can
                be removed using <link to="#removeSharedFolder"/>.
            </desc>
        </attribute>

        <attribute name="clipboardMode" type="ClipboardMode">
            <desc>
                Synchronization mode between the host OS clipboard
                and the guest OS clipboard.
            </desc>
        </attribute>

        <method name="setBootOrder">
            <desc>
                Puts the given device to the specified position in
                the boot order.

                @todo [remove?]
                If the machine can have more than one device of the given type
                (such as hard disks), then a separate method should be used to
                specify the boot order for individual devices. Using this method
                in such cases will put the first device in the group
                (for example, a hard disk attached as Master on the primary
                IDE controller) to the given position.

                To indicate that no any device is associated with the
                given position, <link to="DeviceType::NoDevice"/> should be used.

                @todo setHardDiskBootOrder(), setNetworkBootOrder()
            </desc>
            <param name="position" type="unsigned long" dir="in">
                <desc>
                    Position in the boot order (<tt>1</tt> to the total number of
                    devices the machine can boot from, as returned by
                    <link to="ISystemProperties::maxBootPosition"/>).
                </desc>
            </param>
            <param name="device" type="DeviceType" dir="in">
                <desc>
                    The type of the device used to boot at the given position.
                </desc>
            </param>
        </method>

        <method name="getBootOrder" const="yes">
            <desc>
                Returns the device type that occupies the specified
                position in the boot order.

                @todo [remove?]
                If the machine can have more than one device of the returned type
                (such as hard disks), then a separate method should be used to
                retrieve the individual device that occupies the given position.

                If here are no devices at the given position, then
                <link to="DeviceType::NoDevice"/> is returned.

                @todo getHardDiskBootOrder(), getNetworkBootOrder()
            </desc>
            <param name="order" type="unsigned long" dir="in">
                <desc>
                    Position in the boot order (<tt>1</tt> to the total number of
                    devices the machine can boot from, as returned by
                    <link to="ISystemProperties::maxBootPosition"/>).
                </desc>
            </param>
            <param name="device" type="DeviceType" dir="return">
                <desc>
                    Device at the given position.
                </desc>
            </param>
        </method>

        <method name="attachHardDisk">
            <desc>

                Attaches a virtual hard disk identified by the given UUID to the
                given device slot of the given controller. The specified device
                must not have another disk attached and the given hard disk must
                not be already attached to this machine.

                See <link to="IHardDisk"/> for detailed information about
                attaching hard disks.

                <note>You cannot attach a hard disk to a running machine. Also,
                you cannot attach a hard disk to a newly created machine until
                it is registered.</note>

                <note>Attaching a hard disk to a machine creates a <i>lazy</i>
                attachment. In particular, no differeincing images are
                actually created until <link to="#saveSettings"/> is called to
                commit all changed settings.</note>

            </desc>
            <param name="diskID" type="uuid" dir="in">
                <desc>UUID of the hard disk to attach.</desc>
            </param>
            <param name="controller" type="DiskControllerType" dir="in">
                <desc>Controller to attach the hard disk to.</desc>
            </param>
            <param name="device" type="long" dir="in">
                <desc>Device slot to attach the hard disk to.</desc>
            </param>
        </method>

        <method name="getHardDisk" const="yes">
            <desc>
                Returns the hard disk attached to the
                given controller under the specified device number.
            </desc>
            <param name="controller" type="DiskControllerType" dir="in"/>
            <param name="deviceNumber" type="long" dir="in"/>
            <param name="hardDisk" type="IHardDisk" dir="return"/>
        </method>

        <method name="detachHardDisk">
            <desc>

                Detaches the hard disk drive attached to the given device slot
                of the given controller.

                See <link to="IHardDisk"/> for detailed information about
                attaching hard disks.

                <note>You cannot detach a hard disk from a running
                machine.</note>

                <note>Detaching a hard disk from a machine creates a <i>lazy</i>
                detachment. In particular, if the detached hard disk is a
                differencing hard disk, it is not actually deleted until <link
                to="#saveSettings"/> is called to commit all changed settings.
                Keep in mind, that doing <link to="#saveSettings"/> will
                <b>physically delete</b> all detached differencing hard disks,
                so be careful.</note>

            </desc>
            <param name="controller" type="DiskControllerType" dir="in">
                <desc>Controller to dettach the hard disk from.</desc>
            </param>
            <param name="device" type="long" dir="in">
                <desc>Device slot to dettach the hard disk from.</desc>
            </param>
        </method>

        <method name="getNetworkAdapter" const="yes">
            <desc>
                Returns the network adapter associated with the given slot.
                Slots are numbered sequentially, starting with zero. The total
                number of adapters per every machine is defined by the
                <link to="ISystemProperties::networkAdapterCount"/> property,
                so the maximum slot number is one less than that property's value.
            </desc>
            <param name="slot" type="unsigned long" dir="in"/>
            <param name="adapter" type="INetworkAdapter" dir="return"/>
        </method>

        <method name="getNextExtraDataKey">
            <desc>
                Returns the extra data key name following the supplied key.
                An error is returned if the supplied key does not exist.
                NULL is returned if the supplied key is the last key.
                When supplying NULL for the key, the first item is returned.
                NextValue is an optional parameter and if supplied, the next
                key's value is returned as well.
            </desc>
            <param name="key" type="wstring" dir="in"/>
            <param name="nextKey" type="wstring" dir="out"/>
            <param name="nextValue" type="wstring" dir="out"/>
        </method>

        <method name="getExtraData">
            <desc>Returns associated extra data.</desc>
            <param name="key" type="wstring" dir="in"/>
            <param name="value" type="wstring" dir="return"/>
        </method>

        <method name="setExtraData">
            <desc>Sets associated extra data.</desc>
            <param name="key" type="wstring" dir="in"/>
            <param name="value" type="wstring" dir="in"/>
        </method>

        <method name="saveSettings">
            <desc>
                Saves any changes to machine settings made since the session
                has been opened or a new machine has been created, or since the
                last call to <link to="#saveSettings"/> or <link to="#discardSettings"/>.
                For registered machines, new settings become visible to all
                other VirtualBox clients after successful invocation of this
                method.
                <note>
                    The method sends <link to="IVirtualBoxCallback::onMachineDataChange"/>
                    notification event after the configuration has been successfully
                    saved (only for registered machines).
                </note>
                <note>
                    Calling this method is only valid on instances returned
                    by <link to="ISession::machine"/> and on new machines
                    created by <link to="IVirtualBox::createMachine"/> but not
                    yet registered, or on unregistered machines after calling
                    <link to="IVirtualBox::unregisterMachine"/>.
                </note>
            </desc>
        </method>

        <method name="discardSettings">
            <desc>
                Discards any changes to the machine settings made since the session
                has been opened or since the last call to <link to="#saveSettings"/>
                or <link to="#discardSettings"/>.
                <note>
                    Calling this method is only valid on instances returned
                    by <link to="ISession::machine"/> and on new machines
                    created by <link to="IVirtualBox::createMachine"/> or
                    opened by <link to="IVirtualBox::openMachine"/> but not
                    yet registered, or on unregistered machines after calling
                    <link to="IVirtualBox::unregisterMachine"/>.
                </note>
            </desc>
        </method>

        <method name="deleteSettings">
            <desc>
                Deletes the settings file of this machine from disk.
                The machine must not be registered in order for this operation
                to succeed.
                <note>
                    <link to="#settingsModified"/> will return TRUE after this
                    method successfully returns.
                </note>
                <note>
                    Calling this method is only valid on instances returned
                    by <link to="ISession::machine"/> and on new machines
                    created by <link to="IVirtualBox::createMachine"/> or
                    opened by <link to="IVirtualBox::openMachine"/> but not
                    yet registered, or on unregistered machines after calling
                    <link to="IVirtualBox::unregisterMachine"/>.
                </note>
                <note>
                    The deleted machine settings file can be restored (saved again)
                    by calling <link to="#saveSettings"/>.
                </note>
            </desc>
        </method>

        <method name="getSnapshot">
            <desc>
                Returns a snapshot of this machine with the given UUID.
                A <tt>null</tt> UUID can be used to obtain the first snapshot
                taken on this machine. This is useful if you want to traverse
                the whole tree of snapshots starting from the root.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the snapshot to get</desc>
            </param>
            <param name="snapshot" type="ISnapshot" dir="return">
                <desc>Snapshot object with the given UUID.</desc>
            </param>
        </method>

        <method name="findSnapshot">
            <desc>
                Returns a snapshot of this machine with the given name.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Name of the snapshot to find</desc>
            </param>
            <param name="snapshot" type="ISnapshot" dir="return">
                <desc>Snapshot object with the given name.</desc>
            </param>
        </method>

        <method name="setCurrentSnapshot">
            <desc>
                Sets the current snapshot of this machine.
                <note>
                    In the current implementation, this operation is not
                    implemented.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the snapshot to set as the current snapshot.</desc>
            </param>
        </method>

        <method name="createSharedFolder">
            <desc>
                Creates a new shared folder by associating the given logical
                name with the given host path, adds it to the collection of
                shared folders and starts sharing it.
                Refer to the description of <link to="ISharedFolder"/> to read
                about logical name unicity.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Unique logical name of the shared folder.</desc>
            </param>
            <param name="hostPath" type="wstring" dir="in">
                <desc>Full path to the shared folder in the host file system.</desc>
            </param>
        </method>

        <method name="removeSharedFolder">
            <desc>
                Removes a shared folder with the given name previously created
                by <link to="#createSharedFolder"/> from the collection of
                shared folders and stops sharing it.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Logical name of the shared folder to remove.</desc>
            </param>
        </method>

    </interface>

    <!--
    // IConsole
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IConsoleCallback" extends="$unknown"
        uuid="05D3DD3F-0550-4953-BB3C-4ECB3EBF7C2E"
        wsmap="suppress"
    >

        <method name="onMousePointerShapeChange">
            <desc>
                Notification when the guest mouse pointer shape has
                changed. The new shape data is given.
            </desc>
            <param name="visible" type="boolean" dir="in">
                <desc>
                    Flag whether the pointer is visible.
                </desc>
            </param>
            <param name="alpha" type="boolean" dir="in">
                <desc>
                    Flag whether the pointer has an alpha channel.
                </desc>
            </param>
            <param name="xHot" type="unsigned long" dir="in">
                <desc>
                    The pointer hot spot x coordinate.
                </desc>
            </param>
            <param name="yHot" type="unsigned long" dir="in">
                <desc>
                    The pointer hot spot y coordinate.
                </desc>
            </param>
            <param name="width" type="unsigned long" dir="in">
                <desc>
                    Width of the pointer shape in pixels.
                </desc>
            </param>
            <param name="height" type="unsigned long" dir="in">
                <desc>
                    Height of the pointer shape in pixels.
                </desc>
            </param>
            <param name="shape" type="octet" mod="ptr" dir="in">
                <desc>
                    Address of the shape buffer.

                    The buffer contains 1 bpp (bits per pixel) AND mask followed by 32 bpp XOR (color) mask.

                    For pointers without alpha channel the XOR mask pixels are 32 bit values: (lsb)BGR0(msb).
                    For pointers with alpha channel the XOR mask consists of (lsb)BGRA(msb) 32 bit values.

                    AND mask presents for pointers with alpha channel, so if the callback does not
                    support alpha, the pointer could be displayed as a normal color pointer.

                    The AND mask is 1 bpp bitmap with byte aligned scanlines. Size of AND mask,
                    therefore, is <tt>cbAnd = (width + 7) / 8 * height</tt>. The padding bits at the
                    end of any scanline are undefined.

                    The XOR mask follows the AND mask on the next 4 bytes aligned offset:
                    <tt>uint8_t *pXor = pAnd + (cbAnd + 3) &amp; ~3</tt>
                    Bytes in the gap between the AND and the XOR mask are undefined.
                    XOR mask scanlines have no gap between them and size of XOR mask is:
                    <tt>cXor = width * 4 * height</tt>.

                    <note>
                        If 'shape' is equal to 0, only pointer visibility is being changed.
                    </note>
                </desc>
            </param>
        </method>

        <method name="onMouseCapabilityChange">
            <desc>
                Notification when the mouse capabilities reported by the
                guest have changed. The new capabilities are passed.
            </desc>
            <param name="supportsAbsolute" type="boolean" dir="in"/>
            <param name="needsHostCursor" type="boolean" dir="in"/>
        </method>

        <method name="onKeyboardLedsChange">
            <desc>
                Notification of the host if the guest executed the KBD_CMD_SET_LEDS
                command to alter the state of the keyboard LEDs.
            </desc>
            <param name="numLock" type="boolean" dir="in"/>
            <param name="capsLock" type="boolean" dir="in"/>
            <param name="scrollLock" type="boolean" dir="in"/>
        </method>

        <method name="onStateChange">
            <desc>
                Notification when the execution state of the machine has changed.
                The new state will be given.
            </desc>
            <param name="state" type="MachineState" dir="in"/>
        </method>

        <method name="onAdditionsStateChange">
            <desc>
                Notification when a Guest Additions property changes.
                Interested callees should query IGuest's properties to
                find out what has changed.
            </desc>
        </method>

        <method name="onRuntimeError">
            <desc>
                Notification when an error happens during the virtual
                machine execution.

                There are three kinds of runtime errors:
                <ul>
                    <li><i>fatal</i></li>
                    <li><i>non-fatal with retry</i></li>
                    <li><i>non-fatal warnings</i></li>
                </ul>

                <b>Fatal</b> errors are indicated by the @a fatal parameter set
                to <tt>true</tt>. In case of fatal errors, the virtual machine
                execution is always paused before calling this notification, and
                the notification handler is supposed either to immediately save
                the virtual machine state using <link to="IConsole::saveState()"/>
                or power it off using <link to="IConsole::powerDown()"/>.
                Resuming the execution can lead to unpredictable results.

                <b>Non-fatal</b> errors and warnings are indicated by the
                @a fatal parameter set to <tt>false</tt>. If the virtual machine
                is in the Paused state by the time the error notification is
                received, it means that the user can <i>try to resume</i> the machine
                execution after attempting to solve the probem that caused the
                error. In this case, the notification handler is supposed
                to show an appropriate message to the user (depending on the
                value of the @a id parameter) that offers several actions such
                as <i>Retry</i>, <i>Save</i> or <i>Power Off</i>. If the user
                wants to retry, the notification handler should continue
                the machine execution using the <link to="IConsole::resume()"/>
                call. If the machine execution is not Paused during this
                notification, then it means this notification is a <i>warning</i>
                (for example, about a fatal condition that can happen very soon);
                no immediate action is required from the user, the machine
                continues its normal execution.

                Note that in either case the notification handler
                <b>must not</b> perform any action directly on a thread
                where this notification is called. Everything it is allowed to
                do is to post a message to another thread that will then talk
                to the user and take the corresponding action.

                Currently, the following error identificators are known:
                <ul>
                <li><tt>"HostMemoryLow"</tt></li>
                <li><tt>"HostAudioNotResponding"</tt></li>
                <li><tt>"VDIStorageFull"</tt></li>
                </ul>

                <note>
                    This notification is not designed to be implemented by more
                    than one callback at a time. If you have multiple
                    IConsoleCallback instances registered on the given
                    IConsole object, make sure you just return S_OK from all but
                    one of them that does actual user notification and performs
                    necessary actions.
                </note>

            </desc>
            <param name="fatal" type="boolean" dir="in">
                <desc>Whether the error is fatal or not</desc>
            </param>
            <param name="id" type="wstring" dir="in">
                <desc>Error identificator</desc>
            </param>
            <param name="message" type="wstring" dir="in">
                <desc>Optional error message</desc>
            </param>
        </method>

    </interface>

    <interface
        name="IRemoteDisplayInfo" extends="$unknown"
        uuid="550104cd-2dfd-4a6c-857d-f6f8e088e62c"
        wsmap="struct"
    >
        <attribute name="active" type="boolean" readonly="yes">
            <desc>
                Whether the remote display connection is active.
            </desc>
        </attribute>

        <attribute name="numberOfClients" type="unsigned long" readonly="yes">
            <desc>
                How many times a client connected.
            </desc>
        </attribute>

        <attribute name="beginTime" type="long long" readonly="yes">
            <desc>
                When the last connection was established, in milliseconds since 1970-01-01 UTC.
            </desc>
        </attribute>

        <attribute name="endTime" type="long long" readonly="yes">
            <desc>
                When the last connection was terminated or the current time, if
                connection is still active, in milliseconds since 1970-01-01 UTC.
            </desc>
        </attribute>

        <attribute name="bytesSent" type="unsigned long long" readonly="yes">
            <desc>
                How many bytes were sent in last or current, if still active, connection.
            </desc>
        </attribute>

        <attribute name="bytesSentTotal" type="unsigned long long" readonly="yes">
            <desc>
                How many bytes were sent in all connections.
            </desc>
        </attribute>

        <attribute name="bytesReceived" type="unsigned long long" readonly="yes">
            <desc>
                How many bytes were received in last or current, if still active, connection.
            </desc>
        </attribute>

        <attribute name="bytesReceivedTotal" type="unsigned long long" readonly="yes">
            <desc>
                How many bytes were received in all connections.
            </desc>
        </attribute>

        <attribute name="user" type="wstring" readonly="yes">
            <desc>
                Login user name supplied by the client.
            </desc>
        </attribute>

        <attribute name="domain" type="wstring" readonly="yes">
            <desc>
                Login domain name supplied by the client.
            </desc>
        </attribute>

        <attribute name="clientName" type="wstring" readonly="yes">
            <desc>
                The client name supplied by the client.
            </desc>
        </attribute>

        <attribute name="clientIP" type="wstring" readonly="yes">
            <desc>
                The IP address of the client.
            </desc>
        </attribute>

        <attribute name="clientVersion" type="unsigned long" readonly="yes">
            <desc>
                The client software version number.
            </desc>
        </attribute>

        <attribute name="encryptionStyle" type="unsigned long" readonly="yes">
            <desc>
                Public key exchange method used when connection was established.
                Values: 0 - RDP4 public key exchange scheme.
                        1 - X509 sertificates were sent to client.
            </desc>
        </attribute>

    </interface>

    <interface
        name="IConsole" extends="$unknown"
        uuid="1DEA5C4B-0753-4193-B909-22330F64EC45"
        wsmap="wstring"
    >
        <attribute name="machine" type="IMachine" readonly="yes">
            <desc>
                Machine object this console is sessioned with.
                <note>
                    This is a convenience property, it has the same value as
                    <link to="ISession::machine"/> of the corresponding session
                    object.
                </note>
            </desc>
        </attribute>

        <attribute name="state" type="MachineState" readonly="yes">
            <desc>
                Current execution state of the machine.
                <note>
                    This property always returns the same value as the corresponding
                    property of the IMachine object this console is sessioned with.
                    For the process, that owns (executes) the VM, this is the
                    preferrable way of quierying the VM state, because no IPC
                    calls are made.
                </note>
            </desc>
        </attribute>

        <attribute name="guest" type="IGuest" readonly="yes">
            <desc>Guest object.</desc>
        </attribute>

        <attribute name="keyboard" type="IKeyboard" readonly="yes">
            <desc>
                Virtual keyboard object.
                <note>
                    If the machine is not running, any attempt to use
                    the returned object will result in an error.
                </note>
            </desc>
        </attribute>

        <attribute name="mouse" type="IMouse" readonly="yes">
            <desc>
                Virtual mouse object.
                <note>
                    If the machine is not running, any attempt to use
                    the returned object will result in an error.
                </note>
            </desc>
        </attribute>

        <attribute name="display" type="IDisplay" readonly="yes">
            <desc>Virtual display object.
                <note>
                    If the machine is not running, any attempt to use
                    the returned object will result in an error.
                </note>
            </desc>
        </attribute>

        <attribute name="debugger" type="IMachineDebugger" readonly="yes">
            <desc>Debugging interface.</desc>
        </attribute>

        <attribute name="USBDevices" type="IUSBDeviceCollection" readonly="yes">
            <desc>
                Collection of USB devices currently attached to the virtual
                USB controller.
                <note>
                    The collection is empty if the machine is not running.
                </note>
            </desc>
        </attribute>

        <attribute name="remoteUSBDevices" type="IHostUSBDeviceCollection" readonly="yes">
            <desc>
                List of USB devices currently attached to the remote VRDP client.
                Once a new device is physically attached to the remote host computer,
                it appears in this list and remains there until detached.
            </desc>
        </attribute>

        <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
            <desc>
                Collection of shared folders for the current session.
                This collection is initially empty and is cleared once the
                session is closed. On other words, this collection represents
                transient shares (as opposed to <link to="IMachine::sharedFolders"/>
                that stores permanent shares stored in the settings file).

                New folders to share are added to the collection using
                <link to="#createSharedFolder"/>. An existing shared folder can
                be removed using <link to="#removeSharedFolder"/>.
            </desc>
        </attribute>

        <attribute name="remoteDisplayInfo" type="IRemoteDisplayInfo" readonly="yes">
            <desc>
                Interface that provides information on Remote Display (VRDP) connection.
            </desc>
        </attribute>

        <method name="powerUp">
            <desc>
                Starts the virtual machine execution using the current machine
                state (i.e. its current execution state, current settings and
                current hard disks).

                If the machine is powered off or aborted, the execution will
                start from the beginning (as if the real hardware were just
                powered on).

                If the machine is in the <link to="MachineState::Saved"/> state,
                it will continue its execution the point where the state has
                beem saved.

                <see>#saveState</see>
            </desc>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="powerDown">
            <desc>
                Stops the virtual machine execution.
                After this operation completes, the machine will go to the
                PoweredOff state.
            </desc>
        </method>

        <method name="reset">
            <desc>Resets the virtual machine.</desc>
        </method>

        <method name="pause">
            <desc>Pauses the virtual machine execution.</desc>
        </method>

        <method name="resume">
            <desc>Resumes the virtual machine execution.</desc>
        </method>

        <method name="powerButton">
            <desc>Send the ACPI power button event to the guest.</desc>
        </method>

        <method name="saveState">
            <desc>
                Saves the current execution state of a running virtual machine
                and stops its executiuon.

                After this operation completes, the machine will go to the
                Saved state. Next time it is powered up, this state will
                be restored and the machine will continue its execution from
                the place where it was saved.

                This operation differs from taking a snapshot to the effect
                that it doesn't create new differencing hard disks. Also, once
                the machine is powered up from the state saved using this method,
                the saved state is deleted, so it will be impossible to return
                to this state later.

                <note>On success, this method implicitly calls <link
                to="IMachine::saveSettings"/> to save all current machine
                settings (including runtime changes to the DVD drive, etc.).
                Together with the impossibility to change any VM settings when
                it is in the Saved state, this guarantees the adequate hardware
                configuration of the machine when it is restored from the saved
                state file.</note>

                <note>
                    The machine must be in the Running or Paused state, otherwise
                    the operation will fail.
                </note>

                <see><link to="#takeSnapshot"/></see>
            </desc>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="discardSavedState">
            <desc>
                Discards (deletes) the saved state of the virtual machine
                previously created by <link to="#saveState"/>. Next time the
                machine is powered up, a clean boot will occur.
                <note>
                    This operation is equivalent to resetting or powering off
                    the machine without doing a proper shutdown in the guest OS.
                </note>
            </desc>
        </method>

        <method name="getDeviceActivity">
            <desc>
                Gets the current activity type of a given device or device group.
            </desc>
            <param name="type" type="DeviceType" dir="in"/>
            <param name="activity" type="DeviceActivity" dir="return"/>
        </method>

        <method name="attachUSBDevice">
            <desc>
                Attaches a host USB device with the given UUID to the
                USB controller of the virtual machine.

                The device needs to be in one of the following states:
                <link to="USBDeviceState::USBDeviceBusy">USBDeviceBusy</link>,
                <link to="USBDeviceState::USBDeviceAvailable">USBDeviceAvailable</link> or
                <link to="USBDeviceState::USBDeviceHeld">USBDeviceHeld</link>,
                otherwise an error is immediately returned.

                When the device state is
                <link to="USBDeviceState::USBDeviceBusy">USBDeviceBusy</link>,
                an error may also be returned if the host computer
                refuses to release it for some reason.

                <see>IUSBController::DeviceFilters, USBDeviceState</see>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the host USB device to attach.</desc>
            </param>
        </method>

        <method name="detachUSBDevice">
            <desc>
                Detaches an USB device with the given UUID from the USB controller
                oif the virtual machine.

                After this method succeeds, the VirtualBox server reinitiates
                all USB filters as if the device were just physically attached
                to the host, but filters of this machine are ignored to avoid
                a possible automatic reattachment.

                <see>IUSBController::DeviceFilters, USBDeviceState</see>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the USB device to detach.</desc>
            </param>
            <param name="device" type="IUSBDevice" dir="return">
                <desc>Detached USB device.</desc>
            </param>
        </method>

        <method name="createSharedFolder">
            <desc>
                Creates a new shared folder by associating the given logical
                name with the given host path, adds it to the collection of
                shared folders and starts sharing it.
                Refer to the description of <link to="ISharedFolder"/> to read
                about logical name unicity.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Unique logical name of the shared folder.</desc>
            </param>
            <param name="hostPath" type="wstring" dir="in">
                <desc>Full path to the shared folder in the host file system.</desc>
            </param>
        </method>

        <method name="removeSharedFolder">
            <desc>
                Removes a shared folder with the given name previously created
                by <link to="#createSharedFolder"/> from the collection of
                shared folders and stops sharing it.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Logical name of the shared folder to remove.</desc>
            </param>
        </method>

        <method name="takeSnapshot">
            <desc>
                Saves the current execution state and all settings of the
                machine and creates differencing images for all
                normal (non-independent) hard disks.

                This method can be called for a PoweredOff, Saved, Running or
                Paused virtual machine. When the machine is PoweredOff, an
                offline <link to="ISnapshot">snapshot</link> is created,
                in all other cases -- an online snapshot.

                The taken snapshot is always based on the
                <link to="IMachine::currentSnapshot">current
                snapshot</link> of the associated virtual machine and becomes
                a new current snapshot.

                <note>This method implicitly calls <link
                to="IMachine::saveSettings"/> to save all current machine
                settings before taking an offline snapshot.</note>

                <see>ISnapshot, <link to="#saveState"/></see>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Short name for the snapshot.</desc>
            </param>
            <param name="description" type="wstring" dir="in">
                <desc>Optional description of the snapshot.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="discardSnapshot">
            <desc>

                Starts discarding the specified snapshot. The execution state
                and settings of the associated machine stored in the snapshot
                will be deleted. The contents of all differencing hard disks of
                this snapshot will be merged with the contents of their
                dependent child hard disks to keep the, disks valid (in other
                words, all changes represented by hard disks being discarded
                will be propagated to their child hard disks). After that, this
                snapshot's differencing hard disks will be deleted. The parent
                of this snapshot will become a new parent for all its child
                snapshots.

                If the discarded snapshot is the current one, its parent
                snapshot will become a new current snapshot. The current machine
                state is not directly affected in this case, except that
                currently attached differencing hard disks based on hard disks
                of the discarded snapshot will be also merged as described
                above.

                If the discarded snapshot is the first one (the root snapshot)
                and it has exactly one child snapshot, this child snapshot will
                become the first snapshot after discarding. If there are no
                children at all (i.e. the first snapshot is the only snapshot of
                the machine), both the current and the first snapshot of the
                machine will be set to null. In all other cases, the first
                snapshot cannot be discarded.

                You cannot discard the snapshot if it stores <link
                to="HardDiskType::NormalHardDisk">normal</link>
                (non-differencing) hard disks that have differencing hard disks
                based on them. Snapshots of such kind can be discarded only when
                every normal hard disk has either no children at all or exactly
                one child. In the former case, the normal hard disk simply
                becomes unused (i.e. not attached to any VM). In the latter
                case, it receives all the changes strored in the child hard
                disk, and then it replaces the child hard disk in the
                configuration of the corresponding snapshot or machine.

                Also, you cannot discard the snapshot if it stores hard disks
                (of any type) having differencing child hard disks that belong
                to other machines. Such snapshots can be only discarded after
                you discard all snapshots of other machines containing "foreign"
                child disks, or detach these "foreign" child disks from machines
                they are attached to.

                One particular example of the snapshot storing normal hard disks
                is the first snapshot of a virtual machine that had normal hard
                disks attached when taking the snapshot. Be careful when
                discarding such snapshots because this implicitly commits
                changes (made since the snapshot being discarded has been taken)
                to normal hard disks (as described above), which may be not what
                you want.

                The virtual machine is put to the <link
                to="MachineState::Discarding">Discarding</link> state until the
                discard operation is completed.

                <note>The machine must not be running, otherwise the operation
                will fail.</note>

                <note>
                    Child hard disks of all normal hard disks of the
                    discarded snapshot must be <link to="IHardDisk::accessible">
                    accessible</link> for this operation to succeed.
                    In particular, this means that all virtual machines,
                    whose hard disks are directly or indirectly based on
                    the hard disks of discarded snapshot, must be powered off.
                </note>
                <note>
                    Merging hard disk contents can be very time and disk space
                    consuming, if these disks are big in size and have many
                    children. However, if the snapshot being discarded is the last
                    (head) snapshot on the branch, the operation will be rather
                    quick.
                </note>
                <note>
                    Note that discarding the current snapshot
                    will imlicitly call <link to="IMachine::saveSettings()"/> to
                    make all current machine settings permanent.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the snapshot to discard.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="discardCurrentState">
            <desc>
                This operation is similar to <link to="#discardSnapshot()"/> but
                affects the current machine state. This means that the state stored
                in the current snapshot will become a new current state, and
                all current settings of the machine and changes stored in
                differencing hard disks will be lost.

                After this operation is successfully completed, new empty
                differencing hard disks are created for all normal hard disks
                of the machine.

                If the current snapshot of the machine is an online snapshot,
                the machine will go to the <link to="MachineState::Saved">
                saved state</link>, so that the next time it is powered on,
                the execution state will be restored from the current snapshot.

                <note>The machine must not be running, otherwise the operation
                will fail.</note>

                <note>If the machine state is <link
                to="MachineState::Saved">Saved</link> prior to this operation,
                the saved state file will be implicitly discarded (as if <link
                to="IConsole::discardSavedState()"/> were called).</note>

            </desc>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="discardCurrentSnapshotAndState">
            <desc>

                This method is equivalent to doing <link
                to="#discardSnapshot">discardSnapshot</link> (<link
                to="IMachine::currentSnapshot">currentSnapshot</link>.<link
                to="ISnapshot::id">id()</link>, ...) followed by <link
                to="#discardCurrentState()"/>.

                As a result, the machine will be fully restored from the
                snapshot preceeding the current snapshot, while both the current
                snapshot and the current machine state will be discarded.

                If the current snapshot is the first snapshot of the machine
                (i.e. it has the only snapshot), the current machine state will
                be discarded <b>before</b> discarding the snapshot. In other
                words, the machine will be restored from its last snapshot,
                before discarding it. This differs from performing a single
                <link to="#discardSnapshot()"/> call (note that no <link
                to="#discardCurrentState()"/> will be possible after it) to the
                effect that the latter will preserve the current state instead
                of discarding it.

                Unless explicitly mentioned otherwise, all remarks and
                limitations of the above two methods also apply to this method.

                <note>The machine must not be running, otherwise the operation
                will fail.</note>

                <note>If the machine state is <link
                to="MachineState::Saved">Saved</link> prior to this operation,
                the saved state file will be implicitly discarded (as if <link
                to="IConsole::discardSavedState()"/> were called).</note>

                <note>
                    This method is more efficient than calling two above
                    methods separately: it requires less IPC calls and provides
                    a single progress object.
                </note>

            </desc>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>
        </method>

        <method name="registerCallback">
            <desc>
                Registers a new console callback on this instance. The methods of the
                callback interface will be called by this instance when the appropriate
                event occurs.
            </desc>
            <param name="callback" type="IConsoleCallback" dir="in"/>
        </method>

        <method name="unregisterCallback">
            <desc>
                Unregisters the console callback previously registered using
                <link to="#registerCallback"/>.
            </desc>
            <param name="callback" type="IConsoleCallback" dir="in"/>
        </method>

    </interface>

    <!--
    // IHost
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IHostDVDDrive" extends="$unknown"
        uuid="c2308775-85f3-45ab-ade5-97f02d1e61e0"
        wsmap="struct"
    >
        <attribute name="name" type="wstring" readonly="yes">
            <desc>Returns the platform device identifier.</desc>
        </attribute>

    </interface>

    <enumerator
        name="IHostDVDDriveEnumerator" type="IHostDVDDrive"
        uuid="1ed7cfaf-c363-40df-aa4e-89c1afb7d96b"
    />

    <collection
        name="IHostDVDDriveCollection" type="IHostDVDDrive"
        enumerator="IHostDVDDriveEnumerator"
        uuid="1909c533-1a1e-445f-a4e1-a267cffc30ed"
        readonly="yes"
    >
        <method name="findByName">
            <desc>
                Searches this collection for a host drive with the given name.
                <note>
                    The method returns an error if the given name does not
                    correspond to any host drive in the collection.
                </note>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Name of the host drive to search for</desc>
            </param>
            <param name="drive" type="IHostDVDDrive" dir="return">
                <desc>Found host drive object</desc>
            </param>
        </method>
    </collection>

    <interface
        name="IHostFloppyDrive" extends="$unknown"
        uuid="2b2ad1ab-2ea9-4cf8-be3c-2a76677d8725"
        wsmap="struct"
    >
        <attribute name="name" type="wstring" readonly="yes">
            <desc>Returns the platform device identifier.</desc>
        </attribute>
    </interface>

    <enumerator
        name="IHostFloppyDriveEnumerator" type="IHostFloppyDrive"
        uuid="ce04c924-4f54-432a-9dec-11fddc3ea875"
    />

    <collection
        name="IHostFloppyDriveCollection" type="IHostFloppyDrive"
        enumerator="IHostFloppyDriveEnumerator"
        uuid="fd84bb86-c59a-4037-a557-755ff263a460"
        readonly="yes"
    >
        <method name="findByName">
            <desc>
                Searches this collection for a host drive with the given name.
                <note>
                    The method returns an error if the given name does not
                    correspond to any host drive in the collection.
                </note>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Name of the host drive to search for</desc>
            </param>
            <param name="drive" type="IHostFloppyDrive" dir="return">
                <desc>Found host drive object</desc>
            </param>
        </method>
    </collection>

<if target="midl">
    <interface
        name="IHostNetworkInterface" extends="$unknown"
        uuid="F4512D7C-B074-4e97-99B8-6D2BD27C3F5A"
        wsmap="uuid"
    >
        <attribute name="name" type="wstring" readonly="yes">
            <desc>Returns the host network interface name.</desc>
        </attribute>

        <attribute name="id" type="uuid" readonly="yes">
            <desc>Returns the interface UUID.</desc>
        </attribute>
    </interface>

    <enumerator
        name="IHostNetworkInterfaceEnumerator" type="IHostNetworkInterface"
        uuid="7B52FEF7-56E8-4aec-92F5-15E6D11EC630"
    />

    <collection
        name="IHostNetworkInterfaceCollection" type="IHostNetworkInterface"
        enumerator="IHostNetworkInterfaceEnumerator"
        uuid="BF1D41F2-B97B-4314-A0FB-D4823AF42FB5"
        readonly="yes"
    >
        <method name="findByName">
            <desc>
                Searches this collection for a host network interface with the given name.
                <note>
                    The method returns an error if the given name does not
                    correspond to any host network interface in the collection.
                </note>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Name of the host network interface to search for.</desc>
            </param>
            <param name="networkInterface" type="IHostNetworkInterface" dir="return">
                <desc>Found host network interface object.</desc>
            </param>
        </method>
        <method name="findById">
            <desc>
                Searches this collection for a host network interface with the given GUID.
                <note>
                    The method returns an error if the given GUID does not
                    correspond to any host network interface in the collection.
                </note>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>GUID of the host network interface to search for.</desc>
            </param>
            <param name="networkInterface" type="IHostNetworkInterface" dir="return">
                <desc>Found host network interface object.</desc>
            </param>
        </method>
    </collection>
</if>

    <interface
        name="IHost" extends="$unknown"
        uuid="FD443EC1-000B-4F5B-9282-D72760A66916"
        wsmap="global"
    >
        <attribute name="DVDDrives" type="IHostDVDDriveCollection" readonly="yes">
            <desc>List of DVD drives available on the host.</desc>
        </attribute>

        <attribute name="floppyDrives" type="IHostFloppyDriveCollection" readonly="yes">
            <desc>List of floppy drives available on the host.</desc>
        </attribute>

        <attribute name="USBDevices" type="IHostUSBDeviceCollection" readonly="yes">
            <desc>
                List of USB devices currently attached to the host.
                Once a new device is physically attached to the host computer,
                it appears in this list and remains there until detached.
            </desc>
        </attribute>

        <attribute name="USBDeviceFilters" type="IHostUSBDeviceFilterCollection" readonly="yes">
            <desc>
                List of USB device filters in action.
                When a new device is physically attached to the host computer,
                filters from this list are applied to it (in order they are stored
                in the list). The first matched filter will determine the
                <link to="IHostUSBDeviceFilter::action">action</link>
                performed on the device.

                Unless the device is ignored by these filters, filters of all
                currently running virtual machines
                (<link to="IUSBController::DeviceFilters"/>) are applied to it.

                <see>IHostUSBDeviceFilter, USBDeviceState</see>
            </desc>
        </attribute>

<if target="midl">
        <attribute name="networkInterfaces" type="IHostNetworkInterfaceCollection" readonly="yes">
            <desc>List of host network interfaces currently defined on the host.</desc>
        </attribute>
</if>

        <attribute name="processorCount" type="unsigned long" readonly="yes">
            <desc>Number of (logical) CPUs installed in the host system.</desc>
        </attribute>

        <attribute name="processorSpeed" type="unsigned long" readonly="yes">
            <desc>(Approximate) speed of the host CPU in Megahertz.</desc>
        </attribute>

        <attribute name="processorDescription" type="wstring" readonly="yes">
            <desc>Description string of the host CPU.</desc>
        </attribute>

        <attribute name="memorySize" type="unsigned long" readonly="yes">
            <desc>Amount of system memory in megabytes installed in the host system.</desc>
        </attribute>

        <attribute name="memoryAvailable" type="unsigned long" readonly="yes">
            <desc>Available system memory in the host system.</desc>
        </attribute>

        <attribute name="operatingSystem" type="wstring" readonly="yes">
            <desc>Name of the host system's operating system.</desc>
        </attribute>

        <attribute name="OSVersion" type="wstring" readonly="yes">
            <desc>Host operating system's version string.</desc>
        </attribute>

        <attribute name="UTCTime" type="long long" readonly="yes">
            <desc>Returns the current host time in milliseconds since 1970-01-01 UTC.</desc>
        </attribute>

<if target="midl">
        <method name="createHostNetworkInterface">
            <desc>
                Creates a new adapter for Host Interface Networking.
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>
                    Adapter name.
                </desc>
            </param>
            <param name="hostInterface" type="IHostNetworkInterface" dir="out">
                <desc>
                    Created host interface object.
                </desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>
                    Progress object to track the operation completion.
                </desc>
            </param>
        </method>
        <method name="removeHostNetworkInterface">
            <desc>
                Removes the given host network interface.
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>
                    Adapter GUID.
                </desc>
            </param>
            <param name="hostInterface" type="IHostNetworkInterface" dir="out">
                <desc>
                    Removed host interface object.
                </desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>
                    Progress object to track the operation completion.
                </desc>
            </param>
        </method>
</if>

        <method name="createUSBDeviceFilter">
            <desc>
                Creates a new USB device filter. All attributes except
                the filter name are set to <tt>null</tt> (any match),
                <i>active</i> is <tt>false</tt> (the filter is not active).

                The created filter can be added to the list of filters using
                <link to="#insertUSBDeviceFilter()"/>.

                <see>#USBDeviceFilters</see>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>
                    Filter name. See <link to="IHostUSBDeviceFilter::name"/>
                    for more info.
                </desc>
            </param>
            <param name="filter" type="IHostUSBDeviceFilter" dir="out">
                <desc>Created filter object.</desc>
            </param>
        </method>

        <method name="insertUSBDeviceFilter">
            <desc>
                Inserts the given USB device to the specified position
                in the list of filters.

                Positions are numbered starting from <tt>0</tt>. If the specified
                position is equal to or greater than the number of elements in
                the list, the filter is added to the end of the collection.

                <note>
                    Duplicates are not allowed, so an attempt to insert a
                    filter that is already in the list, will return an
                    error.
                </note>

                <see>#USBDeviceFilters</see>
            </desc>
            <param name="position" type="unsigned long" dir="in">
                <desc>Position to insert the filter to.</desc>
            </param>
            <param name="filter" type="IHostUSBDeviceFilter" dir="in">
                <desc>USB device filter to insert.</desc>
            </param>
        </method>

        <method name="removeUSBDeviceFilter">
            <desc>
                Removes a USB device filter from the specified position in the
                list of filters.

                Positions are numbered starting from <tt>0</tt>. Specifying a
                position equal to or greater than the number of elements in
                the list will produce an error.

                <see>#USBDeviceFilters</see>
            </desc>
            <param name="position" type="unsigned long" dir="in">
                <desc>Position to remove the filter from.</desc>
            </param>
            <param name="filter" type="IHostUSBDeviceFilter" dir="out">
                <desc>Removed USB device filter.</desc>
            </param>
        </method>

    </interface>

    <!--
    // ISystemProperties
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="ISystemProperties"
        extends="$unknown"
        uuid="6dc28c62-7924-43de-8336-fa754aa531d7"
        wsmap="struct"
    >
        <desc>
            The ISystemProperties interface represents global properties
            of the given VirtualBox installation.

            These properties define limits and default values for various
            attributes and parameters.

            Most of the properties are read-only, but some can be changed by
            a user.
        </desc>

        <attribute name="minGuestRAM" type="unsigned long" readonly="yes">
            <desc>Minium guest system memory in Megabytes.</desc>
        </attribute>

        <attribute name="maxGuestRAM" type="unsigned long" readonly="yes">
            <desc>Maximum guest system memory in Megabytes.</desc>
        </attribute>

        <attribute name="minGuestVRAM" type="unsigned long" readonly="yes">
            <desc>Minimum guest video memory in Megabytes.</desc>
        </attribute>

        <attribute name="maxGuestVRAM" type="unsigned long" readonly="yes">
            <desc>Maximum guest video memory in Megabytes.</desc>
        </attribute>

        <attribute name="maxVDISize" type="unsigned long long" readonly="yes">
            <desc>Maximum size of a virtual disk image in Megabytes.</desc>
        </attribute>

        <attribute name="networkAdapterCount" type="unsigned long" readonly="yes">
            <desc>
                Number of network adapters associated with every
                <link to="IMachine"/> instance.
            </desc>
        </attribute>

        <attribute name="maxBootPosition" type="unsigned long" readonly="yes">
            <desc>
                Maximum device position in the boot order. This value corresponds
                to the total number of devices a machine can boot from, to make it
                possible to include all possible devices to the boot list.
                <see><link to="IMachine::setBootOrder()"/></see>
            </desc>
        </attribute>

        <attribute name="defaultVDIFolder" type="wstring">
            <desc>
                Full path to the default directory used to create new or open
                existing virtual disk images when an image file name contains no
                path.

                The initial value of this property is
                <tt>&lt;</tt><link to="IVirtualBox::homeFolder">
                VirtualBox_home</link><tt>&gt;/VDI</tt>.

                <note>
                    Setting this property to <tt>null</tt> will restore the
                    initial value.
                </note>
                <note>
                    When settings this property, the specified path can be
                    absolute (full path) or relative
                    to the <link to="IVirtualBox::homeFolder">
                    VirtualBox home directory</link>.
                    When reading this property, a full path is
                    always returned.
                </note>
                <note>
                    The specified path may not exist, it will be created
                    when necessary.
                </note>

                <see>
                    <link to="IVirtualBox::createHardDisk()"/>,
                    <link to="IVirtualBox::openVirtualDiskImage()"/>
                </see>
            </desc>
        </attribute>

        <attribute name="defaultMachineFolder" type="wstring">
            <desc>
                Full path to the default directory used to create new or open
                existing machines when a settings file name contains no
                path.

                The initial value of this property is
                <tt>&lt;</tt><link to="IVirtualBox::homeFolder">
                VirtualBox_home</link><tt>&gt;/Machines</tt>.

                <note>
                    Setting this property to <tt>null</tt> will restore the
                    initial value.
                </note>
                <note>
                    When settings this property, the specified path can be
                    absolute (full path) or relative
                    to the <link to="IVirtualBox::homeFolder">
                    VirtualBox home directory</link>.
                    When reading this property, a full path is
                    always returned.
                </note>
                <note>
                    The specified path may not exist, it will be created
                    when necessary.
                </note>

                <see>
                    <link to="IVirtualBox::createMachine()"/>,
                    <link to="IVirtualBox::openMachine()"/>
                </see>
            </desc>
        </attribute>

        <attribute name="remoteDisplayAuthLibrary" type="wstring">
            <desc>
                Path to the library that provides authentication
                for VRDP clients. The library is used if authentication
                type is set to "external" in the VM RemoteDisplay
                configuration.

                The initial value of this property is <tt>VRDPAuth</tt>.
                That is library called VRDPAuth in one of default library
                directories. A full path can be used as well.

                <note>
                    The library name does not include the file extension.
                </note>
                <note>
                    Setting this property to <tt>null</tt> will restore the
                    initial value.
                </note>
            </desc>
        </attribute>

        <attribute name="HWVirtExEnabled" type="boolean">
            <desc>
                This specifies the default value for hardware virtualization
                extensions. If enabled, virtual machines will make use of
                hardware virtualization extensions such as Intel VT-x and
                AMD SVM by default. This value can be overridden by each VM
                using their <link to="IMachine::HWVirtExEnabled"/> property.
            </desc>
        </attribute>

    </interface>

    <!--
    // IGuest
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IGuestOSType" extends="$unknown"
        uuid="da94f478-1f37-4726-b750-2235950dc2fe"
        wsmap="struct"
    >
        <attribute name="id" type="wstring" readonly="yes">
            <desc>Guest OS identifier string.</desc>
        </attribute>

        <attribute name="description" type="wstring" readonly="yes">
            <desc>Human readable description of the guest OS.</desc>
        </attribute>

        <attribute name="recommendedRAM" type="unsigned long" readonly="yes">
            <desc>Recommended RAM size in Megabytes.</desc>
        </attribute>

        <attribute name="recommendedVRAM" type="unsigned long" readonly="yes">
            <desc>Recommended video RAM size in Megabytes.</desc>
        </attribute>

        <attribute name="recommendedHDD" type="unsigned long" readonly="yes">
            <desc>Recommended hard disk size in Megabytes.</desc>
        </attribute>
    </interface>


    <enumerator
        name="IGuestOSTypeEnumerator" type="IGuestOSType"
        uuid="a3335e02-4669-4e3c-80c7-c4dc7056a07c"
    />

    <collection
        name="IGuestOSTypeCollection" type="IGuestOSType" enumerator="IGuestOSTypeEnumerator"
        uuid="a5e36749-a610-498b-9f29-2e36c1042d65"
        readonly="yes"
    />

    <interface
        name="IGuest" extends="$unknown"
        uuid="FD443EC1-000E-4F5B-9282-D72760A66916"
        wsmap="suppress"
    >
        <desc>
            The IGuest interface represents a guest (virtual machine's) operating
            system. It provides information about the Guest Additions and other
            guest OS properties.

            <see>IConsole::guest</see>
        </desc>

        <attribute name="OSType" type="IGuestOSType" readonly="yes">
            <desc>
                Guest OS type as reported by the Guest Additions.
                <note>
                    If Guest Additions are not installed, this value will be
                    the same as <link to="IMachine::OSType"/>.
                </note>
            </desc>
        </attribute>

        <attribute name="additionsActive" type="boolean" readonly="yes">
            <desc>
                Flag whether the Guest Additions are installed and active
                in which case their version will be returned by the
                <link to="#additionsVersion"/> property.
            </desc>
        </attribute>

        <attribute name="additionsVersion" type="wstring" readonly="yes">
            <desc>
                Version of the Guest Additions (3 decimal numbers separated
                by dots) or empty when the Additions are not installed. The
                Additions may also report a version but yet not be active as
                the version might be refused by VirtualBox (incompatible) or
                other failures occured.
            </desc>
        </attribute>

        <method name="setCredentials">
            <desc>
                Store login credentials that can be queried by guest operating
                systems with Additions installed. The credentials are transient
                to the session and the guest may also choose to erase them. Note
                that the caller cannot determine whether the guest operating system
                has queried or made use of the credentials.
            </desc>
            <param name="userName" type="wstring" dir="in">
                <desc>User name string, can be empty</desc>
            </param>
            <param name="password" type="wstring" dir="in">
                <desc>Password string, can be empty</desc>
            </param>
            <param name="domain" type="wstring" dir="in">
                <desc>Domain name (guest logon scheme specific), can be emtpy</desc>
            </param>
            <param name="allowInteractiveLogon" type="boolean" dir="in">
                <desc>
                    Flag whether the guest should alternatively allow the user to
                    interactively specify different credentials. This flag might
                    not be supported by all versions of the Additions.
                </desc>
            </param>
        </method>

    </interface>


    <!--
    // IProgress
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="IProgressEnumerator" type="IProgress"
        uuid="e0380522-4ef1-48f4-856c-e455177ccb2d"
    />

    <collection
        name="IProgressCollection" type="IProgress" enumerator="IProgressEnumerator"
        uuid="78B76A7C-F0F2-467c-9F0E-F089A54EE957"
        readonly="yes"
    />

    <interface
        name="IProgress" extends="$unknown"
        uuid="10CC03A1-717E-429b-992D-C67B56175A51"
        wsmap="uuid"
    >
        <desc>
            The IProgress interface represents a task progress object that allows
            to wait for the completion of some asynchronous task.

            The task consists of one or more operations that run sequentially,
            one after one. There is an individual percent of completion of the
            current operation and the percent of completion of the task as a
            whole. Similarly, you can wait for the completion of a particular
            operation or for the completion of the whole task.

            Every operation is identified by a number (starting from 0)
            and has a separate description.
        </desc>

        <attribute name="id" type="uuid" readonly="yes">
            <desc>ID of the task.</desc>
        </attribute>

        <attribute name="description" type="wstring" readonly="yes">
            <desc>Description of the task.</desc>
        </attribute>

        <attribute name="initiator" type="$unknown" readonly="yes">
            <desc>Initiator of the task.</desc>
        </attribute>

        <attribute name="cancelable" type="boolean" readonly="yes">
            <desc>Whether the task can be interrupted.</desc>
        </attribute>

        <attribute name="percent" type="long" readonly="yes">
            <desc>
                Current task progress value in percent.
                This value depends on how many operations are already complete.
            </desc>
        </attribute>

        <attribute name="completed" type="boolean" readonly="yes">
            <desc>Whether the task has been completed.</desc>
        </attribute>

        <attribute name="canceled" type="boolean" readonly="yes">
            <desc>Whether the task has been canceled.</desc>
        </attribute>

        <attribute name="resultCode" type="result" readonly="yes">
            <desc>
                Result code of the progress task.
                Valid only if <link to="#completed"/> is true.
            </desc>
        </attribute>

        <attribute name="errorInfo" type="IVirtualBoxErrorInfo" readonly="yes">
            <desc>
                Extended information about the unsuccessful result of the
                progress operation. May be NULL when no extended information
                is available.
                Valid only if <link to="#completed"/> is true and
                <link to="#resultCode"/> indicates a failure.
            </desc>
        </attribute>

        <attribute name="operationCount" type="unsigned long" readonly="yes">
            <desc>
                Number of operations this task is divided into.
                Every task consists of at least one operation.
            </desc>
        </attribute>

        <attribute name="operation" type="unsigned long" readonly="yes">
            <desc>Number of the operation being currently executed.</desc>
        </attribute>

        <attribute name="operationDescription" type="wstring" readonly="yes">
            <desc>
                Description of the operation being currently executed.
            </desc>
        </attribute>

        <attribute name="operationPercent" type="long" readonly="yes">
            <desc>Current operation progress value in percent.</desc>
        </attribute>

        <method name="waitForCompletion">
            <desc>
                Waits until the task is done (including all operations) with a
                given timeout.
            </desc>
            <param name="timeout" type="long" dir="in">
                <desc>
                    Timeout value in milliseconds.
                    Specify -1 for an indefinite wait.
                </desc>
            </param>
        </method>

        <method name="waitForOperationCompletion">
            <desc>
                Waits until the given operation is done with a given timeout.
            </desc>
            <param name="operation" type="unsigned long" dir="in">
                <desc>
                    Number of the operation to wait for.
                    Must be less than <link to="#operationCount"/>.
                </desc>
            </param>
            <param name="timeout" type="long" dir="in">
                <desc>
                    Timeout value in milliseconds.
                    Specify -1 for an indefinite wait.
                </desc>
            </param>
        </method>

        <method name="cancel">
            <desc>
                Cancels the task.
                <note>
                    If <link to="#cancelable"/> is <tt>false</tt>, then
                    this method will fail.
                </note>
            </desc>
        </method>

    </interface>


    <!--
    // ISnapshot
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="ISnapshotEnumerator" type="ISnapshot"
        uuid="25cfa2a4-1f1d-4f05-9658-b7a5894ef1a3"
    />

    <collection
        name="ISnapshotCollection" type="ISnapshot"
        enumerator="ISnapshotEnumerator"
        uuid="23852e3c-94cd-4801-ab05-ed35675b3894"
        readonly="yes"
    />

    <interface
        name="ISnapshot" extends="$unknown"
        uuid="9f1bbf79-13b0-4da2-abba-4a992c65c083"
        wsmap="uuid"
    >
        <desc>
            The ISnapshot interface represents a snapshot of the virtual
            machine.

            The <i>snapshot</i> stores all the information about a virtual
            machine necessary to bring it to exactly the same state as it was at
            the time of taking the snapshot. The snapshot includes:

            <ul>
            <li>all settings of the virtual machine (i.e. its hardware
            configuration: RAM size, attached hard disks, etc.)
            </li>
            <li>the execution state of the virtual machine (memory contents,
            CPU state, etc.).
            </li>
            </ul>

            Snapshots can be <i>offline</i> (taken when the VM is powered off)
            or <i>online</i> (taken when the VM is running). The execution
            state of the offline snapshot is called a <i>zero execution state</i>
            (it doesn't actually contain any information about memory contents
            or the CPU state, assuming that all hardware is just powered off).

            <h3>Snapshot branches</h3>

            Snapshots can be chained. Chained snapshots form a branch where
            every next snapshot is based on the previous one. This chaining is
            mostly related to hard disk branching (see <link to="IHardDisk"/>
            description). This means that every time a new snapshot is created,
            a new differencing hard disk is implicitly created for all normal
            hard disks attached to the given virtual machine. This allows to
            fully restore hard disk contents when the machine is later reverted
            to a particular snapshot.

            In the current implelemtation, multiple snapshot branches within one
            virtual machine are not allowed. Every machine has a signle branch,
            and <link to="IConsole::takeSnapshot()"/> operation adds a new
            snapshot to the top of that branch.

            Existings snapshots can be discarded using
            <link to="IConsole::discardSnapshot()"/>.

            <h3>Current snapshot</h3>

            Every virtual machine has a current snapshot, identified by
            <link to="IMachine::currentSnapshot"/>. This snapshot is used as
            a base for the <i>current machine state</i> (see below), to the effect
            that all normal hard disks of the machine and its execution
            state are based on this snapshot.

            In the current implementation, the current snapshot is always the
            last taken snapshot (i.e. the head snapshot on the branch) and it
            cannot be changed.

            The current snapshot is <tt>null</tt> if the machine doesn't have
            snapshots at all; in this case the current machine state is just
            current settings of this machine plus its current execution state.

            <h3>Current machine state</h3>

            The current machine state is what represened by IMachine instances
            got directly from IVirtualBox using <link
            to="IVirtualBox::getMachine()">getMachine()</link>, <link
            to="IVirtualBox::findMachine()">findMachine()</link>, etc. (as
            opposed to instances returned by <link to="ISnapshot::machine"/>).
            This state is always used when the machine is <link
            to="IConsole::powerUp"> powered on</link>.

            The current machine state also includes the current execution state.
            If the machine is being currently executed
            (<link to="IMachine::state"/> is <link to="MachineState::Running"/>
            and above), its execution state is just what's happening now.
            If it is powered off (<link to="MachineState::PoweredOff"/> or
            <link to="MachineState::Aborted"/>), it has a zero execution state.
            If the machine is saved (<link to="MachineState::Saved"/>), its
            execution state is what saved in the execution state file
            (<link to="IMachine::stateFilePath"/>).

            If the machine is in the saved state, then, next time it is powered
            on, its execution state will be fully restored from the saved state
            file and the execution will continue from the point where the state
            was saved.

            Similarly to snapshots, the current machine state can be discarded
            using <link to="IConsole::discardCurrentState()"/>.

            <h3>Taking and discarding snapshots</h3>

            The table below briefly explains the meaning of every snapshot
            operation:

            <table>
            <tr><th>Operation</th><th>Meaning</th><th>Remarks</th></tr>

            <tr><td><link to="IConsole::takeSnapshot()"/></td>

            <td>Save the current state of the virtual machine, including all
            settings, contents of normal hard disks and the current modifications
            to immutable hard disks (for online snapshots)</td>

            <td>The current state is not changed (the machine will continue
            execution if it is being executed when the snapshot is
            taken)</td></tr>

            <tr><td><link to="IConsole::discardSnapshot()"/></td>

            <td>Forget the state of the virtual machine stored in the snapshot:
            dismiss all saved settings and delete the saved execution state (for
            online snapshots)</td>

            <td>Other snapshots (including child snapshots, if any) and the
            current state are not directly affected</td></tr>

            <tr><td><link to="IConsole::discardCurrentState()"/></td>

            <td>Restore the current state of the virtual machine from the state
            stored in the current snapshot, including all settings and hard disk
            contents</td>

            <td>The current state of the machine existed prior to this operation
            is lost</td></tr>

            <tr><td><link to="IConsole::discardCurrentSnapshotAndState()"/></td>

            <td>Completely revert the virtual machine to the state it was in
            before the current snapshot has been taken</td>

            <td>The current state, as well as the current snapshot, are
            lost</td></tr>

            </table>

        </desc>

        <attribute name="id" type="uuid" readonly="yes">
            <desc>UUID of the snapshot.</desc>
        </attribute>

        <attribute name="name" type="wstring">
            <desc>Short name of the snapshot.</desc>
        </attribute>

        <attribute name="description" type="wstring">
            <desc>Optional description of the snapshot.</desc>
        </attribute>

        <attribute name="timeStamp" type="long long" readonly="yes">
            <desc>
                Time stamp of the snapshot, in milliseconds since 1970-01-01 UTC.
            </desc>
        </attribute>

        <attribute name="online" type="boolean" readonly="yes">
            <desc>
                <tt>true</tt> if this snapshot is an online snapshot and
                <tt>false</tt> otherwise.

                <note>
                    When this attribute is <tt>true</tt>, the
                    <link to="IMachine::stateFilePath"/> attribute of the
                    <link to="#machine"/> object associated with this snapshot
                    will point to the saved state file. Otherwise, it will be
                    <tt>null</tt>.
                </note>
            </desc>
        </attribute>

        <attribute name="machine" type="IMachine" readonly="yes">
            <desc>
                Virtual machine this snapshot is taken on. This object
                stores all settings the machine had when taking this snapshot.
                <note>
                    The returned machine object is immutable, i.e. no
                    any settings can be changed.
                </note>
            </desc>
        </attribute>

        <attribute name="parent" type="ISnapshot" readonly="yes">
            <desc>
                Parent snapshot (a snapshot this one is based on).
                <note>
                    It's not an error to read this attribute on a snapshot
                    that doesn't have a parent -- a null object will be
                    returned to indicate this.
                </note>
            </desc>
        </attribute>

        <attribute name="children" type="ISnapshotCollection" readonly="yes">
            <desc>
                Child snapshots (all snapshots having this one as a parent).
                <note>
                    In the current implementation, there can be only one
                    child snapshot, or no children at all, meaning this is the
                    last (head) snapshot.
                </note>
            </desc>
        </attribute>

    </interface>

    <!--
    // IHardDisk
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="HardDiskStorageType"
        uuid="48138584-ad99-479d-a36f-eb82a7663685"
    >
        <desc>
            Virtual hard disk storage type.
            <see>IHardDisk</see>
        </desc>
        <const name="VirtualDiskImage" value="0">
            <desc>
                Virtual Disk Image, VDI (a regular file in the file
                system of the host OS, see <link to="IVirtualDiskImage"/>)
            </desc>
        </const>
        <const name="ISCSIHardDisk" value="1">
            <desc>
                iSCSI Remote Disk (a disk accessed via the Internet
                SCSI protocol over a TCP/IP network, see
                <link to="IISCSIHardDisk"/>)
            </desc>
        </const>
        <const name="VMDKImage" value="2">
            <desc>
                WMware Virtual Machine Disk image (a regular file in the file
                system of the host OS, see <link to="IVMDKImage"/>)
            </desc>
        </const>
    </enum>

    <enum
        name="HardDiskType"
        uuid="a348fafd-a64e-4643-ba65-eb3896bd7e0a"
    >
        <desc>
            Virtual hard disk type.
            <see>IHardDisk</see>
        </desc>
        <const name="NormalHardDisk" value="0">
            <desc>
                Normal hard disk (attached directly or indirectly, preserved
                when taking snapshots).
            </desc>
        </const>
        <const name="ImmutableHardDisk" value="1">
            <desc>
                Immutable hard disk (attached indirectly, changes are wiped out
                after powering off the virtual machine).
            </desc>
        </const>
        <const name="WritethroughHardDisk" value="2">
            <desc>
                Write through hard disk (attached directly, ignored when
                taking snapshots).
            </desc>
        </const>
    </enum>

    <interface
        name="IHardDiskAttachment" extends="$unknown"
        uuid="c0ffe596-21c6-4797-8d8a-b47b66881e7a"
        wsmap="struct"
    >
        <attribute name="hardDisk" type="IHardDisk" readonly="yes">
            <desc>Harddisk object this attachment is about.</desc>
        </attribute>

        <attribute name="controller" type="DiskControllerType" readonly="yes">
            <desc>Disk controller ID of this attachment.</desc>
        </attribute>

        <attribute name="deviceNumber" type="long" readonly="yes">
            <desc>Device number of the attachment.</desc>
        </attribute>

    </interface>

    <enumerator
        name="IHardDiskAttachmentEnumerator" type="IHardDiskAttachment"
        uuid="9955e486-2f0b-432a-99e4-0ebbd338875e"
    />

    <collection
        name="IHardDiskAttachmentCollection" type="IHardDiskAttachment"
        enumerator="IHardDiskAttachmentEnumerator"
        uuid="8f727842-bb77-45d4-92de-4ec14bf613c9"
        readonly="yes"
    />

    <enumerator
        name="IHardDiskEnumerator" type="IHardDisk"
        uuid="b976f97b-cdb8-47e3-9860-084031cbd533"
    />

    <collection
        name="IHardDiskCollection" type="IHardDisk"
        enumerator="IHardDiskEnumerator"
        uuid="43EAC2BC-5C61-40fa-BC38-46DE2C7DB6BB"
        readonly="yes"
    />

    <interface
        name="IHardDisk" extends="$unknown"
        uuid="FD443EC1-000F-4F5B-9282-D72760A66916"
        wsmap="uuid"
    >
        <desc>
            The IHardDisk interface represents a virtual hard disk drive
            used by virtual machines.

            The virtual hard disk drive virtualizes the hard disk hardware and
            looks like a regular hard disk inside the virtual machine and
            the guest OS.

            <h3>Storage Types</h3>

            The <link to="HardDiskStorageType">storage type</link> of the
            virtual hard disk determines where and how it stores its data
            (sectors). Currently, the following storage types are supported:

            <ul>

                <li><i>Virtual Disk Image (VDI)</i>, a regular file in the file
                system of the host OS (represented by the <link
                to="IVirtualDiskImage"/> interface). This file has a special
                format optimized so that unused sectors of data occupy much less
                space than on a physical hard disk.</li>

                <li><i>iSCSI Remote Disk</i>, a disk accessed via the Internet
                SCSI protocol over a TCP/IP network link (represented by the
                <link to="IISCSIHardDisk"/> interface).</li>

                <li><i>WMware VMDK Image</i>, a regular file in the file
                system of the host OS (represented by the <link
                to="IVMDKImage"/> interface).</li>

            </ul>

            The storage type of the particular hard disk object is indicated by
            the <link to="#storageType"/> property.

            Each storage type is represented by its own interface (as shown
            above), that allows to query and set properties and perform
            operations specific to that storage type. When an IHardDisk object
            reports it uses some particular storage type, it also guaranteed to
            support the corresponding interface which you can query. And vice
            versa, every object that supports a storage-specific interface, also
            supports IHardDisk.

            <h3>Virtual Hard Disk Types</h3>

            The <link to="HardDiskType">type</link> of the virtual hard disk
            determines how it is attached to the virtual machine when you call
            <link to="IMachine::attachHardDisk()"/> and what happens to it when
            a <link to="ISnapshot">snapshot</link> of the virtual machine is
            taken.

            There are three types of virtual hard disks:

            <ul>
                <li><i>Normal</i></li>
                <li><i>Immutable</i></li>
                <li><i>Writethrough</i></li>
            </ul>

            The virtual disk type is indicated by the <link to="#type"/>
            property. Each of the above types is described in detail further
            down.

            There is also a forth, "hidden" virtual disk type:
            <i>Differencing</i>. It is "hidden" because you cannot directly
            create hard disks of this type -- they are automatically created by
            VirtualBox when necessary.

            <b>Differencing Hard Disks</b>

            Unlike disks of other types (that are similar to real hard disks),
            the differencing hard disk does not store the full range of data
            sectors. Instead, it stores only a subset of sectors of some other
            disk that were changed since the differencing hard disk has been
            created. Thus, every differencing hard disk has a parent hard disk
            it is linked to, and represents the difference between the initial
            and the current hard disk state. A differencing hard disk can be
            linked to another differencing hard disk -- this way, differencing
            hard disks can form a branch of changes. More over, a given virtual
            hard disk can have more than one differencing hard disk linked to
            it.

            A disk the differencing hard disk is linked to (or, in other
            words, based on) is called a <i>parent</i> hard disk and is
            accessible through the <link to="#parent"/> property. Similarly, all
            existing differencing hard disks for a given parent hard disk are
            called its <i>child</i> hard disks (and accessible through the <link
            to="#children"/> property).

            All differencing hard disks use Virtual Disk Image files to store
            changed sectors. They have the <link to="#type"/> property set to
            Normal, but can be easily distinguished from normal hard disks using
            the <link to="#parent"/> property: all differencing hard disks have
            a parent, while all normal hard disks don't.

            When the virtual machine makes an attempt to read a sector that is
            missing in a differencing hard disk, its parent is accessed to
            resolve the sector in question. This process continues until the
            sector is found, or until the root hard disk is encountered, which
            always contains all sectors. As a consequence,

            <ul>

                <li>The virtual hard disk geometry seen by the guest OS is
                always defined by the root hard disk.</li>

                <li>All hard disks on a branch, up to the root, must be <link
                to="#accessible"/> for a given differencing hard disk in order
                to let it function properly when the virtual machine is
                running.</li>

            </ul>

            Differencing hard disks can be implicitly created by VirtualBox in
            the following cases:

            <ul>

                <li>When a hard disk is <i>indirectly</i> attached to the
                virtual machine using <link to="IMachine::attachHardDisk()"/>.
                In this case, all disk writes performed by the guest OS will go
                to the created diffferencing hard disk, as opposed to the
                <i>direct</i> attachment, where all changes are written to the
                attached hard disk itself.</li>

                <li>When a <link to="ISnapshot">snapshot</link> of the virtual
                machine is taken. After that, disk writes to hard disks the
                differencing ones have been created for, will be directed to
                those differencing hard disks, to preserve the contents of the
                original disks.</li>

            </ul>

            Whether to create a differencing hard disk or not depends on the
            type of the hard disk attached to the virtual machine. This is
            explained below.

            Note that in the current implementation, only the
            <link to="VirtualDiskImage"/> storage type is used to
            represent differencing hard disks. In other words, all
            differencing hard disks are <link to="IVirtualDiskImage"/>
            objects.

            <b>Normal Hard Disks</b>

            Normal hard disks are the most commonly used virtual hard disk. A
            normal hard disk is attached to the machine directly if it is not
            already attached to some other machine. Otherwise, an attempt to
            make an indirect attachment through a differencing hard disk will be
            made. This attempt will fail if the hard disk is attached to a
            virtual machine without snapshots (because it's impossible to create
            a differencing hard disk based on a hard disk that is subject to
            change).

            When an indirect attachment takes place, in the simplest case, where
            the machine the hard disk is being attached to doesn't have
            snapshots, the differencing hard disk will be based on the normal
            hard disk being attached. Otherwise, the first (i.e. the most
            recent) descendant of the given normal hard disk found in the
            current snapshot branch (starting from the current snapshot and
            going up to the root) will be actually used as a base.

            Note that when you detach an indirectly attached hard disk from the
            machine, the created differencing hard disk image is simply
            <b>deleted</b>, so <b>all changes are lost</b>. If you attach the
            same disk again, a clean differencing disk will be created based on
            the most recent child, as described above.

            When taking a snapshot, the contents of all normal hard disks (and
            all differencing disks whose roots are normal hard disks) currently
            attached to the virtual machine is preserved by creating
            differencing hard disks based on them.

            <b>Immutable Hard Disks</b>

            Immutable hard disks can be used to provide a sort of read-only
            access. An immutable hard disk is always attached indirectly. The
            created differencing hard disk is automatically wiped out (recreated
            from scratch) every time you power off the virtual machine. Thus,
            the contents of the immutable disk remains unchanged between runs.

            Detaching an immutable hard disk deletes the differencing disk
            created for it, with the same effect as in case with normal hard
            disks.

            When taking a snapshot, the differencing part of the immutable
            hard disk is cloned (i.e. copied to a separate Virtual Disk Image
            file) without any changes. This is necessary to preserve the exact
            virtual machine state when you create an online snapshot.

            <b>Writethrough Hard Disks</b>

            Hard disks of this type are always attached directly. This means
            that every given writethrough hard disk can be attached only to one
            virtual machine at a time.

            It is impossible to take a snapshot of a virtual machine with the
            writethrough hard disk attached, because taking a snapshot implies
            saving the execution state and preserving the contents of all hard
            disks, but writethrough hard disks cannot be preserved. Preserving
            hard disk contents is necessary to ensure the guest OS stored in the
            snapshot will get the same hard disk state when restored, which is
            especially important when it has open file handles or when there are
            cached files and directories stored in memory.

            <h3>Creating, Opening and Registering Hard Disks</h3>

            Non-differencing hard disks are either created from scratch using
            <link to="IVirtualBox::createHardDisk()"/> or opened from a VDI file
            using <link to="IVirtualBox::openVirtualDiskImage()"/> (only for
            hard disks using the VirtualDiskImage storage type). Once a hard
            disk is created or opened, it needs to be registered using <link
            to="IVirtualBox::registerHardDisk()"/> to make it available for
            attaching to virtual machines. See the documentation of individual
            interfaces for various storage types to get more information.

            Differencing hard disks are never created explicitly and cannot
            be registered or unregistered; they are automatically registered
            upon creation and deregistered when deleted.

            <h3>More about Indirect Hard Disk Attachments</h3>

            Normally, when you attach a hard disk to the virtual machine, and
            then query the corresponding attachment using <link
            to="IMachine::getHardDisk()"/> or <link
            to="IMachine::hardDiskAttachments"/> you will get the same hard disk
            object, whose UUID you passed earlier to <link
            to="IMachine::attachHardDisk()"/>. However, when an indirect
            attachment takes place, calling <link to="IMachine::getHardDisk()"/>
            will return a differencing hard disk object, that is either based on
            the attached hard disk or on another differencing hard disk, the
            attached hard disk is eventually a root for (as described above). In
            both cases the returned hard disk object is the object the virtual
            machine actually uses to perform disk writes to.

            Regardless of whether the attachment is direct or indirect, the
            <link to="#machineId"/> property of the attached disk will contain an
            UUID of the machine object <link to="IMachine::attachHardDisk()"/>
            has been called on.

            Note that both <link to="IMachine::attachHardDisk()"/> and <link
            to="IMachine::detachHardDisk()"/> are <i>lazy</i> operations. In
            particular, this means that when an indirect attachment is made,
            differencing hard disks are not created until machine settings are
            committed using <link to="IMachine::saveSettings()"/>. Similarly,
            when a differencing hard disk is detached, it is not deleted until
            <link to="IMachine::saveSettings()"/> is called. Calling <link
            to="IMachine::discardSettings()"/> cancels all lazy attachments or
            detachments made since the last commit and effectively restores the
            previous set of hard disks.

            <h3>Hard Disk Accessibility</h3>

            The <link to="#accessible"/> attribute of the hard disk object
            defines the accessibility state of the respective hard disk storage
            (for example, the VDI file for IVirtualDiskImage objects). If the
            value of this attribute is <tt>false</tt> then some hard disk
            attributes may contain invalid or outdated values (for example, the
            virtual or the actual hard disk size) until a new accessibility
            check is done that returns <tt>true</tt> (see the attribute
            description for more details).

            <note>
            Because of the possible slowness of the accessibility check,
            it is not implicitly performed upon the VirtualBox server startup
            (to prevent the application freeze). In partcular, this means that
            if you try to read hard disk properties that depend on the
            accessibility state without first reading the value of the
            <link to="#accessible"/> attribute and ensuring it's value is
            <tt>true</tt>, you will get wrong (zero) values.
            </note>

        </desc>

        <attribute name="id" type="uuid" readonly="yes">
            <desc>

                UUID of the hard disk. For newly created hard disk objects,
                this value is a randomly generated UUID.

            </desc>
        </attribute>

        <attribute name="description" type="wstring">
            <desc>

                Optional description of the hard disk. For a newly created hard
                disk, this value is <tt>null</tt>.

                <note>For some storage types, reading this property is
                meaningless when <link to="#accessible"/> is <tt>false</tt>.
                Also, you cannot assign it a new value in this case.</note>

            </desc>
        </attribute>

        <attribute name="storageType" type="HardDiskStorageType" readonly="yes">
            <desc>

                Storage type of this hard disk.

                Storage type is defined when you open or create a new hard disk
                object.

            </desc>
        </attribute>

        <attribute name="location" type="wstring" readonly="yes">
            <desc>

                Storage location of this hard disk. The returned string serves
                for informational purposes only. To access detailed information
                about the storage, query the appropriate storage-specific
                interface.

            </desc>
        </attribute>

        <attribute name="type" type="HardDiskType">
            <desc>

                Type (behavior) of this hard disk. For a newly created or opened
                hard disk, this value is <link
                to="HardDiskType::NormalHardDisk"/>.

                <note>In the current implementation, this property can be
                changed only on an unregistered hard disk object. This may be
                changed later.</note>

            </desc>
        </attribute>

        <attribute name="parent" type="IHardDisk" readonly="yes">
            <desc>

                Parent of this hard disk (a hard disk this one is directly based
                on).

                Only differencing hard disks have parents, so a <tt>null</tt>
                object is returned for a hard disk of any other type.
            </desc>
        </attribute>

        <attribute name="children" type="IHardDiskCollection" readonly="yes">
            <desc>

                Children of this hard disk (all differencing hard disks for
                those this one is a parent). An empty collection is returned, if
                this hard disk doesn't have any children.

            </desc>
        </attribute>

        <attribute name="root" type="IHardDisk" readonly="yes">
            <desc>

                Root hard disk of this hard disk. If this hard disk is a
                differencing hard disk, its root hard disk is the first disk on
                the branch. For all other types of hard disks, this property
                returns the hard disk object itself (i.e. the same object you
                read this property on).

            </desc>
        </attribute>

        <attribute name="accessible" type="boolean" readonly="yes">
            <desc>

                Whether the hard disk storage is currently accessible or not.
                The storage, for example, can be unaccessible if it doesn't exist
                or if it is placed on a network resource that is not available
                by the time this attribute is read.

                In the current implementation, the value of this property is
                also <tt>false</tt> if this hard disk is attached to a running
                virtual machine.

                The accessibility check is performed automatically every time
                this attribute is read. You should keep it in mind that this check
                may be slow and can block the calling thread for a long time (for
                example, if the network resourse where the hard disk storage is
                located is down).

                The following attributes of the hard disk object are considered
                to be invalid when this attribute is <tt>false</tt>:
                <ul>
                <li><link to="#size"/></li>
                <li><link to="#actualSize"/></li>
                </ul>
                Individual hard disk storage type interfaces may define
                additional attributes that depend on the accessibility state.
            </desc>
        </attribute>

        <attribute name="allAccessible" type="boolean" readonly="yes">
            <desc>

                Whether the whole hard disk branch, starting from this image and
                going through its ancestors up to the root, is accessible or
                not.

                This property makes sense only for differencing hard disks. For
                all other types of hard disks it returns the same value as
                <link to="#accessible"/>.

            </desc>
        </attribute>

        <attribute name="lastAccessError" type="wstring" readonly="yes">
            <desc>

                String describing the reason of inaccessibility of this hard
                disk after the last call to <link to="#accessible"/> that
                returned <tt>false</tt>. A <tt>null</tt> value of this property
                means that the last accessibility check returned <tt>true</tt>.

            </desc>
        </attribute>

        <attribute name="size" type="unsigned long long" readonly="yes">
            <desc>

                Logical size of this hard disk (in megabytes), as reported to the
                guest OS running inside the vurtual machine this disk is
                attached to. The logical size is defined when the hard disk is
                created.

                <note>Reading this property on a differencing hard disk will
                return the size of its root hard disk.</note>

                <note>Reading this property is meaningless when
                <link to="#accessible"/> is <tt>false</tt></note>

            </desc>
        </attribute>

        <attribute name="actualSize" type="unsigned long long" readonly="yes">
            <desc>

                Physical size of the storage used to store hard disk data (in
                bytes). This size is usually less than the logical size of the
                hard disk, depending on the storage type and on the size
                optimization method used for that storage.

                <note>Reading this property is meaningless when
                <link to="#accessible"/> is <tt>false</tt></note>

            </desc>
        </attribute>

        <attribute name="machineId" type="uuid" readonly="yes">
            <desc>

                UUID of the machine this hard disk is attached to (or a
                <tt>null</tt> UUID if it is not attached).

                <note>Immutable hard disks are never attached directly, so this
                attribute is always <tt>null</tt> in this case.</note>

            </desc>
        </attribute>

        <attribute name="snapshotId" type="uuid" readonly="yes">
            <desc>

                UUID of the <link to="ISnapshot">snapshot</link> this hard disk
                is associated with (or <tt>null</tt> UUID if it is not
                associated with any snapshot).

                <note>This attribute is always <tt>null</tt> if <link
                to="#machineId"/> is <tt>null</tt>.</note>

                <note>Writethrough hard disks are always attached directly and
                cannot be involved when taking snapshots, so this attribute is
                meaningless and therefore always <tt>null</tt>.</note>

            </desc>
        </attribute>

        <method name="cloneToImage">

            <desc>

                Starts creating a clone of this hard disk. The cloned hard disk
                will use the specified Virtual Disk Image file as a storage and
                will contain exactly the same sector data as the hard disk being
                cloned, except that a new UUID for the clone will be randomly
                generated.

                The specified image file path can be absolute (full path) or
                relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
                home directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to the image
                file.

                It is an error to use the object returned in the @a image
                parameter until the returned @a progress object reports success.

                <note>In the current implementation, only non-differencing hard
                disks can be cloned.</note>

            </desc>

            <param name="filePath" type="wstring" dir="in">
                <desc>Path to a file where to store the cloned hard disk.</desc>
            </param>
            <param name="image" type="IVirtualDiskImage" dir="out">
                <desc>Cloned hard disk object.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>

        </method>

    </interface>

    <!--
    // IVirtualDiskImage
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IVirtualDiskImage" extends="$unknown"
        uuid="a8265b5a-0d20-4a46-a02f-65693a4e8239"
        wsmap="uuid"
    >

        <desc>

            The IVirtualDiskImage interface represents <link
            to="IHardDisk">virtual hard disks</link> that use virtual disk image
            files to store hard disk data.

            Hard disks using virtual disk images can be either opened using
            <link to="IVirtualBox::openVirtualDiskImage()"/> or created from
            scratch using <link to="IVirtualBox::createHardDisk()"/>.

            Objects that support this interface also support the <link
            to="IHardDisk"/> interface.

            When a new hard disk object is created from scatch, an image file
            for it is not automatically created. To do it, you need to specify a
            valid <link to="#filePath">file path</link>, and call <link
            to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>.
            When it is done, the hard disk object can be registered by calling
            <link to="IVirtualBox::registerHardDisk()"/> and then
            <link to="IMachine::attachHardDisk()">attached</link> to
            virtual machines.

            The <link to="IHardDisk::description">description</link> of the
            Virtual Disk Image is stored in the image file. For this reason,
            changing the value of this property requires the hard disk to be
            <link to="IHardDisk::accessible">accessible</link>. The description
            of a registered hard disk can be changed only if a virtual machine
            using it is not running.

        </desc>

        <attribute name="filePath" type="wstring">
            <desc>

                Full file name of the virtual disk image of this hard disk. For
                newly created hard disk objects, this value is <tt>null</tt>.

                When assigning a new path, it can be absolute (full path) or
                relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
                home directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to the image
                file.

                When reading this propery, a full path is always returned.

                <note>This property cannot be changed when <link to="#created"/>
                returns <tt>true</tt>. In this case, the specified file name can
                be absolute (full path) or relative to the <link
                to="IVirtualBox::homeFolder"> VirtualBox home directory</link>.
                If only a file name without any path is given, the <link
                to="ISystemProperties::defaultVDIFolder"> default VDI
                folder</link> will be used as a path to the image file.</note>

            </desc>
        </attribute>

        <attribute name="created" type="boolean" readonly="yes">
            <desc>

                Whether the virual disk image is created or not. For newly
                created hard disk objects or after a successful invocation of
                <link to="#deleteImage()"/>, this value is <tt>false</tt> until
                <link to="#createFixedImage()"/> or <link
                to="#createDynamicImage()"/> is called.

            </desc>
        </attribute>

        <method name="createDynamicImage">

            <desc>

                Starts creating a dymically expanding hard disk image in the
                background. The previous image associated with this object, if
                any, must be deleted using <link to="#deleteImage"/>, otherwise
                the operation will fail.

                <note>After the returned progress object reports that the
                operation is complete, this hard disk object can be
                <link to="IVirtualBox::registerHardDisk()">registered</link>
                within this VirtualBox installation.</note>

            </desc>

            <param name="size" type="unsigned long long" dir="in">
                <desc>Maximum logical size of the hard disk in megabytes.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>

        </method>

        <method name="createFixedImage">
            <desc>

                Starts creating a fixed-size hard disk image in the background.
                The previous image, if any, must be deleted using <link
                to="#deleteImage"/>, otherwise the operation will fail.

                <note>After the returned progress object reports that the
                operation is complete, this hard disk object can be
                <link to="IVirtualBox::registerHardDisk()">registered</link>
                within this VirtualBox installation.</note>

            </desc>

            <param name="size" type="unsigned long long" dir="in">
                <desc>Logical size of the hard disk in megabytes.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>

        </method>

        <method name="deleteImage">
            <desc>

                Deletes the existing hard disk image. The hard disk must not be
                registered within this VirtualBox installation, otherwise the
                operation will fail.

                <note>After this operation succeeds, it will be impossible to
                register the hard disk until the image file is created
                again.</note>

                <note>This operation is valid only for non-differencing hard
                disks, after they are unregistered using <link
                to="IVirtualBox::unregisterHardDisk()"/>.</note>

            </desc>
        </method>

    </interface>

    <!--
    // IISCSIHardDisk
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IISCSIHardDisk" extends="$unknown"
        uuid="003f6ca9-3257-4ef9-99c9-c66ce44576cb"
        wsmap="uuid"
    >

        <desc>

            The IISCSIHardDisk interface represents <link to="IHardDisk">virtual
            hard disks</link> that use the Internet SCSI (iSCSI) protocol to
            store hard disk data on remote machines.

            iSCSI hard disks can be created using <link
            to="IVirtualBox::createHardDisk()"/>. When a new hard disk object is
            created, all its properties are uninitialized. After you assign some
            meaningful values to them, the hard disk object can be registered by
            calling <link to="IVirtualBox::registerHardDisk()"/> and then <link
            to="IMachine::attachHardDisk()">attached</link> to virtual machines.

            Objects that support this interface also support the <link
            to="IHardDisk"/> interface.

            The <link to="IHardDisk::description">description</link>
            of the iSCSI hard disk is stored in the VirtualBox
            configuration file, so it can be changed (at appropriate
            times) even when
            <link to="IHardDisk::accessible">accessible</link> returns
            <tt>false</tt>.  However, the hard disk must not be
            attached to a running virtual machine.

            <note>In the current imlementation, the type of all iSCSI hard disks
            is <link to="HardDiskType::WritethroughHardDisk">Writethrough</link>
            and cannot be changed.</note>

        </desc>

        <attribute name="server" type="wstring">
            <desc>

                iSCSI Server name (either a host name or an IP address). For
                newly created hard disk objects, this value is <tt>null</tt>.

            </desc>
        </attribute>

        <attribute name="port" type="unsigned short">
            <desc>

                iSCSI Server port. For newly created hard disk objects, this
                value is <tt>0</tt>, which means the default port.

            </desc>
        </attribute>

        <attribute name="target" type="wstring">
            <desc>

                iSCSI target name. For newly created hard disk objects, this
                value is <tt>null</tt>.

            </desc>
        </attribute>

        <attribute name="lun" type="unsigned long long">
            <desc>

                Logical unit number for this iSCSI disk. For newly created hard
                disk objects, this value is <tt>0</tt>.

            </desc>
        </attribute>

        <attribute name="userName" type="wstring">
            <desc>

                User name for accessing this iSCSI disk. For newly created hard
                disk objects, this value is <tt>null</tt>.

            </desc>
        </attribute>

        <attribute name="password" type="wstring">
            <desc>

                User password for accessing this iSCSI disk. For newly created
                hard disk objects, this value is <tt>null</tt>.

            </desc>
        </attribute>

    </interface>

    <!--
    // IVMDKImage
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IVMDKImage" extends="$unknown"
        uuid="178398f5-8559-4fee-979e-420af5b53eef"
        wsmap="uuid"
    >
        <desc>

            The IVMDKImage interface represents <link
            to="IHardDisk">virtual hard disks</link> that use
            WMware Virtual Machine Disk image files to store hard disk data.

            Hard disks using VMDK images can be either opened using
            <link to="IVirtualBox::openHardDisk()"/> or created from
            scratch using <link to="IVirtualBox::createHardDisk()"/>.

            Objects that support this interface also support the <link
            to="IHardDisk"/> interface.

            When a new hard disk object is created from scatch, an image file
            for it is not automatically created. To do it, you need to specify a
            valid <link to="#filePath">file path</link>, and call <link
            to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>.
            When it is done, the hard disk object can be registered by calling
            <link to="IVirtualBox::registerHardDisk()"/> and then
            <link to="IMachine::attachHardDisk()">attached</link> to
            virtual machines.

            The <link to="IHardDisk::description">description</link>
            of the VMDK hard disk is stored in the VirtualBox
            configuration file, so it can be changed (at appropriate
            times) even when
            <link to="IHardDisk::accessible">accessible</link> returns
            <tt>false</tt>.  However, the hard disk must not be
            attached to a running virtual machine.

            <note>In the current imlementation, the type of all VMDK hard disks
            is <link to="HardDiskType::WritethroughHardDisk">Writethrough</link>
            and cannot be changed.</note>

        </desc>

        <attribute name="filePath" type="wstring">
            <desc>

                Full file name of the VMDK image of this hard disk. For
                newly created hard disk objects, this value is <tt>null</tt>.

                When assigning a new path, it can be absolute (full path) or
                relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
                home directory</link>. If only a file name without any path is
                given, the <link to="ISystemProperties::defaultVDIFolder">
                default VDI folder</link> will be used as a path to the image
                file.

                When reading this propery, a full path is always returned.

                <note>This property cannot be changed when <link to="#created"/>
                returns <tt>true</tt>. In this case, the specified file name can
                be absolute (full path) or relative to the <link
                to="IVirtualBox::homeFolder"> VirtualBox home directory</link>.
                If only a file name without any path is given, the <link
                to="ISystemProperties::defaultVDIFolder"> default VDI
                folder</link> will be used as a path to the image file.</note>

            </desc>
        </attribute>

        <attribute name="created" type="boolean" readonly="yes">
            <desc>

                Whether the virual disk image is created or not. For newly
                created hard disk objects or after a successful invocation of
                <link to="#deleteImage()"/>, this value is <tt>false</tt> until
                <link to="#createFixedImage()"/> or <link
                to="#createDynamicImage()"/> is called.

            </desc>
        </attribute>

        <method name="createDynamicImage">

            <desc>

                Starts creating a dymically expanding hard disk image in the
                background. The previous image associated with this object, if
                any, must be deleted using <link to="#deleteImage"/>, otherwise
                the operation will fail.

                <note>After the returned progress object reports that the
                operation is complete, this hard disk object can be
                <link to="IVirtualBox::registerHardDisk()">registered</link>
                within this VirtualBox installation.</note>

            </desc>

            <param name="size" type="unsigned long long" dir="in">
                <desc>Maximum logical size of the hard disk in megabytes.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>

        </method>

        <method name="createFixedImage">
            <desc>

                Starts creating a fixed-size hard disk image in the background.
                The previous image, if any, must be deleted using <link
                to="#deleteImage"/>, otherwise the operation will fail.

                <note>After the returned progress object reports that the
                operation is complete, this hard disk object can be
                <link to="IVirtualBox::registerHardDisk()">registered</link>
                within this VirtualBox installation.</note>

            </desc>

            <param name="size" type="unsigned long long" dir="in">
                <desc>Logical size of the hard disk in megabytes.</desc>
            </param>
            <param name="progress" type="IProgress" dir="return">
                <desc>Progress object to track the operation completion.</desc>
            </param>

        </method>

        <method name="deleteImage">
            <desc>

                Deletes the existing hard disk image. The hard disk must not be
                registered within this VirtualBox installation, otherwise the
                operation will fail.

                <note>After this operation succeeds, it will be impossible to
                register the hard disk until the image file is created
                again.</note>

                <note>This operation is valid only for non-differencing hard
                disks, after they are unregistered using <link
                to="IVirtualBox::unregisterHardDisk()"/>.</note>

            </desc>
        </method>

    </interface>

    <!--
    // IDVDImage
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="IDVDImageEnumerator" type="IDVDImage"
        uuid="9BE77C8D-E1BE-4bf2-A67B-B4DD3D2B0F28"
    />

    <collection
        name="IDVDImageCollection" type="IDVDImage"
        enumerator="IDVDImageEnumerator"
        uuid="AE7053FA-ADD2-4ea4-AFCF-24D5F8DDED64"
        readonly="yes"
    >
        <method name="findByPath">
            <desc>
                Searches this collection for a DVD image with the given disk path.
                <note>
                    The method returns an error if the given name does not
                    correspond to any DVD image in the collection.
                </note>
            </desc>
            <param name="path" type="wstring" dir="in">
                <desc>Name of the DVD image's file system location.</desc>
            </param>
            <param name="image" type="IDVDImage" dir="return">
                <desc>Found DVD image object</desc>
            </param>
        </method>
    </collection>

    <interface
        name="IDVDImage" extends="$unknown"
        uuid="140FFF03-E479-4194-8562-ABC4F8171009"
        wsmap="uuid"
    >
        <desc>

            The IDVDImage interface represents a file containing the image
            of the DVD or CD disk.

            <h3>Image Accessibility</h3>

            The <link to="#accessible"/> attribute of the image object
            defines the accessibility state of the image file. If the
            value of this attribute is <tt>false</tt> then some image
            attributes may contain invalid or outdated values (for example, the
            the image file size) until a new accessibility
            check is done that returns <tt>true</tt>.

            <note>
            Because of the possible slowness of the accessibility check,
            it is not implicitly performed upon the VirtualBox server startup
            (to prevent the application freeze). In partcular, this means that
            if you try to read image properties that depend on the
            accessibility state without first reading the value of the
            <link to="#accessible"/> attribute and ensuring it's value is
            <tt>true</tt>, you will get wrong (zero) values.
            </note>

        </desc>
        <attribute name="id" type="uuid" readonly="yes">
            <desc>UUID of the CD/DVD image.</desc>
        </attribute>

        <attribute name="filePath" type="wstring" readonly="yes">
            <desc>Full file name of the CD/DVD image.</desc>
        </attribute>

        <attribute name="accessible" type="boolean" readonly="yes">
            <desc>

                Whether the CD/DVD image is currently accessible or not.
                The image, for example, can be unaccessible if it is placed
                on a network share that is not available by the time
                this property is read.

                The accessibility check is performed automatically every time
                this attribute is read. You should keep it in mind that this check
                may be slow and can block the calling thread for a long time (for
                example, if the network share where the image is located is down).

                The following attributes of the image object are considered
                to be invalid when this attribute is <tt>false</tt>:
                <ul>
                <li><link to="#size"/></li>
                </ul>

            </desc>
        </attribute>

        <attribute name="size" type="unsigned long long" readonly="yes">
            <desc>Size of the ISO image in bytes.</desc>
        </attribute>

    </interface>


    <!--
    // IDVDDrive
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="DriveState"
        uuid="cb7233b7-c519-42a5-8310-1830953cacbc"
    >
        <const name="InvalidDriveState"  value="0"/>
        <const name="NotMounted"         value="1"/>
        <const name="ImageMounted"       value="2"/>
        <const name="HostDriveCaptured"  value="3"/>
    </enum>

    <interface
        name="IDVDDrive" extends="$unknown"
        uuid="d9bd101a-8079-4fb9-bad1-31bf32482b75"
        wsmap="suppress"
    >
        <attribute name="state" type="DriveState" readonly="yes">
            <desc>Current drive state.</desc>
        </attribute>

        <attribute name="passthrough" type="boolean">
            <desc>
                When a host drive is mounted and passthrough is enabled
                the guest will be able to directly send SCSI commands to
                the host drive. This enables the guest to use CD/DVD writers
                but is potentially dangerous.
            </desc>
        </attribute>

        <method name="mountImage">
            <desc>Mounts the specified image.</desc>
            <param name="imageId" type="uuid" dir="in"/>
        </method>

        <method name="captureHostDrive">
            <desc>Captures the specified host drive.</desc>
            <param name="drive" type="IHostDVDDrive" dir="in"/>
        </method>

        <method name="unmount">
            <desc>Unmounts the currently mounted image/device.</desc>
        </method>

        <method name="getImage">
            <desc>Gets the currently mounted image ID.</desc>
            <param name="image" type="IDVDImage" dir="return"/>
        </method>

        <method name="getHostDrive">
            <desc>Gets the currently mounted image ID.</desc>
            <param name="drive" type="IHostDVDDrive" dir="return"/>
        </method>

    </interface>

    <!--
    // IFloppyImage
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="IFloppyImageEnumerator" type="IFloppyImage"
        uuid="902C4089-76B7-41f1-91E8-49A261A28A2C"
    />

    <collection
        name="IFloppyImageCollection" type="IFloppyImage"
        enumerator="IFloppyImageEnumerator"
        uuid="327A8928-8572-446e-AD9A-18FE30E81F3F"
        readonly="yes">
        <method name="findByPath">
            <desc>
                Searches this collection for a floppy image with the given disk path.
                <note>
                    The method returns an error if the given name does not
                    correspond to any floppy image in the collection.
                </note>
            </desc>
            <param name="path" type="wstring" dir="in">
                <desc>Name of the floppy image's file system location.</desc>
            </param>
            <param name="image" type="IFloppyImage" dir="return">
                <desc>Found Floppy image object</desc>
            </param>
        </method>
    </collection>

    <interface
        name="IFloppyImage" extends="$unknown"
        uuid="CC696755-EA98-4ffe-9DC5-C003047034AB"
        wsmap="uuid"
    >
        <desc>

            The IFloppyImage interface represents a file containing the image
            of a floppy disk.

            <h3>Image Accessibility</h3>

            The <link to="#accessible"/> attribute of the image object
            defines the accessibility state of the image file. If the
            value of this attribute is <tt>false</tt> then some image
            attributes may contain invalid or outdated values (for example, the
            the image file size) until a new accessibility
            check is done that returns <tt>true</tt>.

            <note>
            Because of the possible slowness of the accessibility check,
            it is not implicitly performed upon the VirtualBox server startup
            (to prevent the application freeze). In partcular, this means that
            if you try to read image properties that depend on the
            accessibility state without first reading the value of the
            <link to="#accessible"/> attribute and ensuring it's value is
            <tt>true</tt>, you will get wrong (zero) values.
            </note>

        </desc>
        <attribute name="id" type="uuid" readonly="yes">
            <desc>UUID of the floppy image.</desc>
        </attribute>

        <attribute name="filePath" type="wstring" readonly="yes">
            <desc>Full file name of the floppy image.</desc>
        </attribute>

        <attribute name="accessible" type="boolean" readonly="yes">
            <desc>

                Whether the floppy image is currently accessible or not.
                The image, for example, can be unaccessible if it is placed
                on a network share that is not available by the time
                this property is read.

                The accessibility check is performed automatically every time
                this attribute is read. You should keep it in mind that this check
                may be slow and can block the calling thread for a long time (for
                example, if the network share where the image is located is down).

                The following attributes of the image object are considered
                to be invalid when this attribute is <tt>false</tt>:
                <ul>
                <li><link to="#size"/></li>
                </ul>

            </desc>
        </attribute>

        <attribute name="size" type="unsigned long" readonly="yes">
            <desc>Size of the floppy image in bytes.</desc>
        </attribute>

    </interface>


    <!--
    // IFloppyDrive
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IFloppyDrive" extends="$unknown"
        uuid="E9318F71-78D2-4b00-863C-B7CB0030A2D9"
        wsmap="suppress"
    >
        <attribute name="enabled" type="boolean">
            <desc>
                Flag whether the floppy drive is enabled. If it is disabled,
                the floppy drive will not be reported to the guest.
            </desc>
        </attribute>

        <attribute name="state" type="DriveState" readonly="yes">
            <desc>Current drive state.</desc>
        </attribute>

        <method name="mountImage">
            <desc>Mounts the specified image.</desc>
            <param name="imageId" type="uuid" dir="in"/>
        </method>

        <method name="captureHostDrive">
            <desc>Captures the specified host drive.</desc>
            <param name="drive" type="IHostFloppyDrive" dir="in"/>
        </method>

        <method name="unmount">
            <desc>Unmounts the currently mounted image/device.</desc>
        </method>

        <method name="getImage">
            <desc>Gets the currently mounted image ID.</desc>
            <param name="image" type="IFloppyImage" dir="return"/>
        </method>

        <method name="getHostDrive">
            <desc>Gets the currently mounted image ID.</desc>
            <param name="drive" type="IHostFloppyDrive" dir="return"/>
        </method>

    </interface>


    <!--
    // IKeyboard
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IKeyboard" extends="$unknown"
        uuid="FD443EC1-000A-4F5B-9282-D72760A66916"
        wsmap="suppress"
    >
        <method name="putScancode">
            <desc>Sends a scancode to the keyboard.</desc>
            <param name="scancode" type="long" dir="in"/>
        </method>

        <method name="putScancodes">
            <desc>Sends an array of scancode to the keyboard.</desc>
            <param name="scancodes" type="long" dir="in" array="count"/>
            <param name="count" type="unsigned long" dir="in"/>
            <param name="codesStored" type="unsigned long" dir="return"/>
        </method>

        <method name="putCAD">
            <desc>Sends the Ctrl-Alt-Del sequence to the keyboard.</desc>
        </method>

    </interface>


    <!--
    // IMouse
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="MouseButtonState"
        uuid="03131722-2EC5-4173-9794-0DACA46673EF"
    >
        <const name="LeftButton"        value="0x01"/>
        <const name="RightButton"       value="0x02"/>
        <const name="MiddleButton"      value="0x04"/>
        <const name="WheelUp"           value="0x08"/>
        <const name="WheelDown"         value="0x10"/>
        <const name="MouseStateMask"    value="0x1F"/>
    </enum>

    <interface
        name="IMouse" extends="$unknown"
        uuid="FD443EC1-0006-4F5B-9282-D72760A66916"
        wsmap="suppress"
    >
        <desc>
            The IMouse interface represents a virtual mouse device.
        </desc>

        <attribute name="absoluteSupported" type="boolean" readonly="yes">
            <desc>
                Whether the guest OS supports absolute mouse pointer positioning
                or not.
                <note>
                    VirtualBox Guest Tools need to be installed to the guest OS
                    in order to enable absolute mouse positioning support.
                    You can use the <link to="IConsoleCallback::onMouseCapabilityChange"/>
                    callback to be instantly informed about changes of this attribute
                    during virtual machine execution.
                </note>
                <see><link to="#putMouseEventAbsolute"/></see>
            </desc>
        </attribute>

        <method name="putMouseEvent">
            <desc>
                Initiates a mouse event using relative pointer movements
                along x and y axis.
            </desc>

            <param name="dx" type="long" dir="in">
                <desc>
                    Amout of pixels the mouse should move to the right.
                    Negative values move the mouse to the left.
                </desc>
            </param>
            <param name="dy" type="long" dir="in">
                <desc>
                    Amout of pixels the mouse should move downwards.
                    Negative values move the mouse upwards.
                </desc>
            </param>
            <param name="dz" type="long" dir="in">
                <desc>
                    Amount of mouse wheel moves.
                    Positive values describe clockwize wheel rotations,
                    negative values describe counterclockwise rotations.
                </desc>
            </param>
            <param name="buttonState" type="long" dir="in">
                <desc>
                    The current state of mouse buttons. Every bit represents
                    a mouse button as follows:
                    <table>
                    <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
                    <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
                    <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
                    </table>
                    A value of <tt>1</tt> means the corresponding button is pressed.
                    otherwise it is released.
                </desc>
            </param>
        </method>

        <method name="putMouseEventAbsolute">
            <desc>
                Positions the mouse pointer using absolute x and y coordinates.
                These coordinates are expressed in pixels and
                start from <tt>[1,1]</tt> which corresponds to the top left
                corner of the virtual display.

                <note>
                    This method will have effect only if absolute mouse
                    positioning is supported by the guest OS.
                </note>

                <see><link to="#absoluteSupported"/></see>
            </desc>

            <param name="x" type="long" dir="in">
                <desc>
                    X coordinate of the pointer in pixels, starting from <tt>1</tt>.
                </desc>
            </param>
            <param name="y" type="long" dir="in">
                <desc>
                    Y coordinate of the pointer in pixels, starting from <tt>1</tt>.
                </desc>
            </param>
            <param name="dz" type="long" dir="in">
                <desc>
                    Amout of mouse wheel moves.
                    Positive values describe clockwize wheel rotations,
                    negative values describe counterclockwise rotations.
                </desc>
            </param>
            <param name="buttonState" type="long" dir="in">
                <desc>
                    The current state of mouse buttons. Every bit represents
                    a mouse button as follows:
                    <table>
                    <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
                    <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
                    <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
                    </table>
                    A value of <tt>1</tt> means the corresponding button is pressed.
                    otherwise it is released.
                </desc>
            </param>
        </method>

    </interface>


    <!--
    // IDisplay
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="FramebufferAccelerationOperation"
        uuid="f0e5ebbe-dc8e-4e2d-916e-53baa3844df8"
    >
        <const name="SolidFillAcceleration"   value="1"/>
        <const name="ScreenCopyAcceleration"  value="2"/>
    </enum>

    <enum
        name="FramebufferPixelFormat"
        uuid="d15f9c8b-bd7e-4003-981c-4ca14f49f2c3"
    >
        <const name="PixelFormatDefault"      value="0"/>
        <const name="PixelFormatRGB16"        value="1"/>
        <const name="PixelFormatRGB24"        value="2"/>
        <const name="PixelFormatRGB32"        value="3"/>
    </enum>

    <interface
        name="IFramebuffer" extends="$unknown"
        uuid="4481F27F-5C79-48d9-86C1-A2EC6747034D"
        wsmap="suppress"
    >
        <attribute name="address" type="octet" mod="ptr" readonly="yes">
            <desc>Address of the start byte of the framebuffer.</desc>
        </attribute>

        <attribute name="width" type="unsigned long" readonly="yes">
            <desc>Framebuffer width.</desc>
        </attribute>

        <attribute name="height" type="unsigned long" readonly="yes">
            <desc>Framebuffer height.</desc>
        </attribute>

        <attribute name="colorDepth" type="unsigned long" readonly="yes">
            <desc>Framebuffer color depth.</desc>
        </attribute>

        <attribute name="lineSize" type="unsigned long" readonly="yes">
            <desc>framebuffer scan line size in bytes.</desc>
        </attribute>

        <attribute name="pixelFormat" type="FramebufferPixelFormat" readonly="yes">
            <desc>Framebuffer pixel format.</desc>
        </attribute>

        <attribute name="heightReduction" type="unsigned long" readonly="yes">
            <desc>
                Hint from the framebuffer about how much of the standard
                screen height it wants to use for itself. This information is
                exposed to the guest through the VESA BIOS and VMMDev interface
                so that it can use it for determining its video mode table. It
                is not guaranteed that the guest respects the value.
            </desc>
        </attribute>

        <attribute name="overlay" type="IFramebufferOverlay" readonly="yes">
            <desc>
                An alpha-blended overlay which is superposed over the framebuffer.
                The initial purpose is to allow the display of icons providing
                information about the VM state, including disk activity, in front
                ends which do not have other means of doing that.  The overlay is
                designed to controlled exclusively by IDisplay.  It has no locking
                of its own, and any changes made to it are not guaranteed to be
                visible until the affected portion of IFramebuffer is updated.  The
                overlay can be created lazily the first time it is requested.  This
                attribute can also return NULL to signal that the overlay is not
                implemented.
            </desc>
        </attribute>

        <method name="lock">
            <desc>
                Locks the framebuffer.
                Gets called by the display object where this buffer is
                registered.
            </desc>
        </method>

        <method name="unlock">
            <desc>
                Unlocks the framebuffer.
                Gets called by the display object where this buffer is
                registered.
            </desc>
        </method>

        <method name="notifyUpdate">
            <desc>
                Informs about an update.
                Gets called by the display object where this buffer is
                registered.
            </desc>
            <param name="x" type="unsigned long" dir="in"/>
            <param name="y" type="unsigned long" dir="in"/>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
            <param name="finished" type="boolean" dir="return"/>
        </method>

        <method name="requestResize">
            <desc>
                Requests a size and pixel format change.

                The IFramebuffer implementation should try to setup
                a memory buffer suitable for the given pixel format
                and line size.
                The buffer must be page aligned, must contain
                whole number of pages, and one should be able
                to lock it to obtain physical addresses of pages.
                (Note: this method is currently not supported,
                use the below mentioned vram pointer!)

                If the requested pixel format is not supported,
                or a PixelFormatDefault is requested,
                a default format is set. In that case the memory
                buffer does not have to be aligned and lockable.

                The callee is also allowed to use the guest video memory
                buffer (pointed to by the @a vram parameter) directly instead
                of allocating its own buffer. To indicate that the framebuffer
                wants to use the guest video memory, its <link to="#address"/>
                implementation must return the same address as it gets in
                the @a vram parameter of this method.

                For non linear modes (such as text and standard VGA), the
                @vram parameter is NULL and must not be used. When it's not
                NULL, it is recommended to use it to access the guest video
                memory instead of creating a separate buffer as it will at
                least remove one copy operation.

                The caller checks if the call was successful
                via the <link to="#pixelFormat"/> property.

                <note>
                    This method is called by IDisplay under the IFramebuffer
                    lock.
                </note>
            </desc>
            <param name="pixelFormat" type="FramebufferPixelFormat" dir="in">
                <desc>Pixel format of the surface (BPP and layout)</desc>
            </param>
            <param name="vram" type="octet" mod="ptr" dir="in">
                <desc>Pointer to the guest VRAM (NULL for non linear modes)</desc>
            </param>
            <param name="lineSize" type="unsigned long" dir="in"/>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
            <param name="finished" type="boolean" dir="return"/>
        </method>

        <method name="operationSupported">
            <desc>
                Returns whether the given acceleration operation is supported
                by the IFramebuffer implementation. If not, the display object
                will not attempt to call the corresponding IFramebuffer entry
                point. Even if an operation is indicated to supported, the
                IFramebuffer implementation always has the option to return non
                supported from the corresponding acceleration method in which
                case the operation will be performed by the display engine. This
                allows for reduced IFramebuffer implementation complexity where
                only common cases are handled.
            </desc>
            <param name="operation" type="FramebufferAccelerationOperation" dir="in"/>
            <param name="supported" type="boolean" dir="return"/>
        </method>

        <method name="videoModeSupported">
            <desc>
                Returns whether the framebuffer implementation is willing to
                support a given video mode. In case it is not able to render
                the video mode (or for some reason not willing), it should
                return false. Usually this method is called when the guest
                asks the VMM device whether a given video mode is supported
                so the information returned is directly exposed to the guest.
                It is important that this method returns very quickly.
            </desc>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
            <param name="bpp" type="unsigned long" dir="in"/>
            <param name="supported" type="boolean" dir="return"/>
        </method>

        <method name="solidFill">
            <desc>
                Fill the specified rectangle on screen with a solid color.
            </desc>
            <param name="x" type="unsigned long" dir="in"/>
            <param name="y" type="unsigned long" dir="in"/>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
            <param name="color" type="unsigned long" dir="in"/>
            <param name="handled" type="boolean" dir="return"/>
        </method>

        <method name="copyScreenBits">
            <desc>
                Copy specified rectangle on the screen.
            </desc>
            <param name="xDst" type="unsigned long" dir="in"/>
            <param name="yDst" type="unsigned long" dir="in"/>
            <param name="xSrc" type="unsigned long" dir="in"/>
            <param name="ySrc" type="unsigned long" dir="in"/>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
            <param name="handled" type="boolean" dir="return"/>
        </method>

    </interface>

    <interface
        name="IFramebufferOverlay" extends="IFrameBuffer"
        uuid="0bcc1c7e-e415-47d2-bfdb-e4c705fb0f47"
        wsmap="suppress"
    >
      <desc>
          An alpha blended overlay for displaying status icons above an IFramebuffer.
          It is always created not visible, so that it must be explicitly shown.  It
          only covers a portion of the IFramebuffer, determined by its width, height
          and co-ordinates.  It is always in packed pixel little-endian 32bit ARGB (in
          that order) format, and may be written to directly.  Do re-read the width
          though, after setting it, as it may be adjusted (increased) to make it more
          suitable for the front end.
      </desc>
        <attribute name="x" type="unsigned long" readonly="yes">
            <desc>X position of the overlay, relative to the framebuffer.</desc>
        </attribute>

        <attribute name="y" type="unsigned long" readonly="yes">
            <desc>Y position of the overlay, relative to the framebuffer.</desc>
        </attribute>

        <attribute name="visible" type="boolean" readonly="no">
            <desc>
                Whether the overlay is currently visible.
            </desc>
        </attribute>

        <attribute name="alpha" type="unsigned long" readonly="no">
            <desc>
                The global alpha value for the overlay.  This may or may not be
                supported by a given front end.
            </desc>
        </attribute>

        <method name="move">
            <desc>
                Changes the overlay's position relative to the IFramebuffer.
            </desc>
            <param name="x" type="unsigned long" dir="in"/>
            <param name="y" type="unsigned long" dir="in"/>
        </method>

    </interface>

    <interface
        name="IDisplay" extends="$unknown"
        uuid="FD443EC1-0012-4F5B-9282-D72760A66916"
        wsmap="suppress"
    >
        <attribute name="width" type="unsigned long" readonly="yes">
            <desc>Current display width.</desc>
        </attribute>

        <attribute name="height" type="unsigned long" readonly="yes">
            <desc>Current display height.</desc>
        </attribute>

        <attribute name="colorDepth" type="unsigned long" readonly="yes">
            <desc>
                Current guest display color depth. Note that this may differ
                from <link to="IFramebuffer::colorDepth">IFramebuffer::colorDepth</link>.
            </desc>
        </attribute>

        <method name="setupInternalFramebuffer">
            <desc>
                Prepares an internally managed framebuffer.
            </desc>
            <param name="depth" type="unsigned long" dir="in"/>
        </method>

        <method name="lockFramebuffer">
            <desc>
               Requests access to the internal framebuffer.
            </desc>
            <param name="address" type="octet" mod="ptr" dir="return"/>
        </method>

        <method name="unlockFramebuffer">
            <desc>
                Releases access to the internal framebuffer.
            </desc>
        </method>

        <method name="registerExternalFramebuffer">
            <desc>
                Registers an external framebuffer.
            </desc>
            <param name="framebuffer" type="IFramebuffer" dir="in"/>
        </method>

        <method name="setVideoModeHint">
            <desc>
                Asks VirtualBox to request the given video mode from
                the guest. This is just a hint and it cannot be guaranteed
                that the requested resolution will be used. Guest Additions
                are required for the request to be seen by guests. The caller
                should issue the request and wait for a resolution change and
                after a timeout retry.
                Specifying "0" for either width and height or the color depth
                means that the dimensions or color depth should not be changed.
            </desc>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
            <param name="colorDepth" type="unsigned long" dir="in"/>
        </method>

        <method name="takeScreenShot">
            <desc>
                Takes a screen shot of the requested size and copies it to the
                32-bpp buffer allocated by the caller.
            </desc>
            <param name="address" type="octet" mod="ptr" dir="in"/>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
        </method>

        <method name="drawToScreen">
            <desc>
                Draws a 32-bpp image of the specified size from the given buffer
                to the given point on the VM display.
            </desc>
            <param name="address" type="octet" mod="ptr" dir="in"/>
            <param name="x" type="unsigned long" dir="in"/>
            <param name="y" type="unsigned long" dir="in"/>
            <param name="width" type="unsigned long" dir="in"/>
            <param name="height" type="unsigned long" dir="in"/>
        </method>

        <method name="invalidateAndUpdate">
            <desc>
                Does a full invalidation of the VM display and instructs the VM
                to update it.
            </desc>
        </method>

        <method name="resizeCompleted">
            <desc>
                Signals that a framebuffer has completed the resize operation.
            </desc>
        </method>

        <method name="updateCompleted">
            <desc>
                Signals that a framebuffer has completed the update operation.
            </desc>
        </method>

    </interface>

    <!--
    // INetworkAdapter
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="NetworkAttachmentType"
        uuid="8730d899-d036-4925-bc63-e58f3486f4bf"
    >
        <const name="NoNetworkAttachment"            value="0"/>
        <const name="NATNetworkAttachment"           value="1"/>
        <const name="HostInterfaceNetworkAttachment" value="2"/>
        <const name="InternalNetworkAttachment"      value="3"/>
    </enum>

    <enum
        name="NetworkAdapterType"
        uuid="156b17b9-5d61-4d54-be90-62e37dda848d"
    >
        <const name="InvalidNetworkAdapterType"      value="0"/>
        <const name="NetworkAdapterAm79C970A"        value="1"/>
        <const name="NetworkAdapterAm79C973"         value="2"/>
    </enum>

    <interface
        name="INetworkAdapter" extends="$unknown"
        uuid="78dfc978-ecb0-44ee-8b20-54549dd4539e"
        wsmap="suppress"
    >
        <attribute name="adapterType" type="NetworkAdapterType">
            <desc>
                Type of the virtual network adapter. Depending on this value,
                VirtualBox will provide a different virtual network hardware
                to the guest.
            </desc>
        </attribute>

        <attribute name="slot" type="unsigned long" readonly="yes">
            <desc>
                Slot number this adapter is plugged into. Corresponds to
                the value you pass to <link to="IMachine::getNetworkAdapter"/>
                to obtain this instance.
            </desc>
        </attribute>

        <attribute name="enabled" type="boolean">
            <desc>
                Flag whether the network adapter is present in the
                guest system. If disabled, the virtual guest hardware will
                not contain this network adapter. Can only be changed when
                the VM is not running.
            </desc>
        </attribute>

        <attribute name="MACAddress" type="wstring">
            <desc>
                Ethernet MAC address of the adapter, 12 hexadecimal characters. When setting
                it to NULL, VirtualBox will generate a unique MAC address.
            </desc>
        </attribute>

        <attribute name="attachmentType" type="NetworkAttachmentType" readonly="yes"/>

        <attribute name="hostInterface" type="wstring">
            <desc>
                Name of the Host Network Interface that is currently in use. NULL will be returned
                if no device has been allocated. On Linux, setting this refers to a permanent TAP
                device. However, a file descriptor has precedence over the interface name on Linux.
                Note that when VBox allocates a TAP device, this property will not be set, i.e. the
                interface name would have to be determined using the file descriptor and /proc/self/fd.
            </desc>
        </attribute>

<if target="xpidl">
        <attribute name="TAPFileDescriptor" type="long">
            <desc>
                File descriptor of the TAP device. It can either be setup by the caller
                which has to supply an existing valid file handle allocated in the parent
                process of the VM process or allocated by VirtualBox. The value is -1 if it
                has not been defined. This property is non persistent, i.e. it will not be
                stored in the VM's configuration data and thus has to be set at each startup.
            </desc>
        </attribute>
        <attribute name="TAPSetupApplication" type="wstring">
            <desc>
                Application to start to configure the TAP device.
                It is being passed two parameters, 1) the file handle (as ascii),
                2) the TAP device name if it is available.
            </desc>
        </attribute>
        <attribute name="TAPTerminateApplication" type="wstring">
            <desc>
                Application to start before closing a TAP device.
                It is being passed two parameters, 1) the file handle (as ascii),
                2) the TAP device name if it is available.
            </desc>
        </attribute>
</if>

        <attribute name="internalNetwork" type="wstring">
            <desc>
                Name of the internal network the VM is attached to.
            </desc>
        </attribute>

        <attribute name="cableConnected" type="boolean">
            <desc>
                Flag whether the adapter reports the cable as connected or not.
                It can be used to report offline situations to a VM.
            </desc>
        </attribute>

        <attribute name="traceEnabled" type="boolean">
            <desc>
                Flag whether network traffic from/to the network card should be traced.
                Can only be toggled when the VM is turned off.
            </desc>
        </attribute>

        <attribute name="traceFile" type="wstring">
            <desc>
                Filename where a network trace will be stored. If not set, VBox-pid.pcap
                will be used.
            </desc>
        </attribute>

        <method name="attachToNAT">
            <desc>
                Attach the network adapter to the Network Address Translation (NAT) interface.
            </desc>
        </method>

        <method name="attachToHostInterface">
            <desc>
                Attach the network adapter to a host interface. On Linux, the TAP
                setup application will be executed if configured and unless a device
                name and/or file descriptor has been set, a new TAP interface will be
                created.
            </desc>
        </method>

        <method name="attachToInternalNetwork">
            <desc>
                Attach the network adapter to an internal network.
            </desc>
        </method>

        <method name="detach">
            <desc>
                Detach the network adapter
            </desc>
        </method>
    </interface>


    <!--
    // IMachineDebugger
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IMachineDebugger" extends="$unknown"
        uuid="288da658-74fa-4877-ab5c-dafdad19a1cd"
        wsmap="suppress"
    >
        <method name="resetStats">
            <desc>
                Reset VM statistics.
            </desc>
        </method>

        <method name="dumpStats">
            <desc>
                Dumps VM statistics.
            </desc>
        </method>

        <attribute name="singlestep" type="boolean">
            <desc>Switch for enabling singlestepping.</desc>
        </attribute>

        <attribute name="recompileUser" type="boolean">
            <desc>Switch for forcing code recompilation for user mode code.</desc>
        </attribute>

        <attribute name="recompileSupervisor" type="boolean">
            <desc>Switch for forcing code recompilation for supervisor mode code.</desc>
        </attribute>

        <attribute name="PATMEnabled" type="boolean">
            <desc>Switch for enabling and disabling the PATM component.</desc>
        </attribute>

        <attribute name="CSAMEnabled" type="boolean">
            <desc>Switch for enabling and disabling the CSAM component.</desc>
        </attribute>

        <attribute name="LogEnabled" type="boolean">
            <desc>Switch for enabling and disabling logging.</desc>
        </attribute>

        <attribute name="HWVirtExEnabled" type="boolean" readonly="yes">
            <desc>
                Flag indicating whether the VM is currently making use of CPU hardware
                virtualization extensions
            </desc>
        </attribute>

        <attribute name="VirtualTimeRate" type="unsigned long">
            <desc>
                The rate at which the virtual time runs expressed as a percentage.
                The accepted range is 2% to 20000%.
            </desc>
        </attribute>

        <!-- @todo method for setting log flags, groups and destination! -->

        <attribute name="VM" type="unsigned long long" readonly="yes">
            <desc>
                Gets the VM handle. This is only for internal use while
                we carve the details of this interface.
            </desc>
        </attribute>

    </interface>

    <!--
    // IUSBController
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IUSBController" extends="$unknown"
        uuid="9a110c34-93c2-46b0-8ac2-b09d1067be56"
        wsmap="suppress"
    >
        <attribute name="enabled" type="boolean">
            <desc>
                Flag whether the USB controller is present in the
                guest system. If disabled, the virtual guest hardware will
                not contain any USB controller. Can only be changed when
                the VM is powered off.
            </desc>
        </attribute>

        <attribute name="USBStandard" type="unsigned short" readonly="yes">
            <desc>
                USB standard version which the controller implements.
                This is a BCD which means that the major version is in the
                high byte and minor version is in the low byte.
            </desc>
        </attribute>

        <attribute name="DeviceFilters" type="IUSBDeviceFilterCollection" readonly="yes">
            <desc>
                List of USB device filters associated with the machine.

                If the machine is currently running, these filters are activated
                every time a new (supported) USB device is attached to the host
                computer that was not ignored by global filters
                (<link to="IHost::USBDeviceFilters"/>).

                These filters are also activated when the machine is powered up.
                They are run against a list of all currently available USB
                devices (in states
                <link to="USBDeviceState::USBDeviceAvailable">USBDeviceAvailable</link>,
                <link to="USBDeviceState::USBDeviceBusy">USBDeviceBusy</link>,
                <link to="USBDeviceState::USBDeviceHeld">USBDeviceHeld</link>)
                that were not previously ignored by global filters.

                If at least one filter matches the USB device in question, this
                device is automatically captured (attached to) the virtual USB
                controller of this machine.

                <see>IUSBDeviceFilter, ::IUSBController</see>
            </desc>
        </attribute>

        <method name="createDeviceFilter">
            <desc>
                Creates a new USB device filter. All attributes except
                the filter name are set to <tt>null</tt> (any match),
                <i>active</i> is <tt>false</tt> (the filter is not active).

                The created filter can then be added to the list of filters using
                <link to="#insertDeviceFilter()"/>.

                <see>#DeviceFilters</see>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>
                    Filter name. See <link to="IUSBDeviceFilter::name"/>
                    for more info.
                </desc>
            </param>
            <param name="filter" type="IUSBDeviceFilter" dir="return">
                <desc>Created filter object.</desc>
            </param>
        </method>

        <method name="insertDeviceFilter">
            <desc>
                Inserts the given USB device to the specified position
                in the list of filters.

                Positions are numbered starting from <tt>0</tt>. If the specified
                position is equal to or greater than the number of elements in
                the list, the filter is added to the end of the collection.

                <note>
                    Duplicates are not allowed, so an attempt to inster a
                    filter that is already in the collection, will return an
                    error.
                </note>

                <see>#DeviceFilters</see>
            </desc>
            <param name="position" type="unsigned long" dir="in">
                <desc>Position to insert the filter to.</desc>
            </param>
            <param name="filter" type="IUSBDeviceFilter" dir="in">
                <desc>USB device filter to insert.</desc>
            </param>
        </method>

        <method name="removeDeviceFilter">
            <desc>
                Removes a USB device filter from the specified position in the
                list of filters.

                Positions are numbered starting from <tt>0</tt>. Specifying a
                position equal to or greater than the number of elements in
                the list will produce an error.

                <see>#DeviceFilters</see>
            </desc>
            <param name="position" type="unsigned long" dir="in">
                <desc>Position to remove the filter from.</desc>
            </param>
            <param name="filter" type="IUSBDeviceFilter" dir="return">
                <desc>Removed USB device filter.</desc>
            </param>
        </method>

    </interface>


    <!--
    // IUSBDevice
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="IUSBDeviceEnumerator" type="IUSBDevice"
        uuid="aefe00f7-eb8a-454b-9ea4-fd5ad93c0e99"
    />

    <collection
        name="IUSBDeviceCollection" type="IUSBDevice"
        enumerator="IUSBDeviceEnumerator"
        uuid="e31f3248-90dd-4ca2-95f0-6b36042d96a2"
        readonly="yes"
    >
        <method name="findById">
            <desc>
                Searches this collection for a USB device with the given UUID.
                <note>
                    The method returns an error if the given UUID does not
                    correspond to any USB device in the collection.
                </note>
                <see>IUSBDevice::id</see>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the USB device to search for.</desc>
            </param>
            <param name="device" type="IUSBDevice" dir="return">
                <desc>Found USB device object.</desc>
            </param>
        </method>

        <method name="findByAddress">
            <desc>
                Searches this collection for a USB device with the given
                host address.
                <note>
                    The method returns an error if the given address does not
                    correspond to any USB device in the collection.
                </note>
                <see>IUSBDevice::address</see>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>
                    Address of the USB device (as assigned by the host) to
                    search for.
                </desc>
            </param>
            <param name="device" type="IUSBDevice" dir="return">
                <desc>Found USB device object.</desc>
            </param>
        </method>

    </collection>

    <interface
        name="IUSBDevice" extends="$unknown"
        uuid="c5ab8d05-1999-4e48-ae34-cdeb235aacf0"
        wsmap="uuid"
    >
        <desc>
            The IUSBDevice interface represents a USB device captured by
            (attached to) a running virtual machine's USB controller.
            <see>IConsole::USBDevices</see>
        </desc>

        <attribute name="id" type="uuid" readonly="yes">
            <desc>
                Unique USB device ID. This ID is built from #vendorId,
                #productId, #revision and #serialNumber.
            </desc>
        </attribute>

        <attribute name="vendorId" type="unsigned short" readonly="yes">
            <desc>Vendor ID.</desc>
        </attribute>

        <attribute name="productId" type="unsigned short" readonly="yes">
            <desc>Product ID.</desc>
        </attribute>

        <attribute name="revision" type="unsigned short" readonly="yes">
            <desc>
                Product revision number. This is a packed BCD represented as
                unsigned short. The high byte is the integer part and the low
                byte is the decimal.
            </desc>
        </attribute>

        <attribute name="manufacturer" type="wstring" readonly="yes">
            <desc>Manufacturer string.</desc>
        </attribute>

        <attribute name="product" type="wstring" readonly="yes">
            <desc>Product string.</desc>
        </attribute>

        <attribute name="serialNumber" type="wstring" readonly="yes">
            <desc>Serial number string.</desc>
        </attribute>

        <attribute name="address" type="wstring" readonly="yes">
            <desc>Host specific address of the device.</desc>
        </attribute>

        <attribute name="port" type="unsigned short" readonly="yes">
            <desc>
                Host USB port number the device is physically
                coonected to.
            </desc>
        </attribute>

        <attribute name="remote" type="boolean" readonly="yes">
            <desc>
                Whether the device is physically connected to a remote VRDP
                client or to a local host machine.
            </desc>
        </attribute>

    </interface>


    <!--
    // IUSBDeviceFilter
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="IUSBDeviceFilterEnumerator" type="IUSBDeviceFilter"
        uuid="8d066d8b-3576-4a22-a387-847840937453"
    />

    <collection
        name="IUSBDeviceFilterCollection" type="IUSBDeviceFilter"
        enumerator="IUSBDeviceFilterEnumerator"
        uuid="4fa3fc99-ceb1-4bf5-a9cb-e962d825c1ef"
        readonly="yes"
    />

    <interface
        name="IUSBDeviceFilter" extends="$unknown"
        uuid="d6831fb4-1a94-4c2c-96ef-8d0d6192066d"
        wsmap="suppress"
    >
        <desc>
            The IUSBDeviceFilter interface represents an USB device filter used
            to perform actions on a group of USB devices.

            This type of filters is used by running virtual machines to
            automatically capture selected USB devices once they are physically
            attached to the host computer.

            A USB device is matched to the given device filter if and only if all
            attributes of the device match the corresponding attributes of the
            filter (that is, attributes are joined together using the logical AND
            operation). On the other hand, all together, filters in the list of
            filters carry the semantics of the logical OR operation. So if it is
            desirable to create a match like "this vendor id OR this product id",
            one needs to create two filters and specify "any match" (see below)
            for unused attributes.

            All filter attributes used for matching are strings. Each string
            is an expression representing a set of values of the corresponding
            device attribute, that will match the given filter. Currently, the
            following filtering expressions are supported:

            <ul>
            <li><i>Interval filters</i>. Used to specify valid intervals for
            integer device attributes (Vendor ID, Product ID and Revision).
            The format of the string is:

            <tt>int:((m)|([m]-[n]))(,(m)|([m]-[n]))*</tt>

            where <tt>m</tt> and <tt>n</tt> are integer numbers, either in octal
            (starting from <tt>0</tt>), hexadecimal (starting from <tt>0x</tt>)
            or decimal (otherwise) form, so that <tt>m &lt; n</tt>. If <tt>m</tt>
            is ommitted before a dash (<tt>-</tt>), the minimum possible integer
            is assumed; if <tt>n</tt> is ommitted after a dash, the maximum
            possible integer is assummed.
            </li>
            <li><i>Boolean filters</i>. Used to specify acceptable values for
            boolean device attributes. The format of the string is:

            <tt>true|false|yes|no|0|1</tt>

            </li>
            <li><i>Exact match</i>. Used to specify a single value for the given
            device attribute. Any string that does't start with <tt>int:</tt>
            represents the exact match. String device attributes are compared to
            this string including case of symbols. Integer attributes are first
            converted to a string (see individual filter attributes) and then
            compared ignoring case.

            </li>
            <li><i>Any match</i>. Any value of the corresponding device attribute
            will match the given filter. An empty or <tt>null</tt> string is
            used to construct this type of filtering expressions.

            </li>
            </ul>

            <note>
                On the Windows host platform, interval filters are not currently
                available. Also all string filter attributes
                (<link to="#manufacturer"/>, <link to="#product"/>,
                <link to="#serialNumber"/>) are ignored, so they behave as
                <i>any match</i> no matter what string expression is specified.
            </note>

            <see>IUSBController::DeviceFilters, IHostUSBDeviceFilter</see>
        </desc>

        <attribute name="name" type="wstring">
            <desc>
                Visible name for this filter.
                This name is used to visually distungish one filter from another,
                so it can neither be <tt>null</tt> nor an empty string.
            </desc>
        </attribute>

        <attribute name="active" type="boolean">
            <desc>Whether this filter active or has been temporarily disabled.</desc>
        </attribute>

        <attribute name="vendorId" type="wstring">
            <desc>
                <link to="IUSBDevice::vendorId">Vendor ID</link> filter.
                The string representation for the <i>exact matching</i>
                has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
                (including leading zeroes).
            </desc>
        </attribute>

        <attribute name="productId" type="wstring">
            <desc>
                <link to="IUSBDevice::productId">Product ID</link> filter.
                The string representation for the <i>exact matching</i>
                has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
                (including leading zeroes).
            </desc>
        </attribute>

        <attribute name="revision" type="wstring">
            <desc>
                <link to="IUSBDevice::productId">Product revision number</link>
                filter. The string representation for the <i>exact matching</i>
                has the form <tt>IIFF</tt>, where <tt>I</tt> is the decimal digit
                of the integer part of the revision, and <tt>F</tt> is the
                decimal digit of its fractional part (including leading and
                trailing zeroes).
                Note that for interval filters, it's best to use the hexadecimal
                form, because the revision is stored as a 16 bit packed BCD value;
                so the expression <tt>int:0x0100-0x0199</tt> will match any
                revision from <tt>1.0</tt> to <tt>1.99</tt>.
            </desc>
        </attribute>

        <attribute name="manufacturer" type="wstring">
            <desc>
                <link to="IUSBDevice::manufacturer">Manufacturer</link> filter.
            </desc>
        </attribute>

        <attribute name="product" type="wstring">
            <desc>
                <link to="IUSBDevice::product">Product</link> filter.
            </desc>
        </attribute>

        <attribute name="serialNumber" type="wstring">
            <desc>
                <link to="IUSBDevice::serialNumber">Serial number</link> filter.
            </desc>
        </attribute>

        <attribute name="port" type="wstring">
            <desc>
                <link to="IUSBDevice::port">Host USB port</link> filter.
            </desc>
        </attribute>

        <attribute name="remote" type="wstring">
            <desc>
                <link to="IUSBDevice::remote">Remote state</link> filter.
                <note>
                    This filter makes sense only for machine USB filters,
                    i.e. it is ignored by IHostUSBDeviceFilter objects.
                </note>
            </desc>
        </attribute>

    </interface>


    <!--
    // IHostUSBDevice
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="USBDeviceState"
        uuid="b99a2e65-67fb-4882-82fd-f3e5e8193ab4"
    >
        <desc>
            USB device state. This enumeration represents all possible states
            of the USB device physically attached to the host computer regarding
            its state on the host computer and availability to guest computers
            (all currently running virtual machines).

            Once a supported USB device is attached to the host, global USB
            filters (<link to="IHost::USBDeviceFilters"/>) are activated. They can
            either ignore the device, or put ot to #USBDeviceHeld state, or do
            nothing. Unless the device is ignored by global filters, filters of
            all currently running guests (<link to="IUSBController::DeviceFilters"/>)
            are activated that can put it to #USBDeviceCaptured state.

            If the device was ignored by global filters, or didn't match
            any filters at all (including guest ones), it is handled by the host
            in a normal way. In this case, the device state is determined by
            the host and can be one of #USBDeviceUnavailable, #USBDeviceBusy or
            #USBDeviceAvailable, depending on the current device usage.

            Besides auto-capturing based on filters, the device can be manually
            captured by guests (<link to="IConsole::attachUSBDevice()"/>) if its
            state is #USBDeviceBusy, #USBDeviceAvailable or #USBDeviceHeld.

            <note>
                Due to differences in USB stack implementations in Linux and Win32,
                states #USBDeviceBusy and #USBDeviceAvailable are applicable
                only to the Linux version of the product. This also means that
                (<link to="IConsole::attachUSBDevice()"/>) can only succeed
                on Win32 if the device state is #USBDeviceHeld.
            </note>

            <see>IHostUSBDevice, IHostUSBDeviceFilter</see>
        </desc>

        <const name="USBDeviceNotSupported" value="0">
            <desc>
                Not supported by the VirtualBox server, not available to guests.
            </desc>
        </const>
        <const name="USBDeviceUnavailable"  value="1">
            <desc>
                Being used by the host computer exclusively,
                not available to guests.
            </desc>
        </const>
        <const name="USBDeviceBusy"         value="2">
            <desc>
                Being used by the host computer, potentially available to guests.
            </desc>
        </const>
        <const name="USBDeviceAvailable"    value="3">
            <desc>
                Not used by the host computer, available to guests.
                The host computer can also start using the device at any time.
            </desc>
        </const>
        <const name="USBDeviceHeld"         value="4">
            <desc>
                Held by the VirtualBox server (ignored by the host computer),
                available to guests.
            </desc>
        </const>
        <const name="USBDeviceCaptured"     value="5">
            <desc>
                Captured by one of the guest computers, not available
                to anybody else.
            </desc>
        </const>
    </enum>

    <enumerator
        name="IHostUSBDeviceEnumerator" type="IHostUSBDevice"
        uuid="a0c55136-939f-4d20-b9d3-4d406f08bfa5"
    />

    <collection
        name="IHostUSBDeviceCollection" type="IHostUSBDevice"
        enumerator="IHostUSBDeviceEnumerator"
        uuid="f9d3f96d-b027-4994-b589-70bb9ee0d364"
        readonly="yes"
    >
        <method name="findById">
            <desc>
                Searches this collection for a USB device with the given UUID.
                <note>
                    The method returns an error if the given UUID does not
                    correspond to any USB device in the collection.
                </note>
                <see>IHostUSBDevice::id</see>
            </desc>
            <param name="id" type="uuid" dir="in">
                <desc>UUID of the USB device to search for.</desc>
            </param>
            <param name="device" type="IHostUSBDevice" dir="return">
                <desc>Found USB device object.</desc>
            </param>
        </method>

        <method name="findByAddress">
            <desc>
                Searches this collection for a USB device with the given
                host address.
                <note>
                    The method returns an error if the given address does not
                    correspond to any USB device in the collection.
                </note>
                <see>IHostUSBDevice::address</see>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>
                    Address of the USB device (as assigned by the host) to
                    search for.
                </desc>
            </param>
            <param name="device" type="IHostUSBDevice" dir="return">
                <desc>Found USB device object.</desc>
            </param>
        </method>

    </collection>

    <interface
        name="IHostUSBDevice" extends="IUSBDevice"
        uuid="173b4b44-d268-4334-a00d-b6521c9a740a"
        wsmap="uuid"
    >
        <desc>
            The IHostUSBDevice interface represents a USB device attached to
            the host computer.

            Among with properties inherited from IUSBDevice,
            this interface adds the <link to="#state"/> property
            that holds the courrent state of the USB device.

            <see>IHost::USBDevices, IHost::USBDeviceFilters</see>
        </desc>

        <attribute name="state" type="USBDeviceState" readonly="yes">
            <desc>
                Current state of the device.
            </desc>
        </attribute>

        <!-- @todo add class, subclass, bandwidth, configs, interfaces endpoints and such later. -->

    </interface>


    <!--
    // IHostUSBDeviceFilter
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="USBDeviceFilterAction"
        uuid="cbc30a49-2f4e-43b5-9da6-121320475933"
    >
        <desc>
            Actions for host USB device filters.
            <see>IHostUSBDeviceFilter, USBDeviceState</see>
        </desc>

        <const name="InvalidUSBDeviceFilterAction"  value="0"/>
        <const name="USBDeviceFilterIgnore"         value="1">
            <desc>Ignore the matched USB device.</desc>
        </const>
        <const name="USBDeviceFilterHold"           value="2">
            <desc>Hold the matched USB device.</desc>
        </const>
    </enum>

    <enumerator
        name="IHostUSBDeviceFilterEnumerator" type="IHostUSBDeviceFilter"
        uuid="ff735211-903e-4642-9c37-189eb44579fe"
    />

    <collection
        name="IHostUSBDeviceFilterCollection" type="IHostUSBDeviceFilter"
        enumerator="IHostUSBDeviceFilterEnumerator"
        uuid="1a80458b-87f1-4a74-995d-04e2330119e0"
        readonly="yes"
    />

    <interface
        name="IHostUSBDeviceFilter" extends="IUSBDeviceFilter"
        uuid="4cc70246-d74a-400f-8222-3900489c0374"
        wsmap="struct"
    >
        <desc>
            The IHostUSBDeviceFilter interface represents a USB device filter used
            by the host computer.

            Using filters of this type, the host computer determines the initial
            state of the USB device after it is physically attached to the
            host's USB controller.

            <note>
                The <link to="#remote"/> attribute is ignored by this type of
                filters, because it makes sense only for
                <link to="IUSBController::DeviceFilters">machine USB filters</link>.
            </note>

            <see>IHost::USBDeviceFilters</see>
        </desc>

        <attribute name="action" type="USBDeviceFilterAction">
            <desc>
                Action performed by the host when an attached USB device
                matches this filter.
            </desc>
        </attribute>

    </interface>

    <!--
    // IAudioAdapter
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="AudioDriverType"
        uuid="0194b900-7233-42d3-b7a1-097bbf53febd"
    >
        <const name="NullAudioDriver"   value="0"/>
        <const name="WINMMAudioDriver"  value="1"/>
        <const name="OSSAudioDriver"    value="2"/>
        <const name="ALSAAudioDriver"   value="3"/>
        <const name="DSOUNDAudioDriver" value="4"/>
        <const name="CoreAudioDriver"   value="5"/>
    </enum>

    <interface
        name="IAudioAdapter" extends="$unknown"
        uuid="921873db-5f3f-4b69-91f9-7be9e535a2cb"
        wsmap="struct"
    >
        <attribute name="enabled" type="boolean">
            <desc>
                Flag whether the audio adapter is present in the
                guest system. If disabled, the virtual guest hardware will
                not contain any audio adapter. Can only be changed when
                the VM is not running.
            </desc>
        </attribute>
        <attribute name="audioDriver" type="AudioDriverType">
            <desc>
                Audio driver the adapter is connected to. This setting
                can only be changed when the VM is not running.
            </desc>
        </attribute>
    </interface>

    <!--
    // IVRDPServer
    /////////////////////////////////////////////////////////////////////////
    -->

    <enum
        name="VRDPAuthType"
        uuid="3d91887a-b67f-4b33-85bf-2da7ab1ea83a"
    >
        <const name="VRDPAuthNull"            value="0"/>
        <const name="VRDPAuthExternal"        value="1"/>
        <const name="VRDPAuthGuest"           value="2"/>
    </enum>

    <interface
        name="IVRDPServer" extends="$unknown"
        uuid="2e88bf9e-2085-421f-9aa2-32088b0378b3"
        wsmap="struct"
    >
        <attribute name="enabled" type="boolean">
            <desc>VRDP server status.</desc>
        </attribute>

        <attribute name="port" type="unsigned long">
            <desc>VRDP server port.</desc>
        </attribute>

        <attribute name="netAddress" type="wstring">
            <desc>VRDP server address.</desc>
        </attribute>

        <attribute name="authType" type="VRDPAuthType">
            <desc>VRDP authentication method.</desc>
        </attribute>

        <attribute name="authTimeout" type="unsigned long">
            <desc>Timeout for guest authentication. Milliseconds.</desc>
        </attribute>

    </interface>


    <!--
    // ISharedFolder
    /////////////////////////////////////////////////////////////////////////
    -->

    <enumerator
        name="ISharedFolderEnumerator" type="ISharedFolder"
        uuid="1d420fd8-e7c1-4511-abf4-a504dc6d0cbf"
    />

    <collection
        name="ISharedFolderCollection" type="ISharedFolder"
        enumerator="ISharedFolderEnumerator"
        uuid="9c7e2282-bb16-4fa7-9138-f383c5e02353"
        readonly="yes">

        <method name="findByName">
            <desc>
                Searches this collection for a shared folder drive with the
                given logical name.
                <note>
                    The method returns an error if the given name does not
                    correspond to any shared folder in the collection.
                </note>
            </desc>
            <param name="name" type="wstring" dir="in">
                <desc>Logical name of the shared folder to search for</desc>
            </param>
            <param name="sharedFolder" type="ISharedFolder" dir="return">
                <desc>Found shared folder object</desc>
            </param>
        </method>

    </collection>

    <interface
        name="ISharedFolder" extends="$unknown"
        uuid="8b0c5f70-9139-4f97-a421-64d5e9c335d5"
        wsmap="struct"
    >
        <desc>
            The ISharedFolder interface represents a folder in the host
            computer's file system accessible from a guest OS running inside a
            virtual machine using an associated logical name.

            There are three types of shared folders:
            <ul>
                <li>permanent (<link to="IMachine::sharedFolders"/>)</li>
                <li>transient (<link to="IConsole::sharedFolders"/>)</li>
                <li>global (<link to="IVirtualBox::sharedFolders"/>)</li>
            </ul>

            For a given virtual machine, both permanently and transiently
            shared folders have the same logical name space which also includes
            all globally shared folders. Thus, every folder in this name space
            must have an unique logical name. Note that permanent and transient
            shares of other machines are in different name spaces, so they don't
            have to have unique names.
        </desc>

        <attribute name="name" type="wstring" readonly="yes">
            <desc>Logical name of the shared folder.</desc>
        </attribute>

        <attribute name="hostPath" type="wstring" readonly="yes">
            <desc>Full path to the shared folder in the host file system.</desc>
        </attribute>

        <attribute name="accessible" type="boolean" readonly="yes">
            <desc>
                Whether the folder defined by the host path is currently
                accessible or not.
                For example, the folder can be unaccessible if it is placed
                on the network share that is not available by the time
                this property is read.
            </desc>
        </attribute>

    </interface>

    <!--
    // ISession
    /////////////////////////////////////////////////////////////////////////
    -->

    <interface
        name="IInternalSessionControl" extends="$unknown"
        uuid="A99D5EB3-02DE-48e4-B059-91A8A41B4DA1"
        internal="yes"
        wsmap="suppress"
    >
        <method name="getPID">
            <desc>PID of the process that has created this Session object.
            </desc>
            <param name="pid" type="unsigned long" dir="return"/>
        </method>

        <method name="getRemoteConsole">
            <desc>Returns the console object suitable for remote control.</desc>
            <param name="console" type="IConsole" dir="return"/>
        </method>

        <method name="assignMachine">
            <desc>
                Assigns the machine object associated with this direct-type
                session or informs the session that it will be a remote one
                (if machine = NULL).
            </desc>
            <param name="machine" type="IMachine" dir="in"/>
        </method>

        <method name="assignRemoteMachine">
            <desc>
                Assigns the machine and the (remote) console object associated with
                this remote-type session.
            </desc>
            <param name="machine" type="IMachine" dir="in"/>
            <param name="console" type="IConsole" dir="in"/>
        </method>

        <method name="updateMachineState">
            <desc>
                Updates the machine state in the VM process.
                Must be called only in certain cases
                (see the method implementation).
            </desc>
            <param name="aMachineState" type="MachineState" dir="in"/>
        </method>

        <method name="uninitialize">
            <desc>
                Uninitializes (closes) this session. Used by VirtualBox to close
                the corresponding remote session when the direct session dies
                or gets closed.
            </desc>
        </method>

        <method name="onDVDDriveChange">
            <desc>
                Triggered when settings of the DVD drive object of the
                associated virtual machine have changed.
            </desc>
        </method>

        <method name="onFloppyDriveChange">
            <desc>
                Triggered when settings of the floppy drive object of the
                associated virtual machine have changed.
            </desc>
        </method>

        <method name="onNetworkAdapterChange">
             <desc>
                 Triggered when settions of a network adapter of the
                 associated virtual machine have changed.
             </desc>
            <param name="networkAdapter" type="INetworkAdapter" dir="in"/>
         </method>

        <method name="onVRDPServerChange">
            <desc>
                Triggered when settings of the VRDP server object of the
                associated virtual machine have changed.
            </desc>
        </method>

        <method name="onUSBControllerChange">
            <desc>
                Triggered when settings of the USB controller object of the
                associated virtual machine have changed.
            </desc>
        </method>

        <method name="onUSBDeviceAttach">
            <desc>
                Triggered when a USB device has just been attached to the host
                computer and is to be auto-captured by the machine according
                to its USB filters.
            </desc>
            <param name="device" type="IUSBDevice" dir="in"/>
        </method>

        <method name="onUSBDeviceDetach">
            <desc>
                Triggered when a USB device has just been detached from the host
                computer and needs to be detached from the machine.
            </desc>
            <param name="id" type="uuid" dir="in"/>
        </method>

    </interface>

    <interface
        name="ISession" extends="$dispatched"
        uuid="12F4DCDB-12B2-4ec1-B7CD-DDD9F6C5BF4D"
        wsmap="wstring"
    >
        <attribute name="state" type="SessionState" readonly="yes">
            <desc>Current state of this session.</desc>
        </attribute>

        <attribute name="type" type="SessionType" readonly="yes">
            <desc>
                Type of this session. The value of this attribute is valid only
                if the session is currently open (i.e. its #state is SessionType::SessionOpen),
                otherwise an error will be returned.
            </desc>
        </attribute>

        <attribute name="machine" type="IMachine" readonly="yes">
            <desc>Machine object associated with this session.</desc>
        </attribute>

        <attribute name="console" type="IConsole" readonly="yes">
            <desc>Console object associated with this session.</desc>
        </attribute>

        <method name="close">
            <desc>
                Closes this session.
                <note>
                    If a direct session for a machine opened with
                    <link to="IVirtualBox::openSession()"/> is not explicitly
                    closed when the application terminates, the state of the
                    machine will be set to <link to="MachineState::Aborted"/>
                    on the server. Generally, it is recommended to close all
                    open sessions explicitly before terminating the application
                    (no matter what is the reason of the termination).
                </note>
            </desc>
        </method>

    </interface>

    <class name="Session" uuid="3C02F46D-C9D2-4f11-A384-53F0CF917214"
           namespace="virtualbox.org">
        <interface name="ISession" default="yes"/>
    </class>


</module>

</idl>
