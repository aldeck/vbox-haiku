<?xml version="1.0" ?>

<!--
 * :tabSize=2:indentSize=2:noTabs=true:
 * :folding=explicit:collapseFolds=1:
 *
 * Master declaration for VirtualBox's Main API, represented
 * by COM/XPCOM and web service interfaces.
 *
 * From this document, the build system generates several files
 * via XSLT that are then used during the build process.
 *
 * Below is the list of XSL templates that operate on this file and
 * output files they generate. These XSL templates must be updated
 * whenever the schema of this file changes:
 *
 * 1. src/VBox/Main/idl/midl.xsl =>
 *    out/<platform>/bin/sdk/idl/VirtualBox.idl
 *    (MS COM interface definition file for Main API)
 *
 * 2. src/VBox/Main/idl/xpidl.xsl =>
 *    out/<platform>/bin/sdk/idl/VirtualBox_XPCOM.idl
 *    (XPCOM interface definition file for Main API)
 *
 * 3. src/VBox/Main/idl/doxygen.xsl =>
 *    out/<platform>/obj/src/VBox/Main/VirtualBox.idl
 *    (pseudo-IDL for Doxygen to generate the official Main API
 *     documentation)
 *
 * 4. src/VBox/Main/webservice/*.xsl =>
 *    a bunch of WSDL and C++ files
 *    (VirtualBox web service sources and SOAP mappers;
 *    see src/VBox/Main/webservice/Makefile.kmk for details)
 *
 * 5. src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl =>
 *    out/<platform>/obj/src/VBox/Frontends/VirtualBox/VirtualBox/include/COMWrappers.h
 *    (smart Qt-based C++ wrapper classes for COM interfaces
 *     of the Main API)
 *
 * 6. src/VBox/Installer/win32/VirtualBox_TypeLib.xsl =>
 *    out/<platform>/obj/src/VBox/Installer/win32/VirtualBox_TypeLib.wxi
 *    (Main API TypeLib block for the WiX installer)
 *
     Copyright (C) 2006-2007 Sun Microsystems, Inc.

     This file is part of VirtualBox Open Source Edition (OSE), as
     available from http://www.virtualbox.org. This file is free software;
     you can redistribute it and/or modify it under the terms of the GNU
     General Public License (GPL) as published by the Free Software
     Foundation, in version 2 as it comes in the "COPYING" file of the
     VirtualBox OSE distribution. VirtualBox OSE is distributed in the
     hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

     Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
     Clara, CA 95054 USA or visit http://www.sun.com if you need
     additional information or have any questions.
-->

<idl>

<if target="midl">
  <cpp line="enum {"/>
  <cpp line="    kTypeLibraryMajorVersion = 1,"/>
  <cpp line="    kTypeLibraryMinorVersion = 0"/>
  <cpp line="};"/>
</if>

<if target="xpidl">
  <!-- NS_IMPL_THREADSAFE_ISUPPORTSxx_CI macros are placed here, for convenience -->
  <cpp>
// currenty, nsISupportsImpl.h lacks the below-like macros
#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_CI
#define NS_IMPL_THREADSAFE_ISUPPORTS1_CI(_class, _interface)                  \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_QUERY_INTERFACE1_CI(_class, _interface)                             \
  NS_IMPL_CI_INTERFACE_GETTER1(_class, _interface)
#endif
#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_CI
#define NS_IMPL_THREADSAFE_ISUPPORTS2_CI(_class, _i1, _i2)                    \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_QUERY_INTERFACE2_CI(_class, _i1, _i2)                               \
  NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif
  </cpp>
</if>

<library
   name="VirtualBox"
   uuid="46137EEC-703B-4fe5-AFD4-7C9BBBBA0259"
   version="1.3"
   desc="innotek VirtualBox Type Library"
   appUuid="819B4D85-9CEE-493C-B6FC-64FFE759B3C9"
   supportsErrorInfo="yes"
>

  <!--
  // all common enums
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="TSBool"
    uuid="523ff64d-842a-4b1a-80e7-c311b028cb3a"
  >
    <desc>
      Boolean variable having a third state, default.
    </desc>

    <const name="False"   value="0"/>
    <const name="True"    value="1"/>
    <const name="Default" value="2"/>
  </enum>

  <enum
    name="MachineState"
    uuid="73bf04d0-7c4f-4684-9abf-d65a9ad74343"
  >
    <desc>
      Virtual machine execution state. This enumeration represents possible
      values of the <link to="IMachine::state"/> attribute.
    </desc>

    <const name="Null"                  value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="PoweredOff"            value="1">
      <desc>
        The machine is not running.
      </desc>
    </const>
    <const name="Saved"                 value="2">
      <desc>
        The machine is not currently running, but the execution state
        of the machine has been saved to an external file when it
        was running.
        <note>
          No any machine settings can be altered when the machine
          is in this state.
        </note>
      </desc>
    </const>
    <const name="Aborted"               value="3">
      <desc>
        A process that run the machine has abnormally terminated.
        Other than that, this value is equivalent to #PoweredOff.
      </desc>
    </const>
    <const name="Running"               value="4">
      <desc>
        The machine is currently being executed.
        <note>
          This value can be used in comparison expressions:
          all state values below it describe a virtual machine that is
          not currently being executed (i.e., it is completely out of
          action).
        </note>
        <note>
          For whoever decides to touch this enum: In order to keep the
          aforementioned comparisons valid, this state must immediately
          preceed the Paused state.
        </note>
      </desc>
    </const>
    <const name="Paused"                value="5">
      <desc>
        The execution of the machine has been paused.
        <note>
          This value can be used in comparison expressions: all state values
          above it represent unstable states of the running virtual
          machine. Unless explicitly stated otherwise, no machine settings can
          be altered when it is in one of the unstable sates.
        </note>
        <note>
          For whoever decides to touch this enum: In order to keep the
          aforementioned comparisons valid, this state must immediately
          follow the Running state.
        </note>
      </desc>
    </const>
    <const name="Stuck"                 value="6">
      <desc>
        The execution of the machine has reached the Guru Meditaion
        condition. This condition indicates an internal VMM failure which may
        happen as a result of either an unhandled low-level virtual hardware
        exception or one of the recompiler exceptions (such as
        the <i>too-many-traps</i> condition).
      </desc>
    </const>
    <const name="Starting"              value="7">
      <desc>
        The machine is being started after
        <link to="IConsole::powerUp">powering it on</link> from a
        zero execution state.
      </desc>
    </const>
    <const name="Stopping"              value="8">
      <desc>
        The machine is being normally stopped
        (after explicitly <link to="IConsole::powerDown">powering it off</link>,
        or after the guest OS has initiated a shutdown sequence).
      </desc>
    </const>
    <const name="Saving"                value="9">
      <desc>
        The machine is saving its execution state to a file as a
        result of calling <link to="IConsole::saveState"/> or an online
        snapshot of the machine is being taken using
        <link to="IConsole::takeSnapshot"/>.
      </desc>
    </const>
    <const name="Restoring"             value="10">
      <desc>
        The execution state of the machine is being restored from a file
        after <link to="IConsole::powerUp">powering it on</link> from
        a saved execution state.
      </desc>
    </const>
    <const name="Discarding"            value="11">
      <desc>
        A snapshot of the machine is being discarded after calling
        <link to="IConsole::discardSnapshot"/> or its current state is
        being discarded after <link to="IConsole::discardCurrentState"/>.
      </desc>
    </const>
  </enum>

  <enum
    name="SessionState"
    uuid="CF2700C0-EA4B-47ae-9725-7810114B94D8"
  >
    <desc>
      Session state. This enumeration represents possible values of
      <link to="IMachine::sessionState"/> and <link to="ISession::state"/>
      attributes. Idividual value descriptions contain the appropriate
      meaning for every case.
    </desc>

    <const name="Null"                  value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="Closed"                value="1">
      <desc>
        The machine has no open sessions (<link to="IMachine::sessionState"/>);
        the session is closed (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Open"                  value="2">
      <desc>
        The machine has an open direct session (<link to="IMachine::sessionState"/>);
        the session is open (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Spawning"              value="3">
      <desc>
        A new (direct) session is being opened for the machine
        as a result of <link to="IVirtualBox::openRemoteSession()"/>
        call (<link to="IMachine::sessionState"/>);
        the session is currently being opened
        as a result of <link to="IVirtualBox::openRemoteSession()"/>
        call (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Closing"               value="4">
      <desc>
        The direct session is being closed (<link to="IMachine::sessionState"/>);
        the session is being closed (<link to="ISession::state"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="SessionType"
    uuid="A13C02CB-0C2C-421E-8317-AC0E8AAA153A"
  >
    <desc>
      Session type. This enumeration represents possible values of the
      <link to="ISession::type"/> attribute.
    </desc>

    <const name="Null"                  value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="Direct"                value="1">
      <desc>
        Direct session
        (opened by <link to="IVirtualBox::openSession()"/>)
      </desc>
    </const>
    <const name="Remote"                value="2">
      <desc>
        Remote session
        (opened by <link to="IVirtualBox::openRemoteSession()"/>)
      </desc>
    </const>
    <const name="Existing"              value="3">
      <desc>
        Existing session
        (opened by <link to="IVirtualBox::openExistingSession()"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="DeviceType"
    uuid="6d9420f7-0b56-4636-99f9-7346f1b01e57"
  >
    <desc>
      Device type.
    </desc>
    <const name="Null"              value="0">
      <desc>
        <tt>null</tt> value which may also mean "no device".
        <note>
          This value is not allowed for
          <link to="IConsole::getDeviceActivity"/>
        </note>
      </desc>
    </const>
    <const name="Floppy"            value="1">
      <desc>Floppy device.</desc>
    </const>
    <const name="DVD"               value="2">
      <desc>CD/DVD-ROM device.</desc>
    </const>
    <const name="HardDisk"          value="3">
      <desc>Hard disk device.</desc>
    </const>
    <const name="Network"           value="4">
      <desc>Network device.</desc>
    </const>
    <const name="USB"               value="5">
      <desc>USB device.</desc>
    </const>
    <const name="SharedFolder"      value="6">
      <desc>Shared folder device.</desc>
    </const>
  </enum>

  <enum
    name="DeviceActivity"
    uuid="6FC8AEAA-130A-4eb5-8954-3F921422D707"
  >
    <desc>
      Device activity for <link to="IConsole::getDeviceActivity"/>.
    </desc>

    <const name="Null"              value="0"/>
    <const name="Idle"              value="1"/>
    <const name="Reading"           value="2"/>
    <const name="Writing"           value="3"/>
  </enum>

  <enum
    name="ResourceUsage"
    uuid="FC56E4B6-B195-48e2-A5E1-A667B0D9F809"
  >
    <desc>
      Usage type constants for
      <link to="IVirtualBox::getDVDImageUsage"/> and
      <link to="IVirtualBox::getFloppyImageUsage"/>.
    </desc>

    <const name="Null"              value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="Permanent"         value="1">
      <desc>
        Scopes the VMs that use the resource permanently
        (the information about this usage is stored in the VM
        settings file).
      </desc>
    </const>
    <const name="Temporary"         value="2">
      <desc>
        Scopes the VMs that are temporarily using the resource
        (the information about the usage is not yet saved in the VM
        settings file). Temporary usage can take place only in the
        context of an open session.
      </desc>
    </const>
    <const name="All"               value="3">
      <desc>
        Combines Permanent and Temporary.
      </desc>
    </const>
  </enum>

  <enum
    name="StorageBus"
    uuid="715984a5-093c-43bb-aa42-a16ed16828dd"
  >
    <desc>Interface bus type for storage devices.</desc>

    <const name="Null"              value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>

    <const name="IDE"      value="1"/>
    <const name="SATA"     value="2"/>
  </enum>

  <enum
    name="ClipboardMode"
    uuid="33364716-4008-4701-8f14-be0fa3d62950"
  >
    <desc>
     Host-Guest clipboard interchange mode.
    </desc>

    <const name="Disabled"          value="0"/>
    <const name="HostToGuest"       value="1"/>
    <const name="GuestToHost"       value="2"/>
    <const name="Bidirectional"     value="3"/>
  </enum>

  <enum
    name="Scope"
    uuid="7c91096e-499e-4eca-9f9b-9001438d7855"
  >
    <desc>
      Scope of the operation.

      A generic enumeration used in various methods to define the action or
      argument scope.
    </desc>

    <const name="Global"          value="0"/>
    <const name="Machine"         value="1"/>
    <const name="Session"         value="2"/>
  </enum>

  <enum
    name="GuestStatisticType"
    uuid="aa7c1d71-aafe-47a8-9608-27d2d337cf55"
  >
    <desc>
      Statistics type for <link to="IGuest::getStatistic"/>.
    </desc>

    <const name="CPULoad_Idle"         value="0">
      <desc>
        Idle CPU load (0-100%) for last interval.
      </desc>
    </const>
    <const name="CPULoad_Kernel"       value="1">
      <desc>
        Kernel CPU load (0-100%) for last interval.
      </desc>
    </const>
    <const name="CPULoad_User"         value="2">
      <desc>
        User CPU load (0-100%) for last interval.
      </desc>
    </const>
    <const name="Threads"              value="3">
      <desc>
        Total number of threads in the system.
      </desc>
    </const>
    <const name="Processes"            value="4">
      <desc>
        Total number of processes in the system.
      </desc>
    </const>
    <const name="Handles"              value="5">
      <desc>
        Total number of handles in the system.
      </desc>
    </const>
    <const name="MemoryLoad"           value="6">
      <desc>
        Memory load (0-100%).
      </desc>
    </const>
    <const name="PhysMemTotal"         value="7">
      <desc>
        Total physical memory in megabytes.
      </desc>
    </const>
    <const name="PhysMemAvailable"     value="8">
      <desc>
        Free physical memory in megabytes.
      </desc>
    </const>
    <const name="PhysMemBalloon"       value="9">
      <desc>
        Ballooned physical memory in megabytes.
      </desc>
    </const>
    <const name="MemCommitTotal"       value="10">
      <desc>
        Total amount of memory in the committed state in megabytes.
      </desc>
    </const>
    <const name="MemKernelTotal"       value="11">
      <desc>
        Total amount of memory used by the guest OS's kernel in megabytes.
      </desc>
    </const>
    <const name="MemKernelPaged"       value="12">
      <desc>
        Total amount of paged memory used by the guest OS's kernel in megabytes.
      </desc>
    </const>
    <const name="MemKernelNonpaged"    value="13">
      <desc>
        Total amount of nonpaged memory used by the guest OS's kernel in megabytes.
      </desc>
    </const>
    <const name="MemSystemCache"       value="14">
      <desc>
        Total amount of memory used by the guest OS's system cache in megabytes.
      </desc>
    </const>
    <const name="PageFileSize"         value="15">
      <desc>
        Pagefile size in megabytes.
      </desc>
    </const>
    <const name="SampleNumber"         value="16">
      <desc>
        Statistics sample number
      </desc>
    </const>
    <const name="MaxVal"               value="17"/>
  </enum>

  <enum
    name="BIOSBootMenuMode"
    uuid="ae4fb9f7-29d2-45b4-b2c7-d579603135d5"
  >
    <desc>
      BIOS boot menu mode.
    </desc>

    <const name="Disabled"        value="0"/>
    <const name="MenuOnly"        value="1"/>
    <const name="MessageAndMenu"  value="2"/>
  </enum>

  <enum
    name="IDEControllerType"
    uuid="445330e3-202a-4dab-854f-ce22e6cb9715"
  >
    <desc>
      IDE controller type.
    </desc>

    <const name="Null"            value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="PIIX3"           value="1"/>
    <const name="PIIX4"           value="2"/>
  </enum>

  <enum
    name="DriveState"
    uuid="cb7233b7-c519-42a5-8310-1830953cacbc"
  >
    <const name="Null"              value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="NotMounted"        value="1"/>
    <const name="ImageMounted"      value="2"/>
    <const name="HostDriveCaptured" value="3"/>
  </enum>

  <!--
  // IVirtualBoxErrorInfo
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualBoxErrorInfo" extends="$errorinfo"
     uuid="e98b5376-8eb4-4eea-812a-3964bf3bb26f"
     supportsErrorInfo="no"
     wsmap="suppress"
     >
    <desc>
      The IVirtualBoxErrorInfo interface represents extended error information.

      Extended error information can be set by VirtualBox components after
      unsuccessful or partially successful method invocation. This information
      can be retrievefd by the calling party as an IVirtualBoxErrorInfo object
      and then shown to the client in addition to the plain 32-bit result code.

      In MS COM, this interface extends the IErrorInfo interface,
      in XPCOM, it extends the nsIException interface. In both cases,
      it provides a set of common attributes to retrieve error
      information.

      Sometimes invocation of some component's method may involve methods of
      other components that may also fail (independently of this method's
      failure), or a series of non-fatal errors may precede a fatal error that
      causes method failure. In cases like that, it may be desirable to preserve
      information about all errors happened during method invocation and deliver
      it to the caller. The <link to="#next"/> attribute is intended
      specifically for this purpose and allows to represent a chain of errors
      through a single IVirtualBoxErrorInfo object set after method invocation.

      Note that errors are stored to a chain in the reverse order, i.e. the
      initial error object you query right after method invocation is the last
      error set by the callee, the object it points to in the @a next attribute
      is the previous error and so on, up to the first error (which is the last
      in the chain).
    </desc>

    <attribute name="resultCode" type="result" readonly="yes">
      <desc>
        Result code of the error.
        Usually, it will be the same as the result code returned
        by the method that provided this error information, but not
        always. For example, on Win32, CoCreateInstance() will most
        likely return E_NOINTERFACE upon unsuccessful component
        instantiation attempt, but not the value the component factory
        returned.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::result.
        </note>
      </desc>
    </attribute>

    <attribute name="interfaceID" type="uuid" readonly="yes">
      <desc>
        UUID of the interface that defined the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetGUID.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="component" type="wstring" readonly="yes">
      <desc>
        Name of the component that generated the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetSource.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="text" type="wstring" readonly="yes">
      <desc>
        Text description of the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetDescription.
          In XPCOM, it is the same as nsIException::message.
        </note>
      </desc>
    </attribute>

    <attribute name="next" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Next error object if there is any, or @c null otherwise.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::inner.
        </note>
      </desc>
    </attribute>

  </interface>


  <!--
  // IVirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualBoxCallback" extends="$unknown"
     uuid="ee95ffc2-b6c6-4ce8-9e9e-ceadbb5019fe"
     wsmap="suppress"
     >
    <method name="onMachineStateChange">
      <desc>
        The execution state of the given machine has changed.
        <see>IMachine::state</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="state" type="MachineState" dir="in">
        <desc>New execution state.</desc>
      </param>
    </method>

    <method name="onMachineDataChange">
      <desc>
        Any of the settings of the given machine has changed.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
    </method>

    <method name="onExtraDataCanChange">
      <desc>
        Notification when someone tries to change extra data for
        either the given machine or (if null) global extra data.
        This gives the chance to veto against changes.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>
          ID of the machine this event relates to
          (null ID for global extra data change requests).
        </desc>
      </param>
      <param name="key" type="wstring" dir="in">
        <desc>
          Extra data key for the attempted write.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          Extra data value for the given key.
        </desc>
      </param>
      <param name="error" type="wstring" dir="out">
        <desc>
          Optional error message describing the reason of the
          veto (ignored if this notification returns @c true).
        </desc>
      </param>
      <param name="allowChange" type="boolean" dir="return">
        <desc>
          Flag to indicate whether the callee agrees (@ true)
          or vetoes against the change (@ false).
        </desc>
      </param>
    </method>

    <method name="onExtraDataChange">
      <desc>
        Notification when machine specific or global extra data
        has changed.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>
          ID of the machine this event relates to.
          Null for global extra data changes.
        </desc>
      </param>
      <param name="key" type="wstring" dir="in">
        <desc>
          Extra data key that has changed.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          Extra data value for the given key.
        </desc>
      </param>
    </method>

    <method name="onMediaRegistered">
      <desc>
        The given media was registered or unregistered
        within this VirtualBox installation.

        The @a mediaType parameter describes what type of
        media the specified @a mediaId refers to. Possible
        values are:

        - <link to="DeviceType::HardDisk"/>: the media is a hard disk
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getHardDisk"/> call.
        - <link to="DeviceType::DVD"/>: the media is a CD/DVD image
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getDVDImage"/> call.
        - <link to="DeviceType::Floppy"/>: the media is a Floppy image
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getFloppyImage"/> call.

        Note that if this is a deregistration notification,
        there is no way to access the object representing the
        unregistered media. It is supposed that the
        application will do required cleanup based on the @a
        mediaId value.
      </desc>
      <param name="mediaId" type="uuid" dir="in">
        <desc>ID of the media this event relates to.</desc>
      </param>
      <param name="mediaType" type="DeviceType" dir="in">
        <desc>Type of the media this event relates to.</desc>
      </param>
      <param name="registered" type="boolean" dir="in">
        <desc>
          If true, the media was registered, otherwise it was
          unregistered.
        </desc>
      </param>
    </method>

    <method name="onMachineRegistered">
      <desc>
        The given machine was registered or unregistered
        within this VirtualBox installation.
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="registered" type="boolean" dir="in">
        <desc>
          If true, the machine was registered, otherwise it was
          unregistered.
        </desc>
      </param>
    </method>

    <method name="onSessionStateChange">
      <desc>
        The state of the session for the given machine was changed.
        <see>IMachine::sessionState</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="state" type="SessionState" dir="in">
        <desc>New session state.</desc>
      </param>
    </method>

    <method name="onSnapshotTaken">
      <desc>
        A new snapshot of the machine has been taken.
        <see>ISnapshot</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" dir="in">
        <desc>ID of the new snapshot.</desc>
      </param>
    </method>

    <method name="onSnapshotDiscarded">
      <desc>
        Snapshot of the given machine has been discarded.

        <note>
          This notification is delivered <b>after</b> the snapshot
          object has been uninitialized on the server (so that any
          attempt to call its methods will return an error).
        </note>

        <see>ISnapshot</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" dir="in">
        <desc>
          ID of the discarded snapshot. <tt>null</tt> means the
          current machine state has been discarded (restored from
          the current snapshot).
        </desc>
      </param>
    </method>

    <method name="onSnapshotChange">
      <desc>
        Snapshot properties (name and/or description) have been changed.
        <see>ISnapshot</see>
      </desc>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" dir="in">
        <desc>ID of the changed snapshot.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IVirtualBox" extends="$dispatched"
    uuid="2d3b9ea7-25f5-4f07-a8e1-7dd7e0dcf667"
    wsmap="managed"
  >
    <desc>
      The IVirtualBox interface represents the main interface exposed by the
      product that provides virtual machine management.

      An instance of IVirtualBox is required for the product to do anything
      useful. Even though the interface does not expose this, internally,
      IVirtualBox is implemented as a singleton and actually lives in the
      process of the VirtualBox server (VBoxSVC.exe). This makes sure that
      IVirtualBox can track the state of all virtual machines on a particular
      host, regardless of which frontend started them.

      To enumerate all the virtual machines on the host, use the
      <link to="IVirtualBox::machines"/> attribute.
    </desc>

    <attribute name="version" type="wstring" readonly="yes">
      <desc>
        A string representing the version number of the product. The
        format is 3 integer numbers divided by dots (e.g. 1.0.1). The
        last number represents the build number and will frequently change.
      </desc>
    </attribute>

    <attribute name="homeFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the directory where the global settings file,
        <tt>VirtualBox.xml</tt>, is stored.

        In this version of VirtualBox, the value of this property is
        always <tt>&lt;user_dir&gt;/.VirtualBox</tt> (where
        <tt>&lt;user_dir&gt;</tt> is the path to the user directory,
        as determined by the host OS), and cannot be changed.

        This path is also used as the base to resolve relative paths in
        places where relative paths are allowed (unless otherwise
        expressly indicated).
      </desc>
    </attribute>

		<attribute name="settingsFilePath" type="wstring" readonly="yes">
			<desc>
				Full name of the global settings file.
				The value of this property corresponds to the value of
				<link to="#homeFolder"/> plus <tt>/VirtualBox.xml</tt>.
			</desc>
		</attribute>

    <attribute name="settingsFileVersion" type="wstring" readonly="yes">
      <desc>
        Current version of the format of the global VirtualBox settings file
        (<tt>VirtualBox.xml</tt>).

        The version string has the following format:
        <pre>
          x.y-platform
        </pre>
        where <tt>x</tt> and <tt>y</tt> are the major and the minor format
        versions, and <tt>platform</tt> is the platform identifier.

        The current version usually matches the value of the
        <link to="#settingsFormatVersion"/> attribute unless the
				settings file was created by an older version of VirtualBox and there
        was a change of the settings file format since then.

        Note that VirtualBox automatically converts settings files from older
        versions to the most recent version when reading them (usually at
        VirtualBox startup) but it doesn't save the changes back until
        you call a method that implicitly saves settings (such as
        <link to="#setExtraData()"/>) or call <link to="#saveSettings()"/>
        explicitly. Therefore, if the value of this attribute differs from the
        value of <link to="#settingsFormatVersion"/>, then it
        means that the settings file was converted but the result of the
        conversion is not yet saved to disk.

        The above feature may be used by interactive front-ends to inform users
        about the settings file format change and offer them to explicitly save
        all converted settings files (the global and VM-specific ones),
        optionally create bacup copies of the old settings files before saving,
        etc.

        <see>settingsFormatVersion, saveSettingsWithBackup()</see>
      </desc>
    </attribute>

    <attribute name="settingsFormatVersion" type="wstring" readonly="yes">
      <desc>
        Most recent version of the settings file format.

        The version string has the following format:
        <pre>
          x.y-platform
        </pre>
        where <tt>x</tt> and <tt>y</tt> are the major and the minor format
        versions, and <tt>platform</tt> is the platform identifier.

        VirtualBox uses this version of the format when saving settings files
        (either as a result of method calls that require to save settings or as
        a result of an explicit call to <link to="#saveSettings()"/>).

        <see>settingsFileVersion</see>
      </desc>
    </attribute>

    <attribute name="host" type="IHost" readonly="yes">
      <desc>Associated host object.</desc>
    </attribute>

    <attribute name="systemProperties" type="ISystemProperties" readonly="yes">
      <desc>Associated system information object.</desc>
    </attribute>

    <attribute name="machines" type="IMachineCollection" readonly="yes">
      <desc>
        Collection of machine objects registered within this VirtualBox
        instance.
      </desc>
    </attribute>

    <attribute name="machines2" type="IMachine" readonly="yes" safearray="yes">
      <desc>
        Array of machine objects registered within this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="hardDisks" type="IHardDiskCollection" readonly="yes">
      <desc>
        Collection of hard disk objects registered within this VirtualBox
        instance.

        This collection contains only "top-level" (basic or independent) hard
        disk images, but not differencing ones. All differencing images of the
        given top-level image (i.e. all its children) can be enumerated using
        <link to="IHardDisk::children"/>.
      </desc>
    </attribute>

    <attribute name="DVDImages" type="IDVDImageCollection" readonly="yes"/>

    <attribute name="FloppyImages" type="IFloppyImageCollection" readonly="yes"/>

    <attribute name="progressOperations" type="IProgressCollection" readonly="yes"/>

    <attribute name="guestOSTypes" type="IGuestOSTypeCollection" readonly="yes"/>

    <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
      <desc>
        Collection of global shared folders. Global shared folders are
        available to all virtual machines.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.

        <note>
          In the current version of the product, global shared folders are not
          implemented and therefore this collection is always empty.
        </note>
      </desc>
    </attribute>

    <method name="createMachine">
      <desc>
        Creates a new virtual machine.

        The new machine will have "empty" default settings and will not
        yet be registered. The typical sequence to create a virtual machine
        is therefore something like this:

        <ol>
           <li>Call this method (IVirtualBox::createMachine) to have a new
           machine created. The machine object returned is "mutable", i.e.
           automatically locked for the current session, as if
           <link to="#openSession" /> had been called on it.</li>

           <li>Assign meaningful settings to the new machine by calling the
           respective methods.</li>

           <li>Call <link to="IMachine::saveSettings" /> to have the settings written
           to the machine's XML settings file. The configuration of the newly
           created machine will not be saved to disk (and the settings subfolder
           and file, as described below, will not be created) until this method
           is called.</li>

           <li>Call <link to="#registerMachine" /> to have the
           machine show up in the list of machines registered with VirtualBox.</li>
        </ol>

        Every machine has a <i>settings file</i> that is used to store
        the machine configuration. This file is stored in the directory
        called <i>machine settings subfolder</i>. Unless specified otherwise,
        both the subfolder and the settings file will have a name that
        corresponds to the name of the virtual machine. You can specify
        where to create the machine settings subfolder using the @a
        baseFolder argument. The base folder can be absolute (full path)
        or relative to the <link to="IVirtualBox::homeFolder">
          VirtualBox home directory</link>.

        If a null or empty string is given as the base folder (which is
        recommended), the <link to="ISystemProperties::defaultMachineFolder">
          default machine settings folder</link> will be used as the base
        folder to create the machine settings subfolder and file. In
        any case, the full path to the settings file will look like:
        <pre>
          &lt;base_folder&gt;/&lt;machine_name&gt;/&lt;machine_name&gt;.xml
        </pre>

        Optionally the UUID of the machine can be predefined. If this is
        not desired (i.e. a new UUID should be generated), pass just an
        empty or null UUID.

        You should also specify a valid name for the machine.
        See the <link to="IMachine::name"/> property
        description for more details about the machine name.

        The created machine remains
        unregistered until you call <link to="#registerMachine()"/>.

        <note>
          There is no way to change the name of the settings file or
          subfolder of the created machine directly.
        </note>
      </desc>
      <param name="baseFolder" type="wstring" dir="in">
        <desc>
          Name of the folder where to create the machine settings
          subfolder containing the settings file.
        </desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>
          UUID of the newly created VM, when non-null or non-empty.
          Otherwise a UUID is automatically generated.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="createLegacyMachine">
      <desc>
        Creates a new virtual machine in "legacy" mode, using the
        specified settings file to store machine settings.

        As opposed to machines created by <link to="#createMachine()"/>,
        the settings file of the machine created in "legacy" mode
        is not automatically renamed when the machine name is
        changed -- it will always remain the same as specified in this
        method call.

        The specified settings file name can be absolute
        (full path) or relative to the <link to="IVirtualBox::homeFolder">
          VirtualBox home directory</link>. If the file name doesn't
        contain an extension, the default extension (.xml) will be
        appended.

        Optionally the UUID of the machine can be predefined. If this is
        not desired (i.e. a new UUID should be generated), pass just an
        empty or null UUID.

        Note that the configuration of the newly created machine is not
        saved to disk (and therefore no settings file is created)
        until <link to="IMachine::saveSettings()"/> is called. If the
        specified settings file already exists,
        <link to="IMachine::saveSettings()"/> will return an error.

        You should also specify a valid name for the machine.
        See the <link to="IMachine::name"/> property
        description for more details about the machine name.

        The created machine remains
        unregistered until you call <link to="#registerMachine()"/>.

        @deprecated This method may be removed later. It is better
        to use <link to="IVirtualBox::createMachine()"/>.

        <note>
          There is no way to change the name of the settings file
          of the created machine.
        </note>
      </desc>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>
          Name of the file where to store machine settings.
        </desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>
          UUID of the newly created VM, when non-null or non-empty.
          Otherwise a UUID is automatically generated.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="openMachine">
      <desc>
        Opens a virtual machine from the existing settings file.
        The opened machine remains unregistered until you call
        <link to="#registerMachine()"/>.

        The specified settings file name can be absolute
        (full path) or relative to the <link to="IVirtualBox::homeFolder">
          VirtualBox home directory</link>. This file must exist
        and must be a valid machine settings file whose contents
        will be used to construct the machine object.

        @deprecated Will be removed soon.
      </desc>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>
          Name of the machine settings file.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Opened machine object.</desc>
      </param>
      <note>
        <link to="IMachine::settingsModified"/> will return
        false for the created machine, until any of machine settigs
        are changed.
      </note>
    </method>

    <method name="registerMachine">
      <desc>

        Registers the machine previously created using
        <link to="#createMachine()"/> or opened using
        <link to="#openMachine()"/> within this VirtualBox installation. After
        successful method invocation, the
        <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
        to all registered callbacks.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/>
          to save all current machine settings before registering it.
        </note>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="getMachine">
      <desc>
        Attempts to find a virtual machine given its UUID.
        To look up a machine by name, use <link to="IVirtualBox::findMachine" /> instead.
      </desc>
      <param name="id" type="uuid" dir="in"/>
      <param name="machine" type="IMachine" dir="return"/>
    </method>

    <method name="findMachine">
      <desc>
        Attempts to find a virtual machine given its name.
        To look up a machine by UUID, use <link to="IVirtualBox::getMachine" /> instead.
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="machine" type="IMachine" dir="return"/>
    </method>

    <method name="unregisterMachine">
      <desc>

        Unregisters the machine previously registered using
        <link to="#registerMachine"/>. After successful method invocation, the
        <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
        to all registered callbacks.

        <note>
          The specified machine must not be in the Saved state, have an open
          (or a spawning) direct session associated with it, have snapshots or
          have hard disks attached.
        </note>

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/> to
          save all current machine settings before unregistering it.
        </note>

        <note>
          If the given machine is inaccessible (see
          <link to="IMachine::accessible"/>), it will be unregistered and
          fully uninitialized right afterwards. As a result, the returned
          machine object will be unusable and an attempt to call
          <b>any</b> method will return the "Object not ready" error.
        </note>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the machine to unregister.</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Unregistered machine object.</desc>
      </param>
    </method>

    <method name="createHardDisk">
      <desc>

        Creates a new unregistered hard disk that will use the given
        storage type.

        Most properties of the created hard disk object are
        uninitialized. Valid values must be assigned to them (and probalby
        some actions performed) to make the actual usage of this hard disk
        (<link to="#registerHardDisk()">register</link>, attach to a virtual
        machine, etc.). See the description of <link to="IHardDisk"/> and
        descriptions of storage type specific interfaces for more information.

        <note>
          For hard disks using
          the <link
          to="HardDiskStorageType::VirtualDiskImage">VirtualDiskImage</link>
          storage type, an image file is not actually created until you call
          <link to="IVirtualDiskImage::createDynamicImage()"/> or
          <link to="IVirtualDiskImage::createFixedImage()"/>.
        </note>

      </desc>

      <param name="storageType" type="HardDiskStorageType" dir="in">
        <desc>Storage type of the hard disk image to create.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk" dir="return">
        <desc>Created hard disk object of the given storage type.</desc>
      </param>

    </method>

    <method name="openHardDisk">
      <desc>

        Opens a hard disk from an existing location.

        This method tries to guess the
        <link to="HardDiskStorageType">hard disk storage type</link> from the
        format of the location string and from the contents of the resource the
        location points to. Currently, a <i>file path</i> is the only
        supported format for the location string which must point to either a
        VDI file or to a VMDK file. On success, an IHardDisk object will be
        returned that also implements the corresponding interface
        (IVirtualDiskImage or IVMDKImage, respectively). The
        <link to="IHardDisk::storageType"/> property may also be used to
        determine the storage type of the returned object (instead of trying
        to query one of these interfaces).

        <note>
          The specified file path can be absolute (full path) or relative to
          the <link to="IVirtualBox::homeFolder">VirtualBox home
          directory</link>. If only a file name without any path is given,
          the <link to="ISystemProperties::defaultVDIFolder"> default VDI
          folder</link> will be used as a path to the image file.
        </note>

        The opened hard disk remains unregistered
        until <link to="#registerHardDisk()"/> is called.

      </desc>

      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the resource that contains a valid hard disk.
        </desc>
      </param>
      <param name="hardDisk" type="IHardDisk" dir="return">
        <desc>Opened hard disk object.</desc>
      </param>
    </method>

    <method name="openVirtualDiskImage">
      <desc>

        Opens a hard disk from an existing Virtual Disk Image file.
        The opened hard disk remains unregistered
        until <link to="#registerHardDisk()"/> is called.

        @deprecated Use <link to="IVirtualBox::openHardDisk()"/> instead.

        <note>Opening differencing images is not supported.</note>

        <note>The specified file path can be absolute (full path) or
          relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
            home directory</link>. If only a file name without any path is
          given, the <link to="ISystemProperties::defaultVDIFolder">
            default VDI folder</link> will be used as a path to the image
          file.</note>

      </desc>

      <param name="filePath" type="wstring" dir="in">
        <desc>
          Name of the file that contains a valid Virtual Disk Image.
        </desc>
      </param>
      <param name="image" type="IVirtualDiskImage" dir="return">
        <desc>Opened hard disk object.</desc>
      </param>
    </method>

    <method name="registerHardDisk">
      <desc>

        Registers the given hard disk within this VirtualBox
        installation. The hard disk must not be registered, must be
        <link to="IHardDisk::accessible"/> and must not be a
        differencing hard disk, otherwise the registration will fail.

      </desc>
      <param name="hardDisk" type="IHardDisk" dir="in">
        <desc>Hard disk object to register.</desc>
      </param>
    </method>

    <method name="getHardDisk" const="yes">
      <desc>
        Returns the registered hard disk with the given UUID.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the hard disk to look for.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk" dir="return">
        <desc>Found hard disk object.</desc>
      </param>
    </method>

    <method name="findHardDisk">
      <desc>

        Returns a registered hard disk that uses the given location to
        store data. The search is done by comparing the
        value of the @a location argument to the
        <link to="IHardDisk::location"/> attribute of each registered
        hard disk.

        For locations repesented by file paths (such as VDI and VMDK
        images), the specified location can be either an absolute file
        path or a path relative to
        the <link to="IVirtualBox::homeFolder"> VirtualBox home
          directory</link>. If only a file name without any path is
        given, the <link to="ISystemProperties::defaultVDIFolder">
          default VDI folder</link> will be used as a path to construct
        the absolute image file name to search for. Note that on host
        systems with case sensitive filesystems, a case sensitive
        comparison is performed, otherwise the case of symbols in the
        file path is ignored.

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>Hard disk location specification to search for.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk" dir="return">
        <desc>Found hard disk object.</desc>
      </param>
    </method>

    <method name="findVirtualDiskImage">
      <desc>

        Returns a registered hard disk that uses the given image file.

        @deprecated Use <link to="IVirtualBox::findHardDisk()"/> instead.

        <note>The specified file path can be absolute (full path) or
          relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
            home directory</link>. If only a file name without any path is
          given, the <link to="ISystemProperties::defaultVDIFolder">
            default VDI folder</link> will be used as a path to the image
          file.</note>

        <note>On host systems with case sensitive filesystems, a case
          sensitive comparison is performed, otherwise the case of symbols
          in the file path is ignored.</note>

      </desc>
      <param name="filePath" type="wstring" dir="in">
        <desc>Virtual Disk Image file path to look for.</desc>
      </param>
      <param name="image" type="IVirtualDiskImage" dir="return">
        <desc>Found hard disk object.</desc>
      </param>
    </method>

    <method name="unregisterHardDisk">
      <desc>
        Unregisters a hard disk previously registered using
        <link to="#registerHardDisk()"/>.
        <note>
          The specified hard disk must not be attached to any of
          the existing virtual machines and must not have children
          (differencing) hard disks.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the hard disk to unregister.</desc>
      </param>
      <param name="hardDisk" type="IHardDisk" dir="return">
        <desc>Unregistered hard disk object.</desc>
      </param>
    </method>

    <method name="openDVDImage">
      <desc>
        Opens the CD/DVD image contained in the specified file of
        the supported format and assigns it the given UUID. The opened
        image remains unregistered
        until <link to="#registerDVDImage()"/> is called.
      </desc>
      <param name="filePath" type="wstring" dir="in">
        <desc>
          Full name of the file that contains a valid
          CD/DVD image. Currently, only ISO images are supported.
          <note>
            The specified file name can be absolute or relative
            to the <link to="IVirtualBox::homeFolder">
              VirtualBox home directory</link>.
          </note>
        </desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>
          UUID to assign to the given image file within this
          VirtualBox installation. If an empty (null) UUID is
          specified, the system will randomly generate an UUID.
        </desc>
      </param>
      <param name="image" type="IDVDImage" dir="return">
        <desc>Opened CD/DVD image object.</desc>
      </param>
    </method>

    <method name="registerDVDImage">
      <desc>
        Registers a CD/DVD image within this VirtualBox
        installation. The image must not be registered and must not
        be associated with the same image file as any of the already
        registered images, otherwise the registration will fail.
      </desc>
      <param name="image" type="IDVDImage" dir="in">
        <desc>CD/DVD image object to register.</desc>
      </param>
    </method>

    <method name="getDVDImage">
      <desc>
        Returns a registered CD/DVD image with the given UUID.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the image to look for.</desc>
      </param>
      <param name="image" type="IDVDImage" dir="return">
        <desc>Found CD/DVD image object.</desc>
      </param>
    </method>

    <method name="findDVDImage">
      <desc>
        Returns a registered CD/DVD image with the given image file.
        <note>
          On host systems with case sensitive filesystems, a case
          sensitive comparison is performed, otherwise the case of
          symbols in the file path is ignored.
        </note>
      </desc>
      <param name="filePath" type="wstring" dir="in">
        <desc>CD/DVD image file path to look for.</desc>
      </param>
      <param name="image" type="IDVDImage" dir="return">
        <desc>Found CD/DVD image object.</desc>
      </param>
    </method>

    <method name="getDVDImageUsage">
      <desc>
        Returns the list of of UUIDs of all virtual machines that use
        the given CD/DVD image.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the image to get the usage information for.</desc>
      </param>
      <param name="usage" type="ResourceUsage" dir="in">
        <desc>Type of the usage (permanent, temporary or all).</desc>
      </param>
      <param name="machineIDs" type="wstring" dir="return">
        <desc>
          List of UUIDs of all machines that use the given image
          in the way specified by the usage parameter.
          The list is returned as a string containing UUIDs separated
          by spaces. A null string means that the image is not used.
          <note>
            When the usage type is <link to="ResourceUsage::All"/> and the image
            is used by the VM both permanently and temporarily, the VM's UUID
            will be present only once in the list.
          </note>
        </desc>
      </param>
    </method>

    <method name="unregisterDVDImage">
      <desc>
        Unregisters the CD/DVD image previously registered using
        <link to="#registerDVDImage()"/>.
        <note>
          The specified image must not be mounted to any of
          the existing virtual machines.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the CD/DVD image to unregister.</desc>
      </param>
      <param name="image" type="IDVDImage" dir="return">
        <desc>Unregistered image object.</desc>
      </param>
    </method>

    <method name="openFloppyImage">
      <desc>
        Opens a floppy image contained in the specified file of
        the supported format and assigns it the given UUID. The opened
        image remains unregistered
        until <link to="#registerFloppyImage()"/> is called.
      </desc>
      <param name="filePath" type="wstring" dir="in">
        <desc>
          Full name of the file that contains a valid
          floppy image.
          <note>
            The specified file name can be absolute or relative
            to the <link to="IVirtualBox::homeFolder">
              VirtualBox home directory</link>.
          </note>
        </desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>
          UUID to assign to the given image file within this
          VirtualBox installation. If an empty (null) UUID is
          specified, the system will randomly generate an UUID.
        </desc>
      </param>
      <param name="image" type="IFloppyImage" dir="return">
        <desc>Opened CD/DVD image object.</desc>
      </param>
    </method>

    <method name="registerFloppyImage">
      <desc>
        Registers a floppy image within this VirtualBox
        installation. The image must not be registered and must not
        be associated with the same image file as any of the already
        registered images, otherwise the registration will fail.
      </desc>
      <param name="image" type="IFloppyImage" dir="in">
        <desc>Floppy image object to register.</desc>
      </param>
    </method>

    <method name="getFloppyImage">
      <desc>
        Returns a registered floppy image with the given UUID.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the image to look for.</desc>
      </param>
      <param name="image" type="IFloppyImage" dir="return">
        <desc>Found floppy image object.</desc>
      </param>
    </method>

    <method name="findFloppyImage">
      <desc>
        Returns a registered floppy image with the given image file.
        <note>
          On host systems with case sensitive filesystems, a case
          sensitive comparison is performed, otherwise the case of
          symbols in the file path is ignored.
        </note>
      </desc>
      <param name="filePath" type="wstring" dir="in">
        <desc>Floppy image file path to look for.</desc>
      </param>
      <param name="image" type="IFloppyImage" dir="return">
        <desc>Found floppy image object.</desc>
      </param>
    </method>

    <method name="getFloppyImageUsage">
      <desc>
        Returns the list of of UUIDs of all virtual machines that use
        the given floppy image.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the image to get the usage information for.</desc>
      </param>
      <param name="usage" type="ResourceUsage" dir="in">
        <desc>Type of the usage (permanent, temporary or all).</desc>
      </param>
      <param name="machineIDs" type="wstring" dir="return">
        <desc>
          List of UUIDs of all machines that use the given image
          in the way specified by the usage parameter.
          The list is returned as a string containing UUIDs separated
          by spaces. A null string means that the image is not used.
          <note>
            When the usage type is <link to="ResourceUsage::All"/> and the image
            is used by the VM both permanently and temporarily, the VM's UUID
            will be present only once in the list.
          </note>
        </desc>
      </param>
    </method>

    <method name="unregisterFloppyImage">
      <desc>
        Unregisters the floppy image previously registered using
        <link to="#registerFloppyImage()"/>.
        <note>
          The specified image must not be mounted to any of
          the existing virtual machines.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the floppy image to unregister.</desc>
      </param>
      <param name="image" type="IFloppyImage" dir="return">
        <desc>Unregistered image object.</desc>
      </param>
    </method>

    <method name="getGuestOSType">
      <param name="id" type="wstring" dir="in"/>
      <param name="type" type="IGuestOSType" dir="return"/>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new global shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the global shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="getNextExtraDataKey">
      <desc>
        Returns the global extra data key name following the supplied key.

        An error is returned if the supplied @a key does not exist. @c NULL is
        returned in @a nextKey if the supplied key is the last key. When
        supplying @c NULL for the @a key, the first key item is returned in @a
        nextKey (if there is any). @a nextValue is an optional parameter and
        if supplied, the next key's value is returned in it.
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to follow.</desc>
      </param>
      <param name="nextKey" type="wstring" dir="out">
        <desc>Name of the next data key.</desc>
      </param>
      <param name="nextValue" type="wstring" dir="out">
        <desc>Value of the next data key.</desc>
      </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated global extra data.

        If the reuqested data @a key does not exist, this function will
        succeed and return @c NULL in the @a value argument.
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated global extra data.

        If you pass @c NULL as a key @a vaule, the given @a key will be
        deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered callbacks using the
          <link to="IVirtualBoxCallback::onExtraDataCanChange()"/>
          notification for a permission. If one of the callbacks refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IVirtualBoxCallback::onExtraDataChange()"/> notification
          is called to inform all registered callbacks about a successful data
          change.
        </note>
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="openSession">
      <desc>
        Opens a new direct session with the given virtual machine.

        Within the direct session context, it is possible to change
        all VM settings, as well as to execute the VM in the process
        space of the session object. There can be only one direct
        session open at a time for every virtual machine. In VirtualBox
        terminology, the machine becomes "mutable" after a session has
        been opened.

        Upon successful return, the session object can be used to
        get access to the machine and to the VM console.

        Note that the "mutable" machine object, on which you may want
        to invoke IMachine methods to change its settings, will be a
        different object from the immutable IMachine objects returned
        by various IVirtualBox methods. To obtain a mutable
        IMachine object, upon which you can invoke settings methods,
        use the "machine" attribute of the ISession object which represents
        your open session.

        In other words, to change settings on a machine, the following
        sequence is typically performed:

        <ol>
        <li>Call this method (openSession) to have a machine locked for
        the current session.</li>

        <li>Obtain a mutable IMachine object from ISession::machine.</li>

        <li>Change the settings of the machine.</li>

        <li>Call IMachine::saveSettings.</li>

        <li>Close the session by calling <link to="#close" />.</li>
        </ol>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the opened session after
          successful method invocation. This object must not represent
          the already open session.
          <note>
            This session will be automatically closed if the
            VirtualBox server is terminated for some reason.
          </note>
        </desc>
      </param>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
    </method>

    <method name="openRemoteSession">
      <desc>
        Opens a new remote session with the given virtual
        machine.

        Opening a remote session causes the VirtualBox server to start a new
        process that opens a direct session with the given VM.  The remote
        session provides some level of control over the VM execution to the
        caller (using the IConsole interface); however, within the remote
        session context, not all VM settings are available for modification.

        This operation can take some time, so the progress object
        is returned to let the caller be informed when the session is
        actually open. Until then, the remote session object remains in
        the closed state and accessing the machine or its console through
        it is invalid.

        Currently supported session types (values of the @a type
        argument) are:
        <ul>
          <li><tt>gui</tt>: VirtualBox Qt GUI session</li>
          <li><tt>vrdp</tt>: VirtualBox VRDP Server session</li>
        </ul>

        The @a environment argument is a string containing definitions of
        environment variables in the following format:
        @code
          NAME[=VALUE]\n
          NAME[=VALUE]\n
          ...
        @endcode
        where <tt>\\n</tt> is the new line character. These environment
        variables will be appended to the environment of the VirtualBox server
        process. If an environment variable exists both in the server process
        and in this list, the value from this list takes precedence over the
        server's variable. If the value of the environment variable is
        omitted, this variable will be removed from the resulting environment.
        If the environment string is @c null, the server environment is
        inherited by the started process as is.

        <note>
          It is an error to open a remote session with the machine
          that already has an open direct session or waits until the
          previous request to open the remote session is completed
          (see <link to="IMachine::sessionState"/>).
        </note>

        <note>
          The opened @a session will be automatically closed when
          the corresponding direct session dies or gets closed.
        </note>

        <see>openExistingSession</see>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the opened remote session
          after successful method invocation (this object must not
          represent an already open session).
        </desc>
      </param>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
      <param name="type" type="wstring" dir="in">
        <desc>
          Type of the remote session (case sensitive).
        </desc>
      </param>
      <param name="environment" type="wstring" dir="in">
        <desc>
          Environment to pass to the opened session (may be @c null).
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="openExistingSession">
      <desc>
        Opens a new remote session with the virtual machine for
        which a direct session is already open.

        The remote session provides some level of control over the VM
        execution (using the IConsole interface) to the caller; however,
        within the remote session context, not all VM settings are available
        for modification.

        As opposed to <link to="#openRemoteSession()"/>, the number of
        remote sessions opened this way is not limited by the API

        <note>
          It is an error to open a remote session with the machine that
          doesn't have an open direct session.
        </note>

        <see>openRemoteSession</see>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the open remote session
          after successful method invocation. This object must not
          represent an already open session.
          <note>
            This session will be automatically closed when the peer
            (direct) session dies or gets closed.
          </note>
        </desc>
      </param>
      <param name="machineId" type="uuid" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
    </method>

    <method name="registerCallback">
      <desc>
        Registers a new global VirtualBox callback. The methods of the given
        callback object will be called by VirtualBox when an appropriate
        event occurs.
      </desc>
      <param name="callback" type="IVirtualBoxCallback" dir="in">
        <desc>Callback object to register.</desc>
      </param>
    </method>

    <method name="unregisterCallback">
      <desc>
        Unregisters the previously registered global VirtualBox callback.
      </desc>
      <param name="callback" type="IVirtualBoxCallback" dir="in">
        <desc>Callback object to unregister.</desc>
      </param>
    </method>

    <method name="waitForPropertyChange">
      <desc>
        Blocks the caller until any of the properties represented by the @a
        what argument changes the value or until the given timeout interval
        expires.

        The @a what argument is a comma separated list of propertiy masks that
        describe properties the caller is interested in. The property mask is
        a string in the following format:

        @code
        [[group.]subgroup.]name
        @endcode

        where @c name is the property name and @c group, @c subgroup are zero
        or or more property group specifiers. Each element (group or name) in
        the property mask may be either a latin string or an asterisk symbol
        (@c "*") which is used to match any string for the given element. A
        property mask that doesn't contain asterisk symbols represents a
        single fully qualified property name.

        Groups in the fully qualified property name go from more generic (the
        left-most part) to more specific (the right-most part). The first
        element is usually a name of the object the property belongs to.  The
        second element may be either a property name, or a child object name,
        or an index if the preceeding element names an object which is one of
        many objects of the same type. This way, property names form a
        hierarchy of properties.  Here are some examples of property names:

        <table>
          <tr>
            <td><tt>VirtualBox.version</tt></td>
            <td><link to="IVirtualBox::version"/> property</td>
          </tr>
          <tr>
            <td><tt>Machine.&lt;UUID&gt;.name</tt></td>
            <td><link to="IMachine::name"/> property of the machine with the
            given UUID</td>
            </tr>
        </table>

        Most property names directly correspond to the properties of objects
        (components) provided by the VirtualBox library and may be used to
        track changes to these properties. However, there may be
        pseudo-property names that don't correspond to any existing object's
        property directly, as well as there may be object properties that
        don't have a corresponding property name that is understood by this
        method, and therefore changes to such properties cannot be
        tracked. See individual object's property descrcriptions to get a
        fully qualified property name that can be used with this method (if
        any).

        There is a special property mask @c "*" (i.e. a string consisting of a
        single asterisk symbol) that can be used to match all properties.
        Below are more examples of property masks:

        <table>
          <tr>
            <td><tt>VirtualBox.*</tt></td>
            <td>Track all properties of the VirtualBox object</td>
          </tr>
          <tr>
            <td><tt>Machine.*.name</tt></td>
            <td>Track changes to the <link to="IMachine::name"/> property of
            all registered virtual machines</td>
          </tr>
        </table>

      </desc>
      <param name="what" type="wstring" dir="in">
        <desc>Comma separated list of property masks.</desc>
      </param>
      <param name="timeout" type="unsigned long" dir="in">
        <desc>
          Wait timeout in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
      <param name="changed" type="wstring" dir="out">
        <desc>
          Comma separated list of properties that have been changed and caused
          this method to return to the caller.
        </desc>
      </param>
      <param name="values" type="wstring" dir="out">
        <desc>Reserved, not currently used.</desc>
      </param>
    </method>

		<method name="saveSettings">
			<desc>
				Saves the global settings to the global settings file
				(<link to="#settingsFilePath"/>).

				This method is only useful for explicitly saving the global settings
				file after it has been auto-converted from the old format to the most
				recent format (see <link to="#settingsFileVersion"/> for details).
				Normally, the global settings file is implicitly saved when a global
				setting is changed.
			</desc>
		</method>

    <method name="saveSettingsWithBackup">
      <desc>
        Creates a backup copy of the global settings file
        (<link to="#settingsFilePath"/>) in case of auto-conversion, and then
        calls <link to="#saveSettings()"/>.

        Note that the backup copy is created <b>only</b> if the settings file
        auto-conversion took place (see <link to="#settingsFileVersion"/> for
        details). Otherwise, this call is fully equivalent to
        <link to="#saveSettings()"/> and no backup copying is done.

        The backup copy is created in the same directory where the original
        settings file is located. It is given the following file name:
        <pre>
          original.xml.x.y-platform.bak
        </pre>
        where <tt>original.xml</tt> is the original settings file name
        (excluding path), and <tt>x.y-platform</tt> is the version of the old
        format of the settings file (before auto-conversion).

        If the given backup file already exists, this method will try to add the
        <tt>.N</tt> suffix to the backup file name (where <tt>N</tt> counts from
        0 to 9) and copy it again until it succeeds. If all suffixes are
        occupied, or if any other copy error occurs, this method will return a
        failure.

        If the copy operation succeeds, the @a bakFileName return argument will
        receive a full path to the created backup file (for informational
        purposes). Note that this will happen even if the subsequent
        <link to="#saveSettings()"/> call performed by this method after the
        copy operation, fails.

        <note>
          The VirtualBox API never calls this method. It is intended purely for
          the purposes of creating backup copies of the settings files by
          front-ends before saving the results of the automatically performed
          settings conversion to disk.
        </note>

        <see>settingsFileVersion</see>
      </desc>
      <param name="bakFileName" type="wstring" dir="return">
        <desc>Full path to the created backup copy.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IMachine
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IMachineEnumerator" type="IMachine"
     uuid="1b554149-be0a-4465-9252-9ff8f420af55"
     />

  <collection
     name="IMachineCollection" type="IMachine" enumerator="IMachineEnumerator"
     uuid="FD443EC1-3007-4F5B-9282-D72760A66916"
     readonly="yes"
     />

  <interface
     name="IInternalMachineControl" extends="$unknown"
     uuid="1063893c-4c38-4304-aee9-73e072c181cc"
     internal="yes"
     wsmap="suppress"
     >
    <method name="updateState">
      <desc>
        Updates the VM state.
        <note>
          This operation will also update the settings file with
          the correct information about the saved state file
          and delete this file from disk when appropriate.
        </note>
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="getIPCId">
      <param name="id" type="wstring" dir="return"/>
    </method>

    <method name="runUSBDeviceFilters">
      <desc>
        Asks the server to run USB devices filters of the associated
        machine against the given USB device and tell if there is
        a match.
        <note>
          Intended to be used only for remote USB devices. Local
          ones don't require to call this method (this is done
          implicitly by the Host and USBProxyService).
        </note>
      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="matched" type="boolean" dir="out"/>
      <param name="maskedInterfaces" type="unsigned long" dir="out"/>
    </method>

    <method name="captureUSBDevice">
      <desc>
        Requests a capture of the given host USB device.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification.
      </desc>
      <param name="id" type="uuid" dir="in"/>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Notification that a VM is going to detach (done = false) or has
        already detached (done = true) the given USB device.
        When the done = true request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceDetach"/>
        notification.
        <note>
          In the done = true case, the server must run its own filters
          and filters of all VMs but this one on the detached device
          as if it were just attached to the host computer.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in"/>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="autoCaptureUSBDevices">
      <desc>
        Requests a capture all matching USB devices attached to the host.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification per every captured device.
      </desc>
    </method>

    <method name="detachAllUSBDevices">
      <desc>
        Notification that a VM that is being powered down. The done
        parameter indicates whether which stage of the power down
        we're at. When done = false the VM is announcing its
        intentions, while when done = true the VM is reporting
        what it has done.
        <note>
          In the done = true case, the server must run its own filters
          and filters of all VMs but this one on all detach devices as
          if they were just attached to the host computer.
        </note>
      </desc>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="onSessionEnd">
      <desc>
        Triggered by the given session object when the session is about
        to close normally.
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>Session that is being closed</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Used to wait until the corresponding machine is actually
          deassociated from the given session on the server.
          Returned only when this session is a direct one.
        </desc>
      </param>
    </method>

    <method name="beginSavingState">
      <desc>
        Called by the VM process to inform the server it wants to
        save the current state and stop the VM execution.
      </desc>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process to wait until
          the state is saved.
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
    </method>

    <method name="endSavingState">
      <desc>
        Called by the VM process to inform the server that saving
        the state previously requested by #beginSavingState is either
        successfully finished or there was a failure.
      </desc>

      <param name="success" type="boolean" dir="in">
        <desc><tt>true</tt> to indicate success and <tt>false</tt> otherwise</desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Gets called by IConsole::adoptSavedState.
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="beginTakingSnapshot">
      <desc>
        Called by the VM process to inform the server it wants to
        take a snapshot.
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Snapshot name</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Snapshot description</desc>
      </param>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process to wait until
          the state is saved (only for online snapshots).
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
      <param name="serverProgress" type="IProgress" dir="out">
        <desc>
          Progress object created by the server process to wait until
          the snapshot is taken (VDI diff creation, etc.).
        </desc>
      </param>
    </method>

    <method name="endTakingSnapshot">
      <desc>
        Called by the VM process to inform the server that the snapshot
        previously requested by #beginTakingSnapshot is either
        successfully taken or there was a failure.
      </desc>

      <param name="success" type="boolean" dir="in">
        <desc><tt>true</tt> to indicate success and <tt>false</tt> otherwise</desc>
      </param>
    </method>

    <method name="discardSnapshot">
      <desc>
        Gets called by IConsole::discardSnapshot.
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to discard.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentState">
      <desc>
        Gets called by IConsole::discardCurrentState.
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentSnapshotAndState">
      <desc>
        Gets called by IConsole::discardCurrentSnapshotAndState.
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>

  <interface
     name="IBIOSSettings" extends="$unknown"
     uuid="38b54279-dc35-4f5e-a431-835b867c6b5e"
     wsmap="struct"
     >
    <desc>
        The IBIOSSettings interface represents BIOS settings of the virtual
        machine. This is used only in the <link to="IMachine::BIOSSettings" /> attribute.

        <note>With the COM API, this is an interface like all the others. With the webservice,
        this is mapped to a structure, so querying the attribute will not return an object,
        but a complete structure.</note>
    </desc>
    <attribute name="logoFadeIn" type="boolean">
      <desc>Fade in flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoFadeOut" type="boolean">
      <desc>Fade out flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoDisplayTime" type="unsigned long">
      <desc>BIOS logo display time in milliseconds (0 = default).</desc>
    </attribute>

    <attribute name="logoImagePath" type="wstring">
      <desc>Local file system path for external BIOS image.</desc>
    </attribute>

    <attribute name="bootMenuMode" type="BIOSBootMenuMode">
      <desc>Mode of the BIOS boot device menu.</desc>
    </attribute>

    <attribute name="ACPIEnabled" type="boolean">
      <desc>ACPI support flag.</desc>
    </attribute>

    <attribute name="IOAPICEnabled" type="boolean">
      <desc>
        IO APIC support flag. If set, VirtualBox will provide an IO APIC
        and support IRQs above 15.
      </desc>
    </attribute>

    <attribute name="timeOffset" type="long long">
      <desc>
        Offset in milliseconds from the host system time. This allows for
        guests running with a different system date/time than the host.
        It is equivalent to setting the system date/time in the BIOS other
        than it's not an absolute value but a relative one. Guest Additions
        time synchronization also honors this offset.
      </desc>
    </attribute>

    <attribute name="PXEDebugEnabled" type="boolean">
      <desc>
        PXE debug logging flag. If set, VirtualBox will write extensive
        PXE trace information to the release log.
      </desc>
    </attribute>

    <attribute name="IDEControllerType" type="IDEControllerType">
      <desc>
        Type of the virtual IDE controller. Depending on this value,
        VirtualBox will provide different virtual IDE hardware
        devices to the guest.
      </desc>
    </attribute>

  </interface>

  <interface
     name="IMachine" extends="$unknown"
     uuid="f95c0793-7737-49a1-85d9-6da81097173b"
     wsmap="managed"
     >
    <desc>
      The IMachine interface represents a virtual machine, or guest, created
      in VirtualBox.

      This interface is used in two contexts. First of all, a collection of
      objects implementing this interface is stored in the
      <link to="IVirtualBox::machines"/> attribute which lists all the virtual
      machines that are currently registered with this VirtualBox
      installation. Also, once a session has been opened for the given virtual
      machine (e.g. the virtual machine is running), the machine object
      associated with the open session can be queried from the session object;
      see <link to="ISession"/> for details.

      The main role of this interface is to expose the settings of the virtual
      machine and provide methods to change various aspects of the virtual
      machine's configuration. For machine objects stored in the
      <link to="IVirtualBox::machines"/> collection, all attributes are
      read-only unless explicitely stated otherwise in individual attribute
      and method descriptions. In order to change a machine setting, a session
      for this machine must be opened using one of
      <link to="IVirtualBox::openSession"/>,
      <link to="IVirtualBox::openRemoteSession"/> or
      <link to="IVirtualBox::openExistingSession"/> methdods. After the
      session has been successfully opened, a mutable machine object needs to
      be queried from the session object and then the desired settings changes
      can be applied to the returned object using IMachine attributes and
      methods. See the ISession interface description for more information
      about sessions.

      Note that the IMachine interface does not provide methods to control
      virtual machine execution (such as start the machine, or power it
      down) -- these methods are grouped in a separate IConsole
      interface. Refer to the IConsole interface description to get more
      information about this topic.

      <see>ISession, IConsole</see>
    </desc>

    <attribute name="parent" type="IVirtualBox" readonly="yes">
      <desc>Associated parent obect.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether this virtual machine is currently accessible or not.

        The machine is considered to be inaccessible when:
        <ul>
          <li>It is a registered virtual machine, and
          </li>
          <li>Its settings file is inaccessible (for example, it is
            located on a network share that is not accessible during
            VirtualBox startup, or becomes inaccessible later, or if
            the settings file can be read but is invalid).
          </li>
        </ul>

        Otherwise, the value of this property is always <tt>true</tt>.

        Every time this property is read, the accessibility state of
        this machine is re-evaluated. If the returned value is |false|,
        the <link to="#accessError"/> property may be used to get the
        detailed error information describing the reason of
        inaccessibility.

        When the machine is inaccessible, only the following properties
        can be used on it:
        <ul>
          <li><link to="#parent"/></li>
          <li><link to="#id"/></li>
          <li><link to="#settingsFilePath"/></li>
          <li><link to="#accessible"/></li>
          <li><link to="#accessError"/></li>
        </ul>

        An attempt to access any other property or method will return
        an error.

        The only possible action you can perform on an inaccessible
        machine is to unregister it using the
        <link to="IVirtualBox::unregisterMachine"/> call (or, to check
        for the accessibility state once more by querying this
        property).

        <note>
          In the current implementation, once this property returns
          <tt>true</tt>, the machine will never become inaccessible
          later, even if its settings file cannot be successfully
          read/written any more (at least, until the VirtualBox
          server is restarted). This limitation may be removed in
          future releases.
        </note>
      </desc>
    </attribute>

    <attribute name="accessError" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Error information describing the reason of machine
        inaccessibility.

        Reading this property is only valid after the last call to
        <link to="#accessible"/> returned <tt>false</tt> (i.e. the
        machine is currently unaccessible). Otherwise, a null
        IVirtualBoxErrorInfo object will be returned.
      </desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>
        Name of the virtual machine.

        Besides being used for human-readable identification purposes
        everywhere in VirtualBox, the virtual machine name is also used
        as a name of the machine's settings file and as a name of the
        subdirectory this settings file resides in. Thus, every time you
        change the value of this property, the settings file will be
        renamed once you call <link to="#saveSettings()"/> to confirm the
        change. The containing subdirectory will be also renamed, but
        only if it has exactly the same name as the settings file
        itself prior to changing this property (for backward compatibility
        with previous API releases). The above implies the following
        limitations:
        <ul>
          <li>The machine name cannot be empty.</li>
          <li>The machine name can contain only characters that are valid
            file name characters according to the rules of the file
            system used to store VirtualBox configuration.</li>
          <li>You cannot have two or more machines with the same name
            if they use the same subdirectory for storing the machine
            settings files.</li>
          <li>You cannot change the name of the machine if it is running,
            or if any file in the directory containing the settings file
            is being used by another running machine or by any other
            process in the host operating system at a time when
            <link to="#saveSettings()"/> is called.
          </li>
        </ul>
        If any of the above limitations are hit, <link to="#saveSettings()"/>
        will return an appropriate error message explaining the exact
        reason and the changes you made to this machine will not be
        saved.
        <note>
          For "legacy" machines created using the
          <link to="IVirtualBox::createLegacyMachine()"/> call,
          the above naming limitations do not apply because the
          machine name does not affect the settings file name.
          The settings file name remains the same as it was specified
          during machine creation and never changes.
        </note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Description of the virtual machine.

        The description attribute can contain any text and is
        typically used to describe the hardware and software
        configuration of the virtual machine in detail (i.e. network
        settings, versions of the installed software and so on).
      </desc>
    </attribute>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>UUID of the virtual machine.</desc>
    </attribute>

    <attribute name="OSTypeId" type="wstring">
      <desc>
        User-defined identifier of the Guest OS type.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          This value may differ from the value returned by
          <link to="IGuest::OSTypeId"/> if Guest Additions are
          installed to the guest OS.
        </note>
      </desc>
    </attribute>

    <attribute name="memorySize" type="unsigned long">
      <desc>System memory size in megabytes.</desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Initial memory balloon size in megabytes.</desc>
    </attribute>

    <attribute name="statisticsUpdateInterval" type="unsigned long">
      <desc>Initial interval to update guest statistics in seconds.</desc>
    </attribute>

    <attribute name="VRAMSize" type="unsigned long">
      <desc>Video memory size in megabytes.</desc>
    </attribute>

    <attribute name="MonitorCount" type="unsigned long">
      <desc>
        Number of virtual monitors.
        <note>
          Only effective on Windows XP and later guests with
          Guest Additions installed.
        </note>
      </desc>
    </attribute>

    <attribute name="BIOSSettings" type="IBIOSSettings" readonly="yes">
      <desc>Object containing all BIOS settings.</desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="TSBool">
      <desc>
        This setting determines whether VirtualBox will try to make use of
        the host CPU's hardware virtualization extensions such as Intel VT-x
        and AMD-V. Note that in case such extensions are not available,
        they will not be used.
      </desc>
    </attribute>

    <attribute name="PAEEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox will expose the Physical Address
        Extension (PAE) feature of the host CPU to the guest. Note that in case PAE
        is not available, it will not be reported.
      </desc>
    </attribute>

    <attribute name="snapshotFolder" type="wstring">
      <desc>
        Full path to the directory used to store snapshot data
        (difrerencing hard disks and saved state files) of this machine.

        The initial value of this property is
        <tt>&lt;</tt><link to="#settingsFilePath">
          path_to_settings_file</link><tt>&gt;/&lt;</tt>
        <link to="#id">machine_uuid</link>
        <tt>&gt;</tt>.

        Currently, it is an error to try to change this property on
        a machine that has snapshots (because this would require to
        move possibly large files to a different location).
        A separate method will be available for this purpose later.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
        <note>
          When setting this property, the specified path can be
          absolute (full path) or relative to the directory where the
          <link to="#settingsFilePath">machine settings file</link>
          is located. When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>
      </desc>
    </attribute>

    <attribute name="VRDPServer" type="IVRDPServer" readonly="yes">
      <desc>VRDP server object.</desc>
    </attribute>

    <attribute name="hardDiskAttachments" type="IHardDiskAttachmentCollection" readonly="yes">
      <desc>Collection of hard disks attached to the machine.</desc>
    </attribute>

    <attribute name="DVDDrive" type="IDVDDrive" readonly="yes">
      <desc>Associated DVD drive object.</desc>
    </attribute>

    <attribute name="FloppyDrive" type="IFloppyDrive" readonly="yes">
      <desc>Associated floppy drive object.</desc>
    </attribute>

    <attribute name="USBController" type="IUSBController" readonly="yes">
      <desc>
        Associated USB controller object.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not avaliable in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="audioAdapter" type="IAudioAdapter" readonly="yes">
      <desc>Associated audio adapter, always present.</desc>
    </attribute>

    <attribute name="SATAController" type="ISATAController" readonly="yes">
      <desc>
        Associated SATA controller object.
      </desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the file containing machine settings data.
      </desc>
    </attribute>

    <attribute name="settingsFileVersion" type="wstring" readonly="yes">
      <desc>
        Current version of the format of the settings file of this machine
        (<link to="#settingsFilePath"/>).

        The version string has the following format:
        <pre>
          x.y-platform
        </pre>
        where <tt>x</tt> and <tt>y</tt> are the major and the minor format
        versions, and <tt>platform</tt> is the platform identifier.

        The current version usually matches the value of the
        <link to="IVirtualBox::settingsFormatVersion"/> attribute unless the
        settings file was created by an older version of VirtualBox and there
        was a change of the settings file format since then.

        Note that VirtualBox automatically converts settings files from older
        versions to the most recent version when reading them (usually at
        VirtualBox startup) but it doesn't save the changes back until
        you call a method that implicitly saves settings (such as
        <link to="#setExtraData()"/>) or call <link to="#saveSettings()"/>
        explicitly. Therefore, if the value of this attribute differs from the
        value of <link to="IVirtualBox::settingsFormatVersion"/>, then it
        means that the settings file was converted but the result of the
        conversion is not yet saved to disk.

        The above feature may be used by interactive front-ends to inform users
        about the settings file format change and offer them to explicitly save
        all converted settings files (the global and VM-specific ones),
        optionally create bacup copies of the old settings files before saving,
        etc.

        <see>IVirtualBox::settingsFormatVersion, saveSettingsWithBackup()</see>
      </desc>
    </attribute>

    <attribute name="settingsModified" type="boolean" readonly="yes">
      <desc>
        Whether the settings of this machine have been modified
        (but neither yet saved nor discarded).
        <note>
          Reading this property is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or opened
          by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>. For all other
          cases, the settigs can never be modified.
        </note>
        <note>
          For newly created unregistered machines, the value of this
          property is always TRUE until <link to="#saveSettings()"/>
          is called (no matter if any machine settings have been
          changed after the creation or not). For opened machines
          the value is set to FALSE (and then follows to normal rules).
        </note>
      </desc>
    </attribute>

    <attribute name="sessionState" type="SessionState" readonly="yes">
      <desc>Current session state for this machine.</desc>
    </attribute>

    <attribute name="sessionType" type="wstring" readonly="yes">
      <desc>
        Type of the session.  If <link to="#sessionState"/> is
        SessionSpawning or SessionOpen, this attribute contains the
        same value as passed to the
        <link to="IVirtualBox::openRemoteSession()"/> method in the @a
        type parameter. If the session was opened directly using
        <link to="IVirtualBox::openSession()"/>, or if
        <link to="#sessionState"/> is SessionClosed, the value of this
        attribute is @c null.
      </desc>
    </attribute>

    <attribute name="sessionPid" type="unsigned long" readonly="yes">
      <desc>
        Identifier of the session process. This attribute contains the
        platform-dependent identifier of the process that has opened a
        direct session for this machine using the
        <link to="IVirtualBox::openSession()"/> call. The returned value
        is only valid if <link to="#sessionState"/> is SessionOpen or
        SessionClosing (i.e. a session is currently open or being
        closed) by the time this property is read.
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>Current execution state of this machine.</desc>
    </attribute>

    <attribute name="lastStateChange" type="long long" readonly="yes">
      <desc>
        Time stamp of the last execution state change,
        in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="stateFilePath" type="wstring" readonly="yes">
      <desc>
        Full path to the file that stores the execution state of
        the machine when it is in the <link to="MachineState::Saved"/>
        state.
        <note>
          When the machine is not in the Saved state, this attribute
          <tt>null</tt>.
        </note>
      </desc>
    </attribute>

    <attribute name="logFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the folder that stores a set of rotated log files
        recorded during machine execution. The most recent log file is
        named <tt>VBox.log</tt>, the previous log file is
        named <tt>VBox.log.1</tt> and so on (upto <tt>VBox.log.3</tt>
        in the current version).
      </desc>
    </attribute>

    <attribute name="currentSnapshot" type="ISnapshot" readonly="yes">
      <desc>
        Current snapshot of this machine.
        <note>
          A <tt>null</tt> object is returned if the machine doesn't
          have snapshots.
        </note>
        <see><link to="ISnapshot"/></see>
      </desc>
    </attribute>

    <attribute name="snapshotCount" type="unsigned long" readonly="yes">
      <desc>
        Number of snapshots taken on this machine. Zero means the
        machine doesn't have any snapshots.
      </desc>
    </attribute>

    <attribute name="currentStateModified" type="boolean" readonly="yes">
      <desc>
        Returns <tt>true</tt> if the current state of the machine is not
        identical to the state stored in the current snapshot.

        The current state is identical to the current snapshot right
        after one of the following calls are made:
        <ul>
          <li><link to="IConsole::discardCurrentState"/> or
            <link to="IConsole::discardCurrentSnapshotAndState"/>
          </li>
          <li><link to="IConsole::takeSnapshot"/> (issued on a
            powered off or saved machine, for which
            <link to="#settingsModified"/> returns <tt>false</tt>)
          </li>
          <li><link to="IMachine::setCurrentSnapshot"/>
          </li>
        </ul>

        The current state remains identical until one of the following
        happens:
        <ul>
          <li>settings of the machine are changed</li>
          <li>the saved state is discarded</li>
          <li>the current snapshot is discarded</li>
          <li>an attempt to execute the machine is made</li>
        </ul>

        <note>
          For machines that don't have snapshots, this property is
          always <tt>false</tt>.
        </note>
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
      <desc>
        Collection of shared folders for this machine (permanent shared
        folders). These folders are shared automatically at machine startup
        and available only to the guest OS installed within this machine.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="clipboardMode" type="ClipboardMode">
      <desc>
        Synchronization mode between the host OS clipboard
        and the guest OS clipboard.
      </desc>
    </attribute>

    <method name="setBootOrder">
      <desc>
        Puts the given device to the specified position in
        the boot order.

        To indicate that no device is associated with the given position,
        <link to="DeviceType::Null"/> should be used.

        @todo setHardDiskBootOrder(), setNetworkBootOrder()
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (<tt>1</tt> to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="in">
        <desc>
          The type of the device used to boot at the given position.
        </desc>
      </param>
    </method>

    <method name="getBootOrder" const="yes">
      <desc>
        Returns the device type that occupies the specified
        position in the boot order.

        @todo [remove?]
        If the machine can have more than one device of the returned type
        (such as hard disks), then a separate method should be used to
        retrieve the individual device that occupies the given position.

        If here are no devices at the given position, then
        <link to="DeviceType::Null"/> is returned.

        @todo getHardDiskBootOrder(), getNetworkBootOrder()
      </desc>
      <param name="order" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (<tt>1</tt> to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="return">
        <desc>
          Device at the given position.
        </desc>
      </param>
    </method>

    <method name="attachHardDisk">
      <desc>

        Attaches a virtual hard disk identified by the given UUID to the
        given device slot of the given channel on the given bus. The
        specified device slot must not have another disk attached and the
        given hard disk must not be already attached to this machine.

        See <link to="IHardDisk"/> for detailed information about
        attaching hard disks.

        <note>You cannot attach a hard disk to a running machine. Also,
          you cannot attach a hard disk to a newly created machine until
          it is registered.</note>

        <note>Attaching a hard disk to a machine creates a <i>lazy</i>
          attachment. In particular, no differeincing images are
          actually created until <link to="#saveSettings()"/> is called to
          commit all changed settings.</note>

      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the hard disk to attach.</desc>
      </param>
      <param name="bus" type="StorageBus" dir="in">
        <desc>Type of storage bus to use (IDE or SATA).</desc>
      </param>
      <param name="channel" type="long" dir="in">
        <desc>Channel to attach the hard disk to. For IDE controllers,
        this can either be 0 or 1, for the primary or secondary controller,
        respectively.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given channel to attach the hard disk to.
        For IDE devices, within each channel (0 or 1), this can again be
        0 or 1, for master or slave, respectively.</desc>
      </param>
    </method>

    <method name="getHardDisk" const="yes">
      <desc>
        Returns the hard disk attached to the
        given controller under the specified device number.
      </desc>
      <param name="bus" type="StorageBus" dir="in"/>
      <param name="channel" type="long" dir="in"/>
      <param name="device" type="long" dir="in"/>
      <param name="hardDisk" type="IHardDisk" dir="return"/>
    </method>

    <method name="detachHardDisk">
      <desc>

        Detaches the hard disk drive attached to the given device slot
        of the given controller.

        See <link to="IHardDisk"/> for detailed information about
        attaching hard disks.

        <note>You cannot detach a hard disk from a running
          machine.</note>

        <note>
          Detaching a hard disk from a machine creates a <i>lazy</i>
          detachment. In particular, if the detached hard disk is a
          differencing hard disk, it is not actually deleted until
          <link to="#saveSettings()"/> is called to commit all changed settings.
          Keep in mind, that doing <link to="#saveSettings()"/> will
          <b>physically delete</b> all detached differencing hard disks,
          so be careful.
        </note>

      </desc>
      <param name="bus" type="StorageBus" dir="in">
        <desc>Bus to dettach the hard disk from.</desc>
      </param>
      <param name="channel" type="long" dir="in">
        <desc>Channel number to dettach the hard disk from.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot number to dettach the hard disk from.</desc>
      </param>
    </method>

    <method name="getNetworkAdapter" const="yes">
      <desc>
        Returns the network adapter associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of adapters per every machine is defined by the
        <link to="ISystemProperties::networkAdapterCount"/> property,
        so the maximum slot number is one less than that property's value.
      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="adapter" type="INetworkAdapter" dir="return"/>
    </method>

    <method name="getSerialPort" const="yes">
      <desc>
        Returns the serial port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of serial ports per every machine is defined by the
        <link to="ISystemProperties::serialPortCount"/> property,
        so the maximum slot number is one less than that property's value.
      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="ISerialPort" dir="return"/>
    </method>

    <method name="getParallelPort" const="yes">
      <desc>
        Returns the parallel port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of parallel ports per every machine is defined by the
        <link to="ISystemProperties::parallelPortCount"/> property,
        so the maximum slot number is one less than that property's value.
      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="IParallelPort" dir="return"/>
    </method>

    <method name="getNextExtraDataKey">
      <desc>
        Returns the machine-specific extra data key name following the
        supplied key.

        An error is returned if the supplied @a key does not exist. @c NULL is
        returned in @a nextKey if the supplied key is the last key. When
        supplying @c NULL for the @a key, the first key item is returned in @a
        nextKey (if there is any). @a nextValue is an optional parameter and
        if supplied, the next key's value is returned in it.
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to follow.</desc>
      </param>
      <param name="nextKey" type="wstring" dir="out">
        <desc>Name of the next data key.</desc>
      </param>
      <param name="nextValue" type="wstring" dir="out">
        <desc>Value of the next data key.</desc>
      </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated machine-specific extra data.

        If the reuqested data @a key does not exist, this function will
        succeed and return @c NULL in the @a value argument.
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated machine-specific extra data.

        If you pass @c NULL as a key @a vaule, the given @a key will be
        deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered callbacks using the
          <link to="IVirtualBoxCallback::onExtraDataCanChange()"/>
          notification for a permission. If one of the callbacks refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IVirtualBoxCallback::onExtraDataChange()"/> notification
          is called to inform all registered callbacks about a successful data
          change.
        </note>
        <note>
          This method can be called outside the machine session and therefore
          it's a caller's responsibility to handle possible race conditions
          when several clients change the same key at the same time.
        </note>
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="saveSettings">
      <desc>
        Saves any changes to machine settings made since the session
        has been opened or a new machine has been created, or since the
        last call to <link to="#saveSettings()"/> or <link to="#discardSettings()"/>.
        For registered machines, new settings become visible to all
        other VirtualBox clients after successful invocation of this
        method.
        <note>
          The method sends <link to="IVirtualBoxCallback::onMachineDataChange()"/>
          notification event after the configuration has been successfully
          saved (only for registered machines).
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>
      </desc>
    </method>

    <method name="saveSettingsWithBackup">
      <desc>
        Creates a backup copy of the machine settings file (<link
        to="#settingsFilePath"/>) in case of auto-conversion, and then calls
        <link to="#saveSettings()"/>.

        Note that the backup copy is created <b>only</b> if the settings file
        auto-conversion took place (see <link to="#settingsFileVersion"/> for
        details). Otherwise, this call is fully equivalent to
        <link to="#saveSettings()"/> and no backup copying is done.

        The backup copy is created in the same directory where the original
        settings file is located. It is given the following file name:
        <pre>
          original.xml.x.y-platform.bak
        </pre>
        where <tt>original.xml</tt> is the original settings file name
        (excluding path), and <tt>x.y-platform</tt> is the version of the old
        format of the settings file (before auto-conversion).

        If the given backup file already exists, this method will try to add the
        <tt>.N</tt> suffix to the backup file name (where <tt>N</tt> counts from
        0 to 9) and copy it again until it succeeds. If all suffixes are
        occupied, or if any other copy error occurs, this method will return a
        failure.

        If the copy operation succeeds, the @a bakFileName return argument will
        receive a full path to the created backup file (for informational
        purposes). Note that this will happen even if the subsequent
        <link to="#saveSettings()"/> call performed by this method after the
        copy operation, fails.

        <note>
          The VirtualBox API never calls this method. It is intended purely for
          the purposes of creating backup copies of the settings files by
          front-ends before saving the results of the automatically performed
          settings conversion to disk.
        </note>

        <see>settingsFileVersion</see>
      </desc>
      <param name="bakFileName" type="wstring" dir="return">
        <desc>Full path to the created backup copy.</desc>
      </param>
    </method>

    <method name="discardSettings">
      <desc>
        Discards any changes to the machine settings made since the session
        has been opened or since the last call to <link to="#saveSettings()"/>
        or <link to="#discardSettings"/>.
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>
      </desc>
    </method>

    <method name="deleteSettings">
      <desc>
        Deletes the settings file of this machine from disk.
        The machine must not be registered in order for this operation
        to succeed.
        <note>
          <link to="#settingsModified"/> will return TRUE after this
          method successfully returns.
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>
        <note>
          The deleted machine settings file can be restored (saved again)
          by calling <link to="#saveSettings()"/>.
        </note>
      </desc>
    </method>

    <method name="getSnapshot">
      <desc>
        Returns a snapshot of this machine with the given UUID.
        A <tt>null</tt> UUID can be used to obtain the first snapshot
        taken on this machine. This is useful if you want to traverse
        the whole tree of snapshots starting from the root.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to get</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given UUID.</desc>
      </param>
    </method>

    <method name="findSnapshot">
      <desc>
        Returns a snapshot of this machine with the given name.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the snapshot to find</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given name.</desc>
      </param>
    </method>

    <method name="setCurrentSnapshot">
      <desc>
        Sets the current snapshot of this machine.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to set as the current snapshot.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new permanent shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the permanent shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="canShowConsoleWindow">
      <desc>
        Returns @c true if the VM console process can activate the
        console window and bring it to foreground on the desktop of
        the host PC.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>
      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c
          false otherwise.
        </desc>
      </param>
    </method>

    <method name="showConsoleWindow">
      <desc>
        Activates the console window and brings it to foreground on
        the desktop of the host PC. Many modern window managers on
        many platforms implement some sort of focus stealing
        prevention logic, so that it may be impossible to activate
        a window without the help of the currently active
        application. In this case, this method will return a non-zero
        identifier that represents the top-level window of the VM
        console process. The caller, if it represents a currently
        active process, is responsible to use this identifier (in a
        platform-dependent manner) to perform actual window
        activation.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>
      </desc>
      <param name="winId" type="unsigned long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or VirtualBox front-end.
        </desc>
      </param>
    </method>

  </interface>

  <!--
  // IConsole
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IConsoleCallback" extends="$unknown"
     uuid="13dfbef3-b74d-487d-bada-2304529aefa6"
     wsmap="suppress"
     >

    <method name="onMousePointerShapeChange">
      <desc>
        Notification when the guest mouse pointer shape has
        changed. The new shape data is given.
      </desc>
      <param name="visible" type="boolean" dir="in">
        <desc>
          Flag whether the pointer is visible.
        </desc>
      </param>
      <param name="alpha" type="boolean" dir="in">
        <desc>
          Flag whether the pointer has an alpha channel.
        </desc>
      </param>
      <param name="xHot" type="unsigned long" dir="in">
        <desc>
          The pointer hot spot x coordinate.
        </desc>
      </param>
      <param name="yHot" type="unsigned long" dir="in">
        <desc>
          The pointer hot spot y coordinate.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Width of the pointer shape in pixels.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Height of the pointer shape in pixels.
        </desc>
      </param>
      <param name="shape" type="octet" mod="ptr" dir="in">
        <desc>
          Address of the shape buffer.

          The buffer contains 1 bpp (bits per pixel) AND mask followed by 32 bpp XOR (color) mask.

          For pointers without alpha channel the XOR mask pixels are 32 bit values: (lsb)BGR0(msb).
          For pointers with alpha channel the XOR mask consists of (lsb)BGRA(msb) 32 bit values.

          AND mask presents for pointers with alpha channel, so if the callback does not
          support alpha, the pointer could be displayed as a normal color pointer.

          The AND mask is 1 bpp bitmap with byte aligned scanlines. Size of AND mask,
          therefore, is <tt>cbAnd = (width + 7) / 8 * height</tt>. The padding bits at the
          end of any scanline are undefined.

          The XOR mask follows the AND mask on the next 4 bytes aligned offset:
          <tt>uint8_t *pXor = pAnd + (cbAnd + 3) &amp; ~3</tt>
          Bytes in the gap between the AND and the XOR mask are undefined.
          XOR mask scanlines have no gap between them and size of XOR mask is:
          <tt>cXor = width * 4 * height</tt>.

          <note>
            If 'shape' is equal to 0, only pointer visibility is being changed.
          </note>
        </desc>
      </param>
    </method>

    <method name="onMouseCapabilityChange">
      <desc>
        Notification when the mouse capabilities reported by the
        guest have changed. The new capabilities are passed.
      </desc>
      <param name="supportsAbsolute" type="boolean" dir="in"/>
      <param name="needsHostCursor" type="boolean" dir="in"/>
    </method>

    <method name="onKeyboardLedsChange">
      <desc>
        Notification when the guest OS executes the KBD_CMD_SET_LEDS command
        to alter the state of the keyboard LEDs.
      </desc>
      <param name="numLock" type="boolean" dir="in"/>
      <param name="capsLock" type="boolean" dir="in"/>
      <param name="scrollLock" type="boolean" dir="in"/>
    </method>

    <method name="onStateChange">
      <desc>
        Notification when the execution state of the machine has changed.
        The new state will be given.
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="onAdditionsStateChange">
      <desc>
        Notification when a Guest Additions property changes.
        Interested callees should query IGuest attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onDVDDriveChange">
      <desc>
        Notification when a property of the
        virtual <link to="IMachine::DVDDrive">DVD drive</link> changes.
        Interested callees should use IDVDDrive methods to find out what has
        changed.
      </desc>
    </method>

    <method name="onFloppyDriveChange">
      <desc>
        Notification when a property of the
        virtual <link to="IMachine::FloppyDrive">floppy drive</link> changes.
        Interested callees should use IFloppyDrive methods to find out what
        has changed.
      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getNetworkAdapter">network adapters</link>
        changes.  Interested callees should use INetworkAdapter methods and
        attributes to find out what has changed.
      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in">
        <desc>Network adapter that is subject to change.</desc>
      </param>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getSerialPort">serial ports</link> changes.
        Interested callees should use ISerialPort methods and attributes
        to find out what has changed.
      </desc>
      <param name="serialPort" type="ISerialPort" dir="in">
        <desc>Serial port that is subject to change.</desc>
      </param>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getParallelPort">parallel ports</link>
        changes.  Interested callees should use ISerialPort methods and
        attributes to find out what has changed.
      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in">
        <desc>Parallel port that is subject to change.</desc>
      </param>
    </method>

    <method name="onVRDPServerChange">
      <desc>
        Notification when a property of the
        <link to="IMachine::VRDPServer">VRDP server</link> changes.
        Interested callees should use IVRDPServer methods and attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Notification when a property of the virtual
        <link to="IMachine::USBController">USB controller</link> changes.
        Interested callees should use IUSBController methods and attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onUSBDeviceStateChange">
      <desc>
        Notification when a USB device is attached to or detached from
        the virtual USB controller.

        This notification is sent as a result of the indirect
        request to attach the device because it matches one of the
        machine USB filters, or as a result of the direct request
        issued by <link to="IConsole::attachUSBDevice"/> or
        <link to="IConsole::detachUSBDevice"/>.

        This notification is sent in case of both a succeeded and a
        failed request completion. When the request succeeds, the @a
        error parameter is @c null, and the given device has been
        already added to (when @a attached is @c true) or removed from
        (when @a attached is @c false) the collection represented by
        <link to="IConsole::USBDevices"/>. On failure, the collection
        doesn't change and the @a error perameter represents the error
        message describing the failure.

      </desc>
      <param name="device" type="IUSBDevice" dir="in">
        <desc>Device that is subject to state change.</desc>
      </param>
      <param name="attached" type="boolean" dir="in">
        <desc>
          <tt>true</tt> if the device was attached
          and <tt>false</tt> otherwise.
        </desc>
      </param>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in">
        <desc>
          <tt>null</tt> on success or an error message object on
          failure.
        </desc>
      </param>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Notification when a shared folder is added or removed.
        The @a scope argument defines one of three scopes:
        <link to="IVirtualBox::sharedFolders">global shared folders</link>
        (<link to="Scope::Global">Global</link>),
        <link to="IMachine::sharedFolders">permanent shared folders</link> of
        the machine (<link to="Scope::Machine">Machine</link>) or <link
        to="IConsole::sharedFolders">transient shared folders</link> of the
        machine (<link to="Scope::Session">Session</link>). Interested callees
        should use query the corresponding collections to find out what has
        changed.
      </desc>
      <param name="scope" type="Scope" dir="in">
        <desc>Sope of the notification.</desc>
      </param>
    </method>

    <method name="onRuntimeError">
      <desc>
        Notification when an error happens during the virtual
        machine execution.

        There are three kinds of runtime errors:
        <ul>
          <li><i>fatal</i></li>
          <li><i>non-fatal with retry</i></li>
          <li><i>non-fatal warnings</i></li>
        </ul>

        <b>Fatal</b> errors are indicated by the @a fatal parameter set
        to <tt>true</tt>. In case of fatal errors, the virtual machine
        execution is always paused before calling this notification, and
        the notification handler is supposed either to immediately save
        the virtual machine state using <link to="IConsole::saveState()"/>
        or power it off using <link to="IConsole::powerDown()"/>.
        Resuming the execution can lead to unpredictable results.

        <b>Non-fatal</b> errors and warnings are indicated by the
        @a fatal parameter set to <tt>false</tt>. If the virtual machine
        is in the Paused state by the time the error notification is
        received, it means that the user can <i>try to resume</i> the machine
        execution after attempting to solve the probem that caused the
        error. In this case, the notification handler is supposed
        to show an appropriate message to the user (depending on the
        value of the @a id parameter) that offers several actions such
        as <i>Retry</i>, <i>Save</i> or <i>Power Off</i>. If the user
        wants to retry, the notification handler should continue
        the machine execution using the <link to="IConsole::resume()"/>
        call. If the machine execution is not Paused during this
        notification, then it means this notification is a <i>warning</i>
        (for example, about a fatal condition that can happen very soon);
        no immediate action is required from the user, the machine
        continues its normal execution.

        Note that in either case the notification handler
        <b>must not</b> perform any action directly on a thread
        where this notification is called. Everything it is allowed to
        do is to post a message to another thread that will then talk
        to the user and take the corresponding action.

        Currently, the following error identificators are known:
        <ul>
          <li><tt>"HostMemoryLow"</tt></li>
          <li><tt>"HostAudioNotResponding"</tt></li>
          <li><tt>"VDIStorageFull"</tt></li>
        </ul>

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c S_OK from all but one of them that does actual
          user notification and performs necessary actions.
        </note>

      </desc>
      <param name="fatal" type="boolean" dir="in">
        <desc>Whether the error is fatal or not</desc>
      </param>
      <param name="id" type="wstring" dir="in">
        <desc>Error identificator</desc>
      </param>
      <param name="message" type="wstring" dir="in">
        <desc>Optional error message</desc>
      </param>
    </method>

    <method name="onCanShowWindow">
      <desc>
        Notification when a call to
        <link to="IMachine::canShowConsoleWindow()"/> is made by a
        front-end to check if a subsequent call to
        <link to="IMachine::showConsoleWindow()"/> can succeed.

        The callee should give an answer appropriate to the current
        machine state in the @a canShow argument. This answer must
        remain valid at least until the next
        <link to="IConsole::state">machine state</link> change.

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c true and @c S_OK from all but one of them that
          actually manages console window activation.
        </note>
      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c
          false otherwise.
        </desc>
      </param>
    </method>

    <method name="onShowWindow">
      <desc>
        Notification when a call to
        <link to="IMachine::showConsoleWindow()"/>
        requests the console window to be activated and brought to
        foreground on the desktop of the host PC.

        This notification should cause the VM console process to
        perform the requested action as described above. If it is
        impossible to do it at a time of this notification, this
        method should return a failure.

        Note that many modern window managers on many platforms
        implement some sort of focus stealing prevention logic, so
        that it may be impossible to activate a window without the
        help of the currently active application (which is supposedly
        an initiator of this notification). In this case, this method
        must return a non-zero identifier that represents the
        top-level window of the VM console process. The caller, if it
        represents a currently active process, is responsible to use
        this identifier (in a platform-dependent manner) to perform
        actual window activation.

        This method must set @a winId to zero if it has performed all
        actions necessary to complete the request and the console
        window is now active and in foreground, to indicate that no
        further action is required on the caller's side.

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return@c S_OK from all but one of them that actually
          manages console window activation.
        </note>
      </desc>
      <param name="winId" type="unsigned long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or this VirtualBox front-end.
        </desc>
      </param>
    </method>

  </interface>

  <interface
     name="IRemoteDisplayInfo" extends="$unknown"
     uuid="550104cd-2dfd-4a6c-857d-f6f8e088e62c"
     wsmap="struct"
     >
     <desc>
        Contains information about the remote display (VRDP) capabilities and status.
        This is used in the <link to="IConsole::remoteDisplayInfo" /> attribute.

        <note>With the COM API, this is an interface like all the others. With the webservice,
        this is mapped to a structure, so querying the attribute will not return an object,
        but a complete structure.</note>
     </desc>

    <attribute name="active" type="boolean" readonly="yes">
      <desc>
        Whether the remote display connection is active.
      </desc>
    </attribute>

    <attribute name="numberOfClients" type="unsigned long" readonly="yes">
      <desc>
        How many times a client connected.
      </desc>
    </attribute>

    <attribute name="beginTime" type="long long" readonly="yes">
      <desc>
        When the last connection was established, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="endTime" type="long long" readonly="yes">
      <desc>
        When the last connection was terminated or the current time, if
        connection is still active, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="bytesSent" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were sent in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesSentTotal" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were sent in all connections.
      </desc>
    </attribute>

    <attribute name="bytesReceived" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were received in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesReceivedTotal" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were received in all connections.
      </desc>
    </attribute>

    <attribute name="user" type="wstring" readonly="yes">
      <desc>
        Login user name supplied by the client.
      </desc>
    </attribute>

    <attribute name="domain" type="wstring" readonly="yes">
      <desc>
        Login domain name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientName" type="wstring" readonly="yes">
      <desc>
        The client name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientIP" type="wstring" readonly="yes">
      <desc>
        The IP address of the client.
      </desc>
    </attribute>

    <attribute name="clientVersion" type="unsigned long" readonly="yes">
      <desc>
        The client software version number.
      </desc>
    </attribute>

    <attribute name="encryptionStyle" type="unsigned long" readonly="yes">
      <desc>
        Public key exchange method used when connection was established.
        Values: 0 - RDP4 public key exchange scheme.
        1 - X509 sertificates were sent to client.
      </desc>
    </attribute>

  </interface>

  <interface
     name="IConsole" extends="$unknown"
     uuid="d5a1cbda-f5d7-4824-9afe-d640c94c7dcf"
     wsmap="managed"
     >
    <desc>
      The IConsole interface represents an interface to control virtual
      machine execution.

      The console object that implements the IConsole interface is obtained
      from a session object after the session for the given machine has been
      opened using one of <link to="IVirtualBox::openSession"/>,
      <link to="IVirtualBox::openRemoteSession"/> or
      <link to="IVirtualBox::openExistingSession"/> methdods.

      Methods of the IConsole interface allow the caller to query the current
      virtual machine execution state, pause the machine or power it down, save
      the machine state or take a snapshot, attach and detach removable media
      and so on.

      <see>ISession</see>
    </desc>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Machine object this console is sessioned with.
        <note>
          This is a convenience property, it has the same value as
          <link to="ISession::machine"/> of the corresponding session
          object.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>
        Current execution state of the machine.
        <note>
          This property always returns the same value as the corresponding
          property of the IMachine object this console is sessioned with.
          For the process that owns (executes) the VM, this is the
          preferable way of querying the VM state, because no IPC
          calls are made.
        </note>
      </desc>
    </attribute>

    <attribute name="guest" type="IGuest" readonly="yes">
      <desc>Guest object.</desc>
    </attribute>

    <attribute name="keyboard" type="IKeyboard" readonly="yes">
      <desc>
        Virtual keyboard object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="mouse" type="IMouse" readonly="yes">
      <desc>
        Virtual mouse object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="display" type="IDisplay" readonly="yes">
      <desc>Virtual display object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="debugger" type="IMachineDebugger" readonly="yes">
      <desc>Debugging interface.</desc>
    </attribute>

    <attribute name="USBDevices" type="IUSBDeviceCollection" readonly="yes">
      <desc>
        Collection of USB devices currently attached to the virtual
        USB controller.
        <note>
          The collection is empty if the machine is not running.
        </note>
      </desc>
    </attribute>

    <attribute name="remoteUSBDevices" type="IHostUSBDeviceCollection" readonly="yes">
      <desc>
        List of USB devices currently attached to the remote VRDP client.
        Once a new device is physically attached to the remote host computer,
        it appears in this list and remains there until detached.
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolderCollection" readonly="yes">
      <desc>
        Collection of shared folders for the current session.  These folders
        are called transient shared folders because they are available to the
        guest OS running inside the associated virtual machine only for the
        duration of the session (as opposed to
        <link to="IMachine::sharedFolders"/> which represent permanent shared
        folders). When the session is closed (e.g. the machine is powered down),
        these folders are automatically discarded.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="remoteDisplayInfo" type="IRemoteDisplayInfo" readonly="yes">
      <desc>
        Interface that provides information on Remote Display (VRDP) connection.
      </desc>
    </attribute>

    <method name="powerUp">
      <desc>
        Starts the virtual machine execution using the current machine
        state (i.e. its current execution state, current settings and
        current hard disks).

        If the machine is powered off or aborted, the execution will
        start from the beginning (as if the real hardware were just
        powered on).

        If the machine is in the <link to="MachineState::Saved"/> state,
        it will continue its execution the point where the state has
        beem saved.

        <see>#saveState</see>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerDown">
      <desc>
        Stops the virtual machine execution.
        After this operation completes, the machine will go to the
        PoweredOff state.
      </desc>
    </method>

    <method name="reset">
      <desc>Resets the virtual machine.</desc>
    </method>

    <method name="pause">
      <desc>Pauses the virtual machine execution.</desc>
    </method>

    <method name="resume">
      <desc>Resumes the virtual machine execution.</desc>
    </method>

    <method name="powerButton">
      <desc>Send the ACPI power button event to the guest.</desc>
    </method>

    <method name="sleepButton">
      <desc>Send the ACPI sleep button event to the guest.</desc>
    </method>

    <method name="getPowerButtonHandled">
      <desc>Check if the last power button event was handled by guest.</desc>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="saveState">
      <desc>
        Saves the current execution state of a running virtual machine
        and stops its executiuon.

        After this operation completes, the machine will go to the
        Saved state. Next time it is powered up, this state will
        be restored and the machine will continue its execution from
        the place where it was saved.

        This operation differs from taking a snapshot to the effect
        that it doesn't create new differencing hard disks. Also, once
        the machine is powered up from the state saved using this method,
        the saved state is deleted, so it will be impossible to return
        to this state later.

        <note>
          On success, this method implicitly calls
          <link to="IMachine::saveSettings()"/> to save all current machine
          settings (including runtime changes to the DVD drive, etc.).
          Together with the impossibility to change any VM settings when it is
          in the Saved state, this guarantees the adequate hardware
          configuration of the machine when it is restored from the saved
          state file.
        </note>

        <note>
          The machine must be in the Running or Paused state, otherwise
          the operation will fail.
        </note>

        <see><link to="#takeSnapshot"/></see>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Associates the given saved state file to the virtual machine.

        On success, the machine will go to the Saved state. Next time it is
        powered up, it will be restored from the adopted saved state and
        continue execution from the place where the saved state file was
        created.

        The specified saved state file path may be full or relative to the
        folder the VM normally saves the state to (usually,
        <link to="IMachine::snapshotFolder"/>).

        <note>
          It's a caller's responsibility to make sure the given saved state
          file is compatible with the settings of this virtual machine that
          represent its virtual hardware (memory size, hard disk configuration
          etc.). If there is a mismatch, the behavior of the virtual machine
          is undefined.
        </note>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="discardSavedState">
      <desc>
        Discards (deletes) the saved state of the virtual machine
        previously created by <link to="#saveState"/>. Next time the
        machine is powered up, a clean boot will occur.
        <note>
          This operation is equivalent to resetting or powering off
          the machine without doing a proper shutdown in the guest OS.
        </note>
      </desc>
    </method>

    <method name="getDeviceActivity">
      <desc>
        Gets the current activity type of a given device or device group.
      </desc>
      <param name="type" type="DeviceType" dir="in"/>
      <param name="activity" type="DeviceActivity" dir="return"/>
    </method>

    <method name="attachUSBDevice">
      <desc>
        Attaches a host USB device with the given UUID to the
        USB controller of the virtual machine.

        The device needs to be in one of the following states:
        <link to="USBDeviceState::Busy">Busy</link>,
        <link to="USBDeviceState::Available">Available</link> or
        <link to="USBDeviceState::Held">Held</link>,
        otherwise an error is immediately returned.

        When the device state is
        <link to="USBDeviceState::Busy">Busy</link>, an error may also
        be returned if the host computer refuses to release it for some reason.

        <see>IUSBController::deviceFilters, USBDeviceState</see>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the host USB device to attach.</desc>
      </param>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Detaches an USB device with the given UUID from the USB controller
        oif the virtual machine.

        After this method succeeds, the VirtualBox server reinitiates
        all USB filters as if the device were just physically attached
        to the host, but filters of this machine are ignored to avoid
        a possible automatic reattachment.

        <see>IUSBController::deviceFilters, USBDeviceState</see>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the USB device to detach.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Detached USB device.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a transient new shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes a transient shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="takeSnapshot">
      <desc>
        Saves the current execution state and all settings of the
        machine and creates differencing images for all
        normal (non-independent) hard disks.

        This method can be called for a PoweredOff, Saved, Running or
        Paused virtual machine. When the machine is PoweredOff, an
        offline <link to="ISnapshot">snapshot</link> is created,
        in all other cases -- an online snapshot.

        The taken snapshot is always based on the
        <link to="IMachine::currentSnapshot">current
          snapshot</link> of the associated virtual machine and becomes
        a new current snapshot.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings()"/> to
          save all current machine settings before taking an offline snapshot.
        </note>

        <see>ISnapshot, <link to="#saveState"/></see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Short name for the snapshot.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Optional description of the snapshot.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardSnapshot">
      <desc>

        Starts discarding the specified snapshot. The execution state
        and settings of the associated machine stored in the snapshot
        will be deleted. The contents of all differencing hard disks of
        this snapshot will be merged with the contents of their
        dependent child hard disks to keep the, disks valid (in other
        words, all changes represented by hard disks being discarded
        will be propagated to their child hard disks). After that, this
        snapshot's differencing hard disks will be deleted. The parent
        of this snapshot will become a new parent for all its child
        snapshots.

        If the discarded snapshot is the current one, its parent
        snapshot will become a new current snapshot. The current machine
        state is not directly affected in this case, except that
        currently attached differencing hard disks based on hard disks
        of the discarded snapshot will be also merged as described
        above.

        If the discarded snapshot is the first one (the root snapshot)
        and it has exactly one child snapshot, this child snapshot will
        become the first snapshot after discarding. If there are no
        children at all (i.e. the first snapshot is the only snapshot of
        the machine), both the current and the first snapshot of the
        machine will be set to null. In all other cases, the first
        snapshot cannot be discarded.

        You cannot discard the snapshot if it
        stores <link to="HardDiskType::Normal">normal</link> (non-differencing)
        hard disks that have differencing hard disks based on them. Snapshots of
        such kind can be discarded only when every normal hard disk has either
        no children at all or exactly one child. In the former case, the normal
        hard disk simply becomes unused (i.e. not attached to any VM). In the
        latter case, it receives all the changes strored in the child hard disk,
        and then it replaces the child hard disk in the configuration of the
        corresponding snapshot or machine.

        Also, you cannot discard the snapshot if it stores hard disks
        (of any type) having differencing child hard disks that belong
        to other machines. Such snapshots can be only discarded after
        you discard all snapshots of other machines containing "foreign"
        child disks, or detach these "foreign" child disks from machines
        they are attached to.

        One particular example of the snapshot storing normal hard disks
        is the first snapshot of a virtual machine that had normal hard
        disks attached when taking the snapshot. Be careful when
        discarding such snapshots because this implicitly commits
        changes (made since the snapshot being discarded has been taken)
        to normal hard disks (as described above), which may be not what
        you want.

        The virtual machine is put to
        the <link to="MachineState::Discarding">Discarding</link> state until
        the discard operation is completed.

        <note>
          The machine must not be running, otherwise the operation
          will fail.
        </note>

        <note>
          Child hard disks of all normal hard disks of the discarded snapshot
          must be <link to="IHardDisk::accessible">accessible</link> for this
          operation to succeed.  In particular, this means that all virtual
          machines, whose hard disks are directly or indirectly based on the
          hard disks of discarded snapshot, must be powered off.
        </note>
        <note>
          Merging hard disk contents can be very time and disk space
          consuming, if these disks are big in size and have many
          children. However, if the snapshot being discarded is the last
          (head) snapshot on the branch, the operation will be rather
          quick.
        </note>
        <note>
          Note that discarding the current snapshot
          will imlicitly call <link to="IMachine::saveSettings()"/> to
          make all current machine settings permanent.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the snapshot to discard.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentState">
      <desc>
        This operation is similar to <link to="#discardSnapshot()"/> but
        affects the current machine state. This means that the state stored in
        the current snapshot will become a new current state, and all current
        settings of the machine and changes stored in differencing hard disks
        will be lost.

        After this operation is successfully completed, new empty differencing
        hard disks are created for all normal hard disks of the machine.

        If the current snapshot of the machine is an online snapshot, the
        machine will go to the <link to="MachineState::Saved"> saved
        state</link>, so that the next time it is powered on, the execution
        state will be restored from the current snapshot.

        <note>
          The machine must not be running, otherwise the operation will fail.
        </note>

        <note>
          If the machine state is <link to="MachineState::Saved">Saved</link>
          prior to this operation, the saved state file will be implicitly
          discarded (as if <link to="IConsole::discardSavedState()"/> were
          called).
        </note>

      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="discardCurrentSnapshotAndState">
      <desc>

        This method is equivalent to
        doing <link to="#discardSnapshot">discardSnapshot</link>
        (<link
        to="IMachine::currentSnapshot">currentSnapshot</link>.<link
        to="ISnapshot::id">id()</link>, ...) followed by
        <link to="#discardCurrentState()"/>.

        As a result, the machine will be fully restored from the
        snapshot preceeding the current snapshot, while both the current
        snapshot and the current machine state will be discarded.

        If the current snapshot is the first snapshot of the machine (i.e. it
        has the only snapshot), the current machine state will be
        discarded <b>before</b> discarding the snapshot. In other words, the
        machine will be restored from its last snapshot, before discarding
        it. This differs from performing a single
        <link to="#discardSnapshot()"/> call (note that no
        <link to="#discardCurrentState()"/> will be possible after it) to the
        effect that the latter will preserve the current state instead of
        discarding it.

        Unless explicitly mentioned otherwise, all remarks and
        limitations of the above two methods also apply to this method.

        <note>
          The machine must not be running, otherwise the operation
          will fail.
        </note>

        <note>
          If the machine state is <link to="MachineState::Saved">Saved</link>
          prior to this operation, the saved state file will be implicitly
          discarded (as if <link to="IConsole::discardSavedState()"/> were
          called).</note>

        <note>
          This method is more efficient than calling two above
          methods separately: it requires less IPC calls and provides
          a single progress object.
        </note>

      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="registerCallback">
      <desc>
        Registers a new console callback on this instance. The methods of the
        callback interface will be called by this instance when the appropriate
        event occurs.
      </desc>
      <param name="callback" type="IConsoleCallback" dir="in"/>
    </method>

    <method name="unregisterCallback">
      <desc>
        Unregisters the console callback previously registered using
        <link to="#registerCallback"/>.
      </desc>
      <param name="callback" type="IConsoleCallback" dir="in"/>
    </method>

  </interface>

  <!--
  // IHost
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IHostDVDDrive" extends="$unknown"
     uuid="21f86694-202d-4ce4-8b05-a63ff82dbf4c"
     wsmap="managed"
     >
    <desc>
      The IHostDVDDrive interface represents the physical CD/DVD drive
      hardware on the host. Used indirectly in <link to="IHost::DVDDrives"/>.
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Returns the platform-specific device identifier.
        On DOS-like platforms, it is a drive name (e.g. R:).
        On Unix-like platforms, it is a device name (e.g. /dev/hdc).
      </desc>
    </attribute>
    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Returns a human readable description for the drive.  This
        description usually contains the product and vendor name.  A
        @c null string is returned if the description is not available.
      </desc>
    </attribute>
    <attribute name="udi" type="wstring" readonly="yes">
      <desc>
        Returns the unique device identifier for the drive.  This
        attribute is reserved for future use instead of
        <link to="#name"/>. Currently it is not used and may return
        @c null on some platforms.
      </desc>
    </attribute>

  </interface>

  <enumerator
     name="IHostDVDDriveEnumerator" type="IHostDVDDrive"
     uuid="1ed7cfaf-c363-40df-aa4e-89c1afb7d96b"
     />

  <collection
     name="IHostDVDDriveCollection" type="IHostDVDDrive"
     enumerator="IHostDVDDriveEnumerator"
     uuid="1909c533-1a1e-445f-a4e1-a267cffc30ed"
     readonly="yes"
     >
    <method name="findByName">
      <desc>
        Searches this collection for a host drive with the given name.
        <note>
          The method returns an error if the given name does not
          correspond to any host drive in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host drive to search for</desc>
      </param>
      <param name="drive" type="IHostDVDDrive" dir="return">
        <desc>Found host drive object</desc>
      </param>
    </method>
  </collection>

  <interface
     name="IHostFloppyDrive" extends="$unknown"
     uuid="b6a4d1a9-4221-43c3-bd52-021a5daa9ed2"
     wsmap="managed"
     >
    <desc>
      The IHostFloppyDrive interface represents the physical floppy drive
      hardware on the host. Used indirectly in <link to="IHost::floppyDrives"/>.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Returns the platform-specific device identifier.
        On DOS-like platforms, it is a drive name (e.g. A:).
        On Unix-like platforms, it is a device name (e.g. /dev/fd0).
      </desc>
    </attribute>
    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Returns a human readable description for the drive.  This
        description usually contains the product and vendor name.  A
        @c null string is returned if the description is not available.
      </desc>
    </attribute>
    <attribute name="udi" type="wstring" readonly="yes">
      <desc>
        Returns the unique device identifier for the drive.  This
        attribute is reserved for future use instead of
        <link to="#name"/>. Currently it is not used and may return
        @c null on some platforms.
      </desc>
    </attribute>
  </interface>

  <enumerator
     name="IHostFloppyDriveEnumerator" type="IHostFloppyDrive"
     uuid="ce04c924-4f54-432a-9dec-11fddc3ea875"
     />

  <collection
     name="IHostFloppyDriveCollection" type="IHostFloppyDrive"
     enumerator="IHostFloppyDriveEnumerator"
     uuid="fd84bb86-c59a-4037-a557-755ff263a460"
     readonly="yes"
     >
    <method name="findByName">
      <desc>
        Searches this collection for a host drive with the given name.
        <note>
          The method returns an error if the given name does not
          correspond to any host drive in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host drive to search for</desc>
      </param>
      <param name="drive" type="IHostFloppyDrive" dir="return">
        <desc>Found host drive object</desc>
      </param>
    </method>
  </collection>

<if target="midl">
  <interface
     name="IHostNetworkInterface" extends="$unknown"
     uuid="F4512D7C-B074-4e97-99B8-6D2BD27C3F5A"
     wsmap="managed"
     >
    <attribute name="name" type="wstring" readonly="yes">
      <desc>Returns the host network interface name.</desc>
    </attribute>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>Returns the interface UUID.</desc>
    </attribute>
  </interface>

  <enumerator
     name="IHostNetworkInterfaceEnumerator" type="IHostNetworkInterface"
     uuid="7B52FEF7-56E8-4aec-92F5-15E6D11EC630"
     />

  <collection
     name="IHostNetworkInterfaceCollection" type="IHostNetworkInterface"
     enumerator="IHostNetworkInterfaceEnumerator"
     uuid="BF1D41F2-B97B-4314-A0FB-D4823AF42FB5"
     readonly="yes"
     >
    <method name="findByName">
      <desc>
        Searches this collection for a host network interface with the given name.
        <note>
          The method returns an error if the given name does not
          correspond to any host network interface in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host network interface to search for.</desc>
      </param>
      <param name="networkInterface" type="IHostNetworkInterface" dir="return">
        <desc>Found host network interface object.</desc>
      </param>
    </method>
    <method name="findById">
      <desc>
        Searches this collection for a host network interface with the given GUID.
        <note>
          The method returns an error if the given GUID does not
          correspond to any host network interface in the collection.
        </note>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>GUID of the host network interface to search for.</desc>
      </param>
      <param name="networkInterface" type="IHostNetworkInterface" dir="return">
        <desc>Found host network interface object.</desc>
      </param>
    </method>
  </collection>
</if>

  <interface
     name="IHost" extends="$unknown"
     uuid="81729c26-1aec-46f5-b7c0-cc7364738fdb"
     wsmap="managed"
     >
    <desc>
      The IHost interface represents the physical machine that this VirtualBox
      installation runs on.

      An object implementing this interface is returned by the
      <link to="IVirtualBox::host" /> attribute. This interface contains
      read-only information about the host's physical hardware (such as what
      processors, and disks are available, what the host operating system is,
      and so on) and also allows for manipulating some of the host's hardware,
      such as global USB device filters and host interface networking.

    </desc>
    <attribute name="DVDDrives" type="IHostDVDDriveCollection" readonly="yes">
      <desc>List of DVD drives available on the host.</desc>
    </attribute>

    <attribute name="floppyDrives" type="IHostFloppyDriveCollection" readonly="yes">
      <desc>List of floppy drives available on the host.</desc>
    </attribute>

    <attribute name="USBDevices" type="IHostUSBDeviceCollection" readonly="yes">
      <desc>
        List of USB devices currently attached to the host.
        Once a new device is physically attached to the host computer,
        it appears in this list and remains there until detached.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not avaliable in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="USBDeviceFilters" type="IHostUSBDeviceFilterCollection" readonly="yes">
      <desc>
        List of USB device filters in action.
        When a new device is physically attached to the host computer,
        filters from this list are applied to it (in order they are stored
        in the list). The first matched filter will determine the
        <link to="IHostUSBDeviceFilter::action">action</link>
        performed on the device.

        Unless the device is ignored by these filters, filters of all
        currently running virtual machines
        (<link to="IUSBController::deviceFilters"/>) are applied to it.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not avaliable in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>IHostUSBDeviceFilter, USBDeviceState</see>
      </desc>
    </attribute>

<if target="midl">
    <attribute name="networkInterfaces" type="IHostNetworkInterfaceCollection" readonly="yes">
      <desc>List of host network interfaces currently defined on the host.</desc>
    </attribute>
</if>

    <attribute name="processorCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs installed in the host system.</desc>
    </attribute>

    <attribute name="processorSpeed" type="unsigned long" readonly="yes">
      <desc>(Approximate) speed of the host CPU in Megahertz.</desc>
    </attribute>

    <attribute name="processorDescription" type="wstring" readonly="yes">
      <desc>Description string of the host CPU.</desc>
    </attribute>

    <attribute name="memorySize" type="unsigned long" readonly="yes">
      <desc>Amount of system memory in megabytes installed in the host system.</desc>
    </attribute>

    <attribute name="memoryAvailable" type="unsigned long" readonly="yes">
      <desc>Available system memory in the host system.</desc>
    </attribute>

    <attribute name="operatingSystem" type="wstring" readonly="yes">
      <desc>Name of the host system's operating system.</desc>
    </attribute>

    <attribute name="OSVersion" type="wstring" readonly="yes">
      <desc>Host operating system's version string.</desc>
    </attribute>

    <attribute name="UTCTime" type="long long" readonly="yes">
      <desc>Returns the current host time in milliseconds since 1970-01-01 UTC.</desc>
    </attribute>

<if target="midl">
    <method name="createHostNetworkInterface">
      <desc>
        Creates a new adapter for Host Interface Networking.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Adapter name.
        </desc>
      </param>
      <param name="hostInterface" type="IHostNetworkInterface" dir="out">
        <desc>
          Created host interface object.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>
    <method name="removeHostNetworkInterface">
      <desc>
        Removes the given host network interface.
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>
          Adapter GUID.
        </desc>
      </param>
      <param name="hostInterface" type="IHostNetworkInterface" dir="out">
        <desc>
          Removed host interface object.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>
</if>

    <method name="createUSBDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to <tt>null</tt> (any match),
        <i>active</i> is <tt>false</tt> (the filter is not active).

        The created filter can be added to the list of filters using
        <link to="#insertUSBDeviceFilter()"/>.

        <see>#USBDeviceFilters</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IHostUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertUSBDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from <tt>0</tt>. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added to the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter that is already in the list, will return an
          error.
        </note>
        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not avaliable in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>#USBDeviceFilters</see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeUSBDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from <tt>0</tt>. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <note>
          This method may set a @ref com_warnings "warning result code".
        </note>
        <note>
          If USB functionality is not avaliable in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>#USBDeviceFilters</see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="return">
        <desc>Removed USB device filter.</desc>
      </param>
    </method>

  </interface>

  <!--
  // ISystemProperties
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="ISystemProperties"
     extends="$unknown"
     uuid="12c2e31e-247f-4d51-82e5-5b9d4a6c7d5b"
     wsmap="managed"
     >
    <desc>
      The ISystemProperties interface represents global properties
      of the given VirtualBox installation.

      These properties define limits and default values for various
      attributes and parameters. Most of the properties are read-only, but some can be
      changed by a user.
    </desc>

    <attribute name="minGuestRAM" type="unsigned long" readonly="yes">
      <desc>Minium guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="minGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxVDISize" type="unsigned long long" readonly="yes">
      <desc>Maximum size of a virtual disk image in Megabytes.</desc>
    </attribute>

    <attribute name="networkAdapterCount" type="unsigned long" readonly="yes">
      <desc>
        Number of network adapters associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="serialPortCount" type="unsigned long" readonly="yes">
      <desc>
        Number of serial ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="parallelPortCount" type="unsigned long" readonly="yes">
      <desc>
        Number of parallel ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="maxBootPosition" type="unsigned long" readonly="yes">
      <desc>
        Maximum device position in the boot order. This value corresponds
        to the total number of devices a machine can boot from, to make it
        possible to include all possible devices to the boot list.
        <see><link to="IMachine::setBootOrder()"/></see>
      </desc>
    </attribute>

    <attribute name="defaultVDIFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open
        existing virtual disk images when an image file name contains no
        path.

        The initial value of this property is
        <tt>&lt;</tt><link to="IVirtualBox::homeFolder">
          VirtualBox_home</link><tt>&gt;/VDI</tt>.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
        <note>
          When settings this property, the specified path can be
          absolute (full path) or relative
          to the <link to="IVirtualBox::homeFolder">
            VirtualBox home directory</link>.
          When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>

        <see>
          <link to="IVirtualBox::createHardDisk()"/>,
          <link to="IVirtualBox::openVirtualDiskImage()"/>
        </see>
      </desc>
    </attribute>

    <attribute name="defaultMachineFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open
        existing machines when a settings file name contains no
        path.

        The initial value of this property is
        <tt>&lt;</tt><link to="IVirtualBox::homeFolder">
          VirtualBox_home</link><tt>&gt;/Machines</tt>.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
        <note>
          When settings this property, the specified path can be
          absolute (full path) or relative
          to the <link to="IVirtualBox::homeFolder">
            VirtualBox home directory</link>.
          When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>

        <see>
          <link to="IVirtualBox::createMachine()"/>,
          <link to="IVirtualBox::openMachine()"/>
        </see>
      </desc>
    </attribute>

    <attribute name="remoteDisplayAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for VRDP clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration.

        The system library extension (".DLL" or ".so") must be omitted.
        A full path can be specified; if not, then the library must reside on the
        system's default library path.

        The default value of this property is <tt>VRDPAuth</tt>. There is a library
        of that name in one of the default VirtualBox library directories.

        For details about VirtualBox authentication libraries and how to implement
        them, please refer to the VirtualBox manual.

        <note>
          Setting this property to <tt>null</tt> will restore the
          initial value.
        </note>
      </desc>
    </attribute>

    <attribute name="webServiceAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for webservice clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration and will be called from
        within the <link to="IWebsessionManager::logon" /> implementation.

        As opposed to <link to="ISystemProperties::remoteDisplayAuthLibrary" />,
        there is no per-VM setting for this, as the webservice is a global
        resource (if it is running). Only for this setting (for the webservice),
        setting this value to a literal "null" string disables authentication,
        meaning that <link to="IWebsessionManager::logon" /> will always succeed,
        no matter what user name and password are supplied.

        The initial value of this property is <tt>VRDPAuth</tt>,
        meaning that the webservice will use the same authentication
        library that is used by default for VBoxVRDP (again, see
        <link to="ISystemProperties::remoteDisplayAuthLibrary" />).
        The format and calling convetion of authentication libraries
        is the same for the webservice as it is for VBoxVRDP.

      </desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="boolean">
      <desc>
        This specifies the default value for hardware virtualization
        extensions. If enabled, virtual machines will make use of
        hardware virtualization extensions such as Intel VT-x and
        AMD-V by default. This value can be overridden by each VM
        using their <link to="IMachine::HWVirtExEnabled" /> property.
      </desc>
    </attribute>

    <attribute name="LogHistoryCount" type="unsigned long">
      <desc>
        This value specifies how many old release log files are kept.
       </desc>
    </attribute>
  </interface>

  <!--
  // IGuest
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IGuestOSType" extends="$unknown"
     uuid="da94f478-1f37-4726-b750-2235950dc2fe"
     wsmap="struct"
     >
    <desc>
        <note>With the COM API, this is an interface like all the others. With the webservice,
        this is mapped to a structure, so querying the attribute will not return an object,
        but a complete structure.</note>
    </desc>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>Guest OS identifier string.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS.</desc>
    </attribute>

    <attribute name="recommendedRAM" type="unsigned long" readonly="yes">
      <desc>Recommended RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedVRAM" type="unsigned long" readonly="yes">
      <desc>Recommended video RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedHDD" type="unsigned long" readonly="yes">
      <desc>Recommended hard disk size in Megabytes.</desc>
    </attribute>
  </interface>


  <enumerator
     name="IGuestOSTypeEnumerator" type="IGuestOSType"
     uuid="a3335e02-4669-4e3c-80c7-c4dc7056a07c"
     />

  <collection
     name="IGuestOSTypeCollection" type="IGuestOSType" enumerator="IGuestOSTypeEnumerator"
     uuid="a5e36749-a610-498b-9f29-2e36c1042d65"
     readonly="yes"
     />

  <interface
     name="IGuest" extends="$unknown"
     uuid="d8556fca-81bc-12af-fca3-365528fa38ca"

     wsmap="suppress"
     >
    <desc>
      The IGuest interface represents information about the operating system
      running inside the virtual machine. Used in
      <link to="IConsole::guest"/>.

      IGuest provides information about the guest operating system, whether
      Guest Additions are installed and other OS-specific virtual machine
      properties.
    </desc>

    <attribute name="OSTypeId" type="wstring" readonly="yes">
      <desc>
        Identifier of the Guest OS type as reported by the Guest
        Additions.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          If Guest Additions are not installed, this value will be
          the same as <link to="IMachine::OSTypeId"/>.
        </note>
      </desc>
    </attribute>

    <attribute name="additionsActive" type="boolean" readonly="yes">
      <desc>
        Flag whether the Guest Additions are installed and active
        in which case their version will be returned by the
        <link to="#additionsVersion"/> property.
      </desc>
    </attribute>

    <attribute name="additionsVersion" type="wstring" readonly="yes">
      <desc>
        Version of the Guest Additions (3 decimal numbers separated
        by dots) or empty when the Additions are not installed. The
        Additions may also report a version but yet not be active as
        the version might be refused by VirtualBox (incompatible) or
        other failures occured.
      </desc>
    </attribute>

    <attribute name="supportsSeamless" type="boolean" readonly="yes">
      <desc>
        Flag whether seamless guest display rendering (seamless desktop
        integration) is supported.
      </desc>
    </attribute>

    <attribute name="supportsGraphics" type="boolean" readonly="yes">
      <desc>
        Flag whether the guest is in graphics mode.  If it is not, then
        seamless rendering will not work, resize hints are not immediately
        acted on and guest display resizes are probably not initiated by
        the guest additions.
      </desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Guest system memory balloon size in megabytes.</desc>
    </attribute>

    <attribute name="statisticsUpdateInterval" type="unsigned long">
      <desc>Interval to update guest statistics in seconds.</desc>
    </attribute>

    <method name="setCredentials">
      <desc>
        Store login credentials that can be queried by guest operating
        systems with Additions installed. The credentials are transient
        to the session and the guest may also choose to erase them. Note
        that the caller cannot determine whether the guest operating system
        has queried or made use of the credentials.
      </desc>
      <param name="userName" type="wstring" dir="in">
        <desc>User name string, can be empty</desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>Password string, can be empty</desc>
      </param>
      <param name="domain" type="wstring" dir="in">
        <desc>Domain name (guest logon scheme specific), can be emtpy</desc>
      </param>
      <param name="allowInteractiveLogon" type="boolean" dir="in">
        <desc>
          Flag whether the guest should alternatively allow the user to
          interactively specify different credentials. This flag might
          not be supported by all versions of the Additions.
        </desc>
      </param>
    </method>

    <method name="getStatistic">
      <desc>
        Query specified guest statistics as reported by the VirtualBox Additions.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>Virtual CPU id; not relevant for all statistic types</desc>
      </param>
      <param name="statistic" type="GuestStatisticType" dir="in">
        <desc>Statistic type.</desc>
      </param>
      <param name="statVal" type="unsigned long" dir="out">
        <desc>Statistics value</desc>
      </param>
    </method>

  </interface>


  <!--
  // IProgress
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IProgressEnumerator" type="IProgress"
     uuid="e0380522-4ef1-48f4-856c-e455177ccb2d"
     />

  <collection
     name="IProgressCollection" type="IProgress" enumerator="IProgressEnumerator"
     uuid="78B76A7C-F0F2-467c-9F0E-F089A54EE957"
     readonly="yes"
     />

  <interface
     name="IProgress" extends="$unknown"
     uuid="10CC03A1-717E-429b-992D-C67B56175A51"
     wsmap="managed"
     >
    <desc>
      The IProgress interface represents a task progress object that allows
      to wait for the completion of some asynchronous task.

      The task consists of one or more operations that run sequentially,
      one after one. There is an individual percent of completion of the
      current operation and the percent of completion of the task as a
      whole. Similarly, you can wait for the completion of a particular
      operation or for the completion of the whole task.

      Every operation is identified by a number (starting from 0)
      and has a separate description.
    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>ID of the task.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Description of the task.</desc>
    </attribute>

    <attribute name="initiator" type="$unknown" readonly="yes">
      <desc>Initiator of the task.</desc>
    </attribute>

    <attribute name="cancelable" type="boolean" readonly="yes">
      <desc>Whether the task can be interrupted.</desc>
    </attribute>

    <attribute name="percent" type="long" readonly="yes">
      <desc>
        Current task progress value in percent.
        This value depends on how many operations are already complete.
      </desc>
    </attribute>

    <attribute name="completed" type="boolean" readonly="yes">
      <desc>Whether the task has been completed.</desc>
    </attribute>

    <attribute name="canceled" type="boolean" readonly="yes">
      <desc>Whether the task has been canceled.</desc>
    </attribute>

    <attribute name="resultCode" type="result" readonly="yes">
      <desc>
        Result code of the progress task.
        Valid only if <link to="#completed"/> is true.
      </desc>
    </attribute>

    <attribute name="errorInfo" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Extended information about the unsuccessful result of the
        progress operation. May be NULL when no extended information
        is available.
        Valid only if <link to="#completed"/> is true and
        <link to="#resultCode"/> indicates a failure.
      </desc>
    </attribute>

    <attribute name="operationCount" type="unsigned long" readonly="yes">
      <desc>
        Number of operations this task is divided into.
        Every task consists of at least one operation.
      </desc>
    </attribute>

    <attribute name="operation" type="unsigned long" readonly="yes">
      <desc>Number of the operation being currently executed.</desc>
    </attribute>

    <attribute name="operationDescription" type="wstring" readonly="yes">
      <desc>
        Description of the operation being currently executed.
      </desc>
    </attribute>

    <attribute name="operationPercent" type="long" readonly="yes">
      <desc>Current operation progress value in percent.</desc>
    </attribute>

    <method name="waitForCompletion">
      <desc>
        Waits until the task is done (including all operations) with a
        given timeout.
      </desc>
      <param name="timeout" type="long" dir="in">
        <desc>
          Timeout value in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
    </method>

    <method name="waitForOperationCompletion">
      <desc>
        Waits until the given operation is done with a given timeout.
      </desc>
      <param name="operation" type="unsigned long" dir="in">
        <desc>
          Number of the operation to wait for.
          Must be less than <link to="#operationCount"/>.
        </desc>
      </param>
      <param name="timeout" type="long" dir="in">
        <desc>
          Timeout value in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
    </method>

    <method name="cancel">
      <desc>
        Cancels the task.
        <note>
          If <link to="#cancelable"/> is <tt>false</tt>, then
          this method will fail.
        </note>
      </desc>
    </method>

  </interface>


  <!--
  // ISnapshot
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="ISnapshotEnumerator" type="ISnapshot"
     uuid="25cfa2a4-1f1d-4f05-9658-b7a5894ef1a3"
     />

  <collection
     name="ISnapshotCollection" type="ISnapshot"
     enumerator="ISnapshotEnumerator"
     uuid="23852e3c-94cd-4801-ab05-ed35675b3894"
     readonly="yes"
     />

  <interface
     name="ISnapshot" extends="$unknown"
     uuid="9f1bbf79-13b0-4da2-abba-4a992c65c083"
     wsmap="managed"
     >
    <desc>
      The ISnapshot interface represents a snapshot of the virtual
      machine.

      The <i>snapshot</i> stores all the information about a virtual
      machine necessary to bring it to exactly the same state as it was at
      the time of taking the snapshot. The snapshot includes:

      <ul>
        <li>all settings of the virtual machine (i.e. its hardware
          configuration: RAM size, attached hard disks, etc.)
        </li>
        <li>the execution state of the virtual machine (memory contents,
          CPU state, etc.).
        </li>
      </ul>

      Snapshots can be <i>offline</i> (taken when the VM is powered off)
      or <i>online</i> (taken when the VM is running). The execution
      state of the offline snapshot is called a <i>zero execution state</i>
      (it doesn't actually contain any information about memory contents
      or the CPU state, assuming that all hardware is just powered off).

      <h3>Snapshot branches</h3>

      Snapshots can be chained. Chained snapshots form a branch where
      every next snapshot is based on the previous one. This chaining is
      mostly related to hard disk branching (see <link to="IHardDisk"/>
      description). This means that every time a new snapshot is created,
      a new differencing hard disk is implicitly created for all normal
      hard disks attached to the given virtual machine. This allows to
      fully restore hard disk contents when the machine is later reverted
      to a particular snapshot.

      In the current implelemtation, multiple snapshot branches within one
      virtual machine are not allowed. Every machine has a signle branch,
      and <link to="IConsole::takeSnapshot()"/> operation adds a new
      snapshot to the top of that branch.

      Existings snapshots can be discarded using
      <link to="IConsole::discardSnapshot()"/>.

      <h3>Current snapshot</h3>

      Every virtual machine has a current snapshot, identified by
      <link to="IMachine::currentSnapshot"/>. This snapshot is used as
      a base for the <i>current machine state</i> (see below), to the effect
      that all normal hard disks of the machine and its execution
      state are based on this snapshot.

      In the current implementation, the current snapshot is always the
      last taken snapshot (i.e. the head snapshot on the branch) and it
      cannot be changed.

      The current snapshot is <tt>null</tt> if the machine doesn't have
      snapshots at all; in this case the current machine state is just
      current settings of this machine plus its current execution state.

      <h3>Current machine state</h3>

      The current machine state is what represened by IMachine instances got
      directly from IVirtualBox
      using <link
      to="IVirtualBox::getMachine()">getMachine()</link>, <link
      to="IVirtualBox::findMachine()">findMachine()</link>, etc. (as opposed
      to instances returned by <link to="ISnapshot::machine"/>).  This state
      is always used when the machine is <link to="IConsole::powerUp"> powered
      on</link>.

      The current machine state also includes the current execution state.
      If the machine is being currently executed
      (<link to="IMachine::state"/> is <link to="MachineState::Running"/>
      and above), its execution state is just what's happening now.
      If it is powered off (<link to="MachineState::PoweredOff"/> or
      <link to="MachineState::Aborted"/>), it has a zero execution state.
      If the machine is saved (<link to="MachineState::Saved"/>), its
      execution state is what saved in the execution state file
      (<link to="IMachine::stateFilePath"/>).

      If the machine is in the saved state, then, next time it is powered
      on, its execution state will be fully restored from the saved state
      file and the execution will continue from the point where the state
      was saved.

      Similarly to snapshots, the current machine state can be discarded
      using <link to="IConsole::discardCurrentState()"/>.

      <h3>Taking and discarding snapshots</h3>

      The table below briefly explains the meaning of every snapshot
      operation:

      <table>
        <tr><th>Operation</th><th>Meaning</th><th>Remarks</th></tr>

        <tr><td><link to="IConsole::takeSnapshot()"/></td>

          <td>Save the current state of the virtual machine, including all
            settings, contents of normal hard disks and the current modifications
            to immutable hard disks (for online snapshots)</td>

          <td>The current state is not changed (the machine will continue
            execution if it is being executed when the snapshot is
            taken)</td></tr>

        <tr><td><link to="IConsole::discardSnapshot()"/></td>

          <td>Forget the state of the virtual machine stored in the snapshot:
            dismiss all saved settings and delete the saved execution state (for
            online snapshots)</td>

          <td>Other snapshots (including child snapshots, if any) and the
            current state are not directly affected</td></tr>

        <tr><td><link to="IConsole::discardCurrentState()"/></td>

          <td>Restore the current state of the virtual machine from the state
            stored in the current snapshot, including all settings and hard disk
            contents</td>

          <td>The current state of the machine existed prior to this operation
            is lost</td></tr>

        <tr><td><link to="IConsole::discardCurrentSnapshotAndState()"/></td>

          <td>Completely revert the virtual machine to the state it was in
            before the current snapshot has been taken</td>

          <td>The current state, as well as the current snapshot, are
            lost</td></tr>

      </table>

    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>UUID of the snapshot.</desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>Short name of the snapshot.</desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>Optional description of the snapshot.</desc>
    </attribute>

    <attribute name="timeStamp" type="long long" readonly="yes">
      <desc>
        Time stamp of the snapshot, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="online" type="boolean" readonly="yes">
      <desc>
        <tt>true</tt> if this snapshot is an online snapshot and
        <tt>false</tt> otherwise.

        <note>
          When this attribute is <tt>true</tt>, the
          <link to="IMachine::stateFilePath"/> attribute of the
          <link to="#machine"/> object associated with this snapshot
          will point to the saved state file. Otherwise, it will be
          <tt>null</tt>.
        </note>
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Virtual machine this snapshot is taken on. This object
        stores all settings the machine had when taking this snapshot.
        <note>
          The returned machine object is immutable, i.e. no
          any settings can be changed.
        </note>
      </desc>
    </attribute>

    <attribute name="parent" type="ISnapshot" readonly="yes">
      <desc>
        Parent snapshot (a snapshot this one is based on).
        <note>
          It's not an error to read this attribute on a snapshot
          that doesn't have a parent -- a null object will be
          returned to indicate this.
        </note>
      </desc>
    </attribute>

    <attribute name="children" type="ISnapshotCollection" readonly="yes">
      <desc>
        Child snapshots (all snapshots having this one as a parent).
        <note>
          In the current implementation, there can be only one
          child snapshot, or no children at all, meaning this is the
          last (head) snapshot.
        </note>
      </desc>
    </attribute>

  </interface>

  <!--
  // IHardDisk
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="HardDiskStorageType"
    uuid="48138584-ad99-479d-a36f-eb82a7663685"
  >
    <desc>
      Virtual hard disk storage type.
      <see>IHardDisk</see>
    </desc>

    <const name="VirtualDiskImage"  value="0">
      <desc>
        Virtual Disk Image, VDI (a regular file in the file
        system of the host OS, see <link to="IVirtualDiskImage"/>)
      </desc>
    </const>
    <const name="ISCSIHardDisk"     value="1">
      <desc>
        iSCSI Remote Disk (a disk accessed via the Internet
        SCSI protocol over a TCP/IP network, see
        <link to="IISCSIHardDisk"/>)
      </desc>
    </const>
    <const name="VMDKImage"         value="2">
      <desc>
        VMware Virtual Machine Disk image (a regular file in the file
        system of the host OS, see <link to="IVMDKImage"/>)
      </desc>
    </const>
    <const name="CustomHardDisk"    value="3">
      <desc>
        Disk formats supported through plugins (see
        <link to="ICustomHardDisk"/>)
      </desc>
    </const>
    <const name="VHDImage"          value="4">
      <desc>
        Virtual PC Virtual Machine Disk image (a regular file in the file
        system of the host OS, see <link to="IVHDImage"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="HardDiskType"
    uuid="a348fafd-a64e-4643-ba65-eb3896bd7e0a"
   >
    <desc>
      Virtual hard disk type.
      <see>IHardDisk</see>
    </desc>

    <const name="Normal"            value="0">
      <desc>
        Normal hard disk (attached directly or indirectly, preserved
        when taking snapshots).
      </desc>
    </const>
    <const name="Immutable"         value="1">
      <desc>
        Immutable hard disk (attached indirectly, changes are wiped out
        after powering off the virtual machine).
      </desc>
    </const>
    <const name="Writethrough"      value="2">
      <desc>
        Write through hard disk (attached directly, ignored when
        taking snapshots).
      </desc>
    </const>
  </enum>

  <interface
     name="IHardDiskAttachment" extends="$unknown"
     uuid="c0ffe596-21c6-4797-8d8a-b47b66881e7a"
     wsmap="struct"
     >
    <desc>
        <note>With the COM API, this is an interface like all the others. With the webservice,
        this is mapped to a structure, so querying the attribute will not return an object,
        but a complete structure.</note>
    </desc>
    <attribute name="hardDisk" type="IHardDisk" readonly="yes">
      <desc>Harddisk object this attachment is about.</desc>
    </attribute>

    <attribute name="bus" type="StorageBus" readonly="yes">
      <desc>Disk controller ID of this attachment.</desc>
    </attribute>

    <attribute name="channel" type="long" readonly="yes">
      <desc>Channel number of the attachment.</desc>
    </attribute>

    <attribute name="device" type="long" readonly="yes">
      <desc>Device slot number of the attachment.</desc>
    </attribute>

  </interface>

  <enumerator
     name="IHardDiskAttachmentEnumerator" type="IHardDiskAttachment"
     uuid="9955e486-2f0b-432a-99e4-0ebbd338875e"
     />

  <collection
     name="IHardDiskAttachmentCollection" type="IHardDiskAttachment"
     enumerator="IHardDiskAttachmentEnumerator"
     uuid="8f727842-bb77-45d4-92de-4ec14bf613c9"
     readonly="yes"
     />

  <enumerator
     name="IHardDiskEnumerator" type="IHardDisk"
     uuid="b976f97b-cdb8-47e3-9860-084031cbd533"
     />

  <collection
     name="IHardDiskCollection" type="IHardDisk"
     enumerator="IHardDiskEnumerator"
     uuid="43EAC2BC-5C61-40fa-BC38-46DE2C7DB6BB"
     readonly="yes"
     />

  <interface
     name="IHardDisk" extends="$unknown"
     uuid="FD443EC1-000F-4F5B-9282-D72760A66916"
     wsmap="managed"
     >
    <desc>
      The IHardDisk interface represents a virtual hard disk drive
      used by virtual machines.

      The virtual hard disk drive virtualizes the hard disk hardware and
      looks like a regular hard disk inside the virtual machine and
      the guest OS.

      <h3>Storage Types</h3>

      The <link to="HardDiskStorageType">storage type</link> of the
      virtual hard disk determines where and how it stores its data
      (sectors). Currently, the following storage types are supported:

      <ul>

        <li>
          <i>Virtual Disk Image (VDI)</i>, a regular file in the file system
          of the host OS (represented by the <link to="IVirtualDiskImage"/>
          interface). This file has a special format optimized so that unused
          sectors of data occupy much less space than on a physical hard disk.
        </li>

        <li>
          <i>iSCSI Remote Disk</i>, a disk accessed via the Internet SCSI
          protocol over a TCP/IP network link (represented by the
          <link to="IISCSIHardDisk"/> interface).
        </li>

        <li>
          <i>VMware VMDK image</i>, a regular file in the file system of the
          host OS (represented by the <link to="IVMDKImage"/> interface).
          Note that the regular file may be just a descriptor referring to
          further files, so don't make assumptions about the OS representation
          of a VMDK image.
        </li>

        <li>
          <i>Custom HardDisk</i>, a disk accessed via a plugin which is loaded
          when the disk is accessed (represented by the
          <link to="ICustomHardDisk"/> interface).
        </li>

        <li>
          <i>Virtual PC VHD Image</i>, a regular file in the file system of the
          host OS (represented by the <link to="IVHDImage"/> interface).
        </li>

      </ul>

      The storage type of the particular hard disk object is indicated by
      the <link to="#storageType"/> property.

      Each storage type is represented by its own interface (as shown
      above), that allows to query and set properties and perform
      operations specific to that storage type. When an IHardDisk object
      reports it uses some particular storage type, it also guaranteed to
      support the corresponding interface which you can query. And vice
      versa, every object that supports a storage-specific interface, also
      supports IHardDisk.

      <h3>Virtual Hard Disk Types</h3>

      The <link to="HardDiskType">type</link> of the virtual hard disk
      determines how it is attached to the virtual machine when you call
      <link to="IMachine::attachHardDisk()"/> and what happens to it when
      a <link to="ISnapshot">snapshot</link> of the virtual machine is
      taken.

      There are three types of virtual hard disks:

      <ul>
        <li><i>Normal</i></li>
        <li><i>Immutable</i></li>
        <li><i>Writethrough</i></li>
      </ul>

      The virtual disk type is indicated by the <link to="#type"/>
      property. Each of the above types is described in detail further
      down.

      There is also a forth, "hidden" virtual disk type:
      <i>Differencing</i>. It is "hidden" because you cannot directly
      create hard disks of this type -- they are automatically created by
      VirtualBox when necessary.

      <b>Differencing Hard Disks</b>

      Unlike disks of other types (that are similar to real hard disks),
      the differencing hard disk does not store the full range of data
      sectors. Instead, it stores only a subset of sectors of some other
      disk that were changed since the differencing hard disk has been
      created. Thus, every differencing hard disk has a parent hard disk
      it is linked to, and represents the difference between the initial
      and the current hard disk state. A differencing hard disk can be
      linked to another differencing hard disk -- this way, differencing
      hard disks can form a branch of changes. More over, a given virtual
      hard disk can have more than one differencing hard disk linked to
      it.

      A disk the differencing hard disk is linked to (or, in other words,
      based on) is called a <i>parent</i> hard disk and is accessible through
      the <link to="#parent"/> property. Similarly, all existing differencing
      hard disks for a given parent hard disk are called its <i>child</i> hard
      disks (and accessible through the <link to="#children"/> property).

      All differencing hard disks use Virtual Disk Image files to store
      changed sectors. They have the <link to="#type"/> property set to
      Normal, but can be easily distinguished from normal hard disks using
      the <link to="#parent"/> property: all differencing hard disks have
      a parent, while all normal hard disks don't.

      When the virtual machine makes an attempt to read a sector that is
      missing in a differencing hard disk, its parent is accessed to
      resolve the sector in question. This process continues until the
      sector is found, or until the root hard disk is encountered, which
      always contains all sectors. As a consequence,

      <ul>

        <li>
          The virtual hard disk geometry seen by the guest OS is
          always defined by the root hard disk.
        </li>

        <li>
          All hard disks on a branch, up to the root, must be
          <link to="#accessible"/> for a given differencing hard disk in order
          to let it function properly when the virtual machine is
          running.
        </li>

      </ul>

      Differencing hard disks can be implicitly created by VirtualBox in
      the following cases:

      <ul>

        <li>
          When a hard disk is <i>indirectly</i> attached to the virtual
          machine using <link to="IMachine::attachHardDisk()"/>.  In this
          case, all disk writes performed by the guest OS will go to the
          created diffferencing hard disk, as opposed to the
          <i>direct</i> attachment, where all changes are written to the
          attached hard disk itself.
        </li>

        <li>
          When a <link to="ISnapshot">snapshot</link> of the virtual machine
          is taken. After that, disk writes to hard disks the differencing
          ones have been created for, will be directed to those differencing
          hard disks, to preserve the contents of the original disks.
        </li>

      </ul>

      Whether to create a differencing hard disk or not depends on the
      type of the hard disk attached to the virtual machine. This is
      explained below.

      Note that in the current implementation, only the
      <link to="VirtualDiskImage"/> storage type is used to
      represent differencing hard disks. In other words, all
      differencing hard disks are <link to="IVirtualDiskImage"/>
      objects.

      <b>Normal Hard Disks</b>

      Normal hard disks are the most commonly used virtual hard disk. A
      normal hard disk is attached to the machine directly if it is not
      already attached to some other machine. Otherwise, an attempt to
      make an indirect attachment through a differencing hard disk will be
      made. This attempt will fail if the hard disk is attached to a
      virtual machine without snapshots (because it's impossible to create
      a differencing hard disk based on a hard disk that is subject to
      change).

      When an indirect attachment takes place, in the simplest case, where
      the machine the hard disk is being attached to doesn't have
      snapshots, the differencing hard disk will be based on the normal
      hard disk being attached. Otherwise, the first (i.e. the most
      recent) descendant of the given normal hard disk found in the
      current snapshot branch (starting from the current snapshot and
      going up to the root) will be actually used as a base.

      Note that when you detach an indirectly attached hard disk from the
      machine, the created differencing hard disk image is simply
      <b>deleted</b>, so <b>all changes are lost</b>. If you attach the
      same disk again, a clean differencing disk will be created based on
      the most recent child, as described above.

      When taking a snapshot, the contents of all normal hard disks (and
      all differencing disks whose roots are normal hard disks) currently
      attached to the virtual machine is preserved by creating
      differencing hard disks based on them.

      <b>Immutable Hard Disks</b>

      Immutable hard disks can be used to provide a sort of read-only
      access. An immutable hard disk is always attached indirectly. The
      created differencing hard disk is automatically wiped out (recreated
      from scratch) every time you power off the virtual machine. Thus,
      the contents of the immutable disk remains unchanged between runs.

      Detaching an immutable hard disk deletes the differencing disk
      created for it, with the same effect as in case with normal hard
      disks.

      When taking a snapshot, the differencing part of the immutable
      hard disk is cloned (i.e. copied to a separate Virtual Disk Image
      file) without any changes. This is necessary to preserve the exact
      virtual machine state when you create an online snapshot.

      <b>Writethrough Hard Disks</b>

      Hard disks of this type are always attached directly. This means
      that every given writethrough hard disk can be attached only to one
      virtual machine at a time.

      It is impossible to take a snapshot of a virtual machine with the
      writethrough hard disk attached, because taking a snapshot implies
      saving the execution state and preserving the contents of all hard
      disks, but writethrough hard disks cannot be preserved. Preserving
      hard disk contents is necessary to ensure the guest OS stored in the
      snapshot will get the same hard disk state when restored, which is
      especially important when it has open file handles or when there are
      cached files and directories stored in memory.

      <h3>Creating, Opening and Registering Hard Disks</h3>

      Non-differencing hard disks are either created from scratch using
      <link to="IVirtualBox::createHardDisk()"/> or opened from a VDI file
      using <link to="IVirtualBox::openVirtualDiskImage()"/> (only for hard
      disks using the VirtualDiskImage storage type). Once a hard disk is
      created or opened, it needs to be registered using
      <link to="IVirtualBox::registerHardDisk()"/> to make it available for
      attaching to virtual machines. See the documentation of individual
      interfaces for various storage types to get more information.

      Differencing hard disks are never created explicitly and cannot
      be registered or unregistered; they are automatically registered
      upon creation and deregistered when deleted.

      <h3>More about Indirect Hard Disk Attachments</h3>

      Normally, when you attach a hard disk to the virtual machine, and then
      query the corresponding attachment using
      <link to="IMachine::getHardDisk()"/> or
      <link to="IMachine::hardDiskAttachments"/> you will get the same hard
      disk object, whose UUID you passed earlier to
      <link to="IMachine::attachHardDisk()"/>. However, when an indirect
      attachment takes place, calling <link to="IMachine::getHardDisk()"/>
      will return a differencing hard disk object, that is either based on the
      attached hard disk or on another differencing hard disk, the attached
      hard disk is eventually a root for (as described above). In both cases
      the returned hard disk object is the object the virtual machine actually
      uses to perform disk writes to.

      Regardless of whether the attachment is direct or indirect, the
      <link to="#machineId"/> property of the attached disk will contain an
      UUID of the machine object <link to="IMachine::attachHardDisk()"/>
      has been called on.

      Note that both <link to="IMachine::attachHardDisk()"/> and
      <link to="IMachine::detachHardDisk()"/> are <i>lazy</i> operations. In
      particular, this means that when an indirect attachment is made,
      differencing hard disks are not created until machine settings are
      committed using <link to="IMachine::saveSettings()"/>. Similarly, when a
      differencing hard disk is detached, it is not deleted until
      <link to="IMachine::saveSettings()"/> is called. Calling
      <link to="IMachine::discardSettings()"/> cancels all lazy attachments or
      detachments made since the last commit and effectively restores the
      previous set of hard disks.

      <h3>Hard Disk Accessibility</h3>

      The <link to="#accessible"/> attribute of the hard disk object
      defines the accessibility state of the respective hard disk storage
      (for example, the VDI file for IVirtualDiskImage objects). If the
      value of this attribute is <tt>false</tt> then some hard disk
      attributes may contain invalid or outdated values (for example, the
      virtual or the actual hard disk size) until a new accessibility
      check is done that returns <tt>true</tt> (see the attribute
      description for more details).

      <note>
        Because of the possible slowness of the accessibility check,
        it is not implicitly performed upon the VirtualBox server startup
        (to prevent the application freeze). In partcular, this means that
        if you try to read hard disk properties that depend on the
        accessibility state without first reading the value of the
        <link to="#accessible"/> attribute and ensuring it's value is
        <tt>true</tt>, you will get wrong (zero) values.
      </note>

    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>

        UUID of the hard disk. For newly created hard disk objects,
        this value is a randomly generated UUID.

      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>

        Optional description of the hard disk. For a newly created hard
        disk, this value is <tt>null</tt>.

        <note>For some storage types, reading this property is
          meaningless when <link to="#accessible"/> is <tt>false</tt>.
          Also, you cannot assign it a new value in this case.</note>

      </desc>
    </attribute>

    <attribute name="storageType" type="HardDiskStorageType" readonly="yes">
      <desc>

        Storage type of this hard disk.

        Storage type is defined when you open or create a new hard disk
        object.

      </desc>
    </attribute>

    <attribute name="location" type="wstring" readonly="yes">
      <desc>

        Storage location of this hard disk. The returned string serves
        for informational purposes only. To access detailed information
        about the storage, query the appropriate storage-specific
        interface.

      </desc>
    </attribute>

    <attribute name="type" type="HardDiskType">
      <desc>

        Type (behavior) of this hard disk. For a newly created or opened hard
        disk, this value is <link to="HardDiskType::Normal"/>.

        <note>
          In the current implementation, this property can be
          changed only on an unregistered hard disk object. This may be
          changed later.
        </note>

      </desc>
    </attribute>

    <attribute name="parent" type="IHardDisk" readonly="yes">
      <desc>

        Parent of this hard disk (a hard disk this one is directly based
        on).

        Only differencing hard disks have parents, so a <tt>null</tt>
        object is returned for a hard disk of any other type.
      </desc>
    </attribute>

    <attribute name="children" type="IHardDiskCollection" readonly="yes">
      <desc>

        Children of this hard disk (all differencing hard disks for
        those this one is a parent). An empty collection is returned, if
        this hard disk doesn't have any children.

      </desc>
    </attribute>

    <attribute name="root" type="IHardDisk" readonly="yes">
      <desc>

        Root hard disk of this hard disk. If this hard disk is a
        differencing hard disk, its root hard disk is the first disk on
        the branch. For all other types of hard disks, this property
        returns the hard disk object itself (i.e. the same object you
        read this property on).

      </desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>

        Whether the hard disk storage is currently accessible or not.
        The storage, for example, can be unaccessible if it doesn't exist
        or if it is placed on a network resource that is not available
        by the time this attribute is read.

        In the current implementation, the value of this property is
        also <tt>false</tt> if this hard disk is attached to a running
        virtual machine.

        The accessibility check is performed automatically every time
        this attribute is read. You should keep it in mind that this check
        may be slow and can block the calling thread for a long time (for
        example, if the network resourse where the hard disk storage is
        located is down).

        The following attributes of the hard disk object are considered
        to be invalid when this attribute is <tt>false</tt>:
        <ul>
          <li><link to="#size"/></li>
          <li><link to="#actualSize"/></li>
        </ul>
        Individual hard disk storage type interfaces may define
        additional attributes that depend on the accessibility state.
      </desc>
    </attribute>

    <attribute name="allAccessible" type="boolean" readonly="yes">
      <desc>

        Whether the whole hard disk branch, starting from this image and
        going through its ancestors up to the root, is accessible or
        not.

        This property makes sense only for differencing hard disks. For
        all other types of hard disks it returns the same value as
        <link to="#accessible"/>.

      </desc>
    </attribute>

    <attribute name="lastAccessError" type="wstring" readonly="yes">
      <desc>

        String describing the reason of inaccessibility of this hard
        disk after the last call to <link to="#accessible"/> that
        returned <tt>false</tt>. A <tt>null</tt> value of this property
        means that the last accessibility check returned <tt>true</tt>.

      </desc>
    </attribute>

    <attribute name="size" type="unsigned long long" readonly="yes">
      <desc>

        Logical size of this hard disk (in megabytes), as reported to the
        guest OS running inside the vurtual machine this disk is
        attached to. The logical size is defined when the hard disk is
        created.

        <note>Reading this property on a differencing hard disk will
          return the size of its root hard disk.</note>

        <note>Reading this property is meaningless when
          <link to="#accessible"/> is <tt>false</tt></note>

      </desc>
    </attribute>

    <attribute name="actualSize" type="unsigned long long" readonly="yes">
      <desc>

        Physical size of the storage used to store hard disk data (in
        bytes). This size is usually less than the logical size of the
        hard disk, depending on the storage type and on the size
        optimization method used for that storage.

        <note>Reading this property is meaningless when
          <link to="#accessible"/> is <tt>false</tt></note>

      </desc>
    </attribute>

    <attribute name="machineId" type="uuid" readonly="yes">
      <desc>

        UUID of the machine this hard disk is attached to (or a
        <tt>null</tt> UUID if it is not attached).

        <note>Immutable hard disks are never attached directly, so this
          attribute is always <tt>null</tt> in this case.</note>

      </desc>
    </attribute>

    <attribute name="snapshotId" type="uuid" readonly="yes">
      <desc>

        UUID of the <link to="ISnapshot">snapshot</link> this hard disk
        is associated with (or <tt>null</tt> UUID if it is not
        associated with any snapshot).

        <note>
          This attribute is always <tt>null</tt> if <link to="#machineId"/>
          is <tt>null</tt>.
        </note>

        <note>
          Writethrough hard disks are always attached directly and cannot be
          involved when taking snapshots, so this attribute is meaningless and
          therefore always <tt>null</tt>.
        </note>

      </desc>
    </attribute>

    <method name="cloneToImage">

      <desc>

        Starts creating a clone of this hard disk. The cloned hard disk
        will use the specified Virtual Disk Image file as a storage and
        will contain exactly the same sector data as the hard disk being
        cloned, except that a new UUID for the clone will be randomly
        generated.

        The specified image file path can be absolute (full path) or
        relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
          home directory</link>. If only a file name without any path is
        given, the <link to="ISystemProperties::defaultVDIFolder">
          default VDI folder</link> will be used as a path to the image
        file.

        It is an error to use the object returned in the @a image
        parameter until the returned @a progress object reports success.

        <note>In the current implementation, only non-differencing hard
          disks can be cloned.</note>

      </desc>

      <param name="filePath" type="wstring" dir="in">
        <desc>Path to a file where to store the cloned hard disk.</desc>
      </param>
      <param name="image" type="IVirtualDiskImage" dir="out">
        <desc>Cloned hard disk object.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

  </interface>

  <!--
  // IVirtualDiskImage
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualDiskImage" extends="$unknown"
     uuid="a8265b5a-0d20-4a46-a02f-65693a4e8239"
     wsmap="managed"
     >

    <desc>
      The IVirtualDiskImage interface represent a specific type of
      <link to="IHardDisk" /> that uses VDI image files.

      The Virtual Disk Image (VDI) format is VirtualBox's native format for
      hard disk containers.

      Objects that support this interface also support the
      <link to="IHardDisk"/> interface.

      Hard disks using virtual disk images can be either opened using
      <link to="IVirtualBox::openHardDisk()"/> or created from
      scratch using <link to="IVirtualBox::createHardDisk()"/>.

      When a new hard disk object is created from scratch, an image file for it
      is not automatically created. To do it, you need to specify a
      valid <link to="#filePath">file path</link>, and call
      <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>.
      When it is done, the hard disk object can be registered by calling
      <link to="IVirtualBox::registerHardDisk()"/> and then
      <link to="IMachine::attachHardDisk()">attached</link> to
      virtual machines.

      The <link to="IHardDisk::description">description</link> of the
      Virtual Disk Image is stored in the image file. For this reason,
      changing the value of this property requires the hard disk to be
      <link to="IHardDisk::accessible">accessible</link>. The description
      of a registered hard disk can be changed only if a virtual machine
      using it is not running.

    </desc>

    <attribute name="filePath" type="wstring">
      <desc>

        Full file name of the virtual disk image of this hard disk. For
        newly created hard disk objects, this value is <tt>null</tt>.

        When assigning a new path, it can be absolute (full path) or relative
        to the <link to="IVirtualBox::homeFolder"> VirtualBox home
        directory</link>. If only a file name without any path is given,
        the <link to="ISystemProperties::defaultVDIFolder"> default VDI
        folder</link> will be used as a path to the image file.

        When reading this propery, a full path is always returned.

        <note>
          This property cannot be changed when <link to="#created"/>
          returns <tt>true</tt>.
        </note>

      </desc>
    </attribute>

    <attribute name="created" type="boolean" readonly="yes">
      <desc>

        Whether the virual disk image is created or not. For newly
        created hard disk objects or after a successful invocation of
        <link to="#deleteImage()"/>, this value is <tt>false</tt> until
        <link to="#createFixedImage()"/> or <link
                                               to="#createDynamicImage()"/> is called.

      </desc>
    </attribute>

    <method name="createDynamicImage">

      <desc>

        Starts creating a dymically expanding hard disk image in the
        background. The previous image associated with this object, if
        any, must be deleted using <link to="#deleteImage"/>, otherwise
        the operation will fail.

        <note>After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link>
          within this VirtualBox installation.</note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Maximum logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="createFixedImage">
      <desc>

        Starts creating a fixed-size hard disk image in the background.  The
        previous image, if any, must be deleted using
        <link to="#deleteImage"/>, otherwise the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link>
          within this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="deleteImage">
      <desc>

        Deletes the existing hard disk image. The hard disk must not be
        registered within this VirtualBox installation, otherwise the
        operation will fail.

        <note>
          After this operation succeeds, it will be impossible to
          register the hard disk until the image file is created
          again.
        </note>

        <note>
          This operation is valid only for non-differencing hard disks, after
          they are unregistered using
          <link to="IVirtualBox::unregisterHardDisk()"/>.
        </note>

      </desc>
    </method>

  </interface>

  <!--
  // IISCSIHardDisk
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IISCSIHardDisk" extends="$unknown"
     uuid="003f6ca9-3257-4ef9-99c9-c66ce44576cb"
     wsmap="managed"
     >

    <desc>
      THe IISCSIHardDisk interface represents a specific type of
      <link to="IHardDisk"/> that uses iSCSI.

      The IISCSIHardDisk interface represents <link to="IHardDisk">virtual
      hard disks</link> that use the Internet SCSI (iSCSI) protocol to store
      hard disk data on remote machines.

      Objects that support this interface also support the
      <link to="IHardDisk"/> interface.

      iSCSI hard disks can be created using
      <link to="IVirtualBox::createHardDisk()"/>. When a new hard disk object
      is created, all its properties are uninitialized. After you assign some
      meaningful values to them, the hard disk object can be registered by
      calling <link to="IVirtualBox::registerHardDisk()"/> and
      then <link to="IMachine::attachHardDisk()">attached</link> to virtual
      machines.

      The <link to="IHardDisk::description">description</link>
      of the iSCSI hard disk is stored in the VirtualBox
      configuration file, so it can be changed (at appropriate
      times) even when
      <link to="IHardDisk::accessible">accessible</link> returns
      <tt>false</tt>.  However, the hard disk must not be
      attached to a running virtual machine.

      <note>
        In the current imlementation, the type of all iSCSI hard disks
        is <link to="HardDiskType::Writethrough">Writethrough</link>
        and cannot be changed.
      </note>

    </desc>

    <attribute name="server" type="wstring">
      <desc>

        iSCSI Server name (either a host name or an IP address). For
        newly created hard disk objects, this value is <tt>null</tt>.

      </desc>
    </attribute>

    <attribute name="port" type="unsigned short">
      <desc>

        iSCSI Server port. For newly created hard disk objects, this
        value is <tt>0</tt>, which means the default port.

      </desc>
    </attribute>

    <attribute name="target" type="wstring">
      <desc>

        iSCSI target name. For newly created hard disk objects, this
        value is <tt>null</tt>.

      </desc>
    </attribute>

    <attribute name="lun" type="unsigned long long">
      <desc>

        Logical unit number for this iSCSI disk. For newly created hard
        disk objects, this value is <tt>0</tt>.

      </desc>
    </attribute>

    <attribute name="userName" type="wstring">
      <desc>

        User name for accessing this iSCSI disk. For newly created hard
        disk objects, this value is <tt>null</tt>.

      </desc>
    </attribute>

    <attribute name="password" type="wstring">
      <desc>

        User password for accessing this iSCSI disk. For newly created
        hard disk objects, this value is <tt>null</tt>.

      </desc>
    </attribute>

  </interface>

  <!--
  // IVMDKImage
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVMDKImage" extends="$unknown"
     uuid="178398f5-8559-4fee-979e-420af5b53eef"
     wsmap="managed"
     >
    <desc>
      The IVMDKImage interface represents a specific type of
      <link to="IHardDisk"/> that uses VMDK image files.

      The Virtual Machine Disk (VMDK) format is the industry standard format
      for virtual hard disk image files, which VirtualBox supports besides its
      own native VDI format.

      Objects that support this interface also support the
      <link to="IHardDisk"/> interface.

      Hard disks using VMDK images can be either opened using
      <link to="IVirtualBox::openHardDisk()"/> or created from
      scratch using <link to="IVirtualBox::createHardDisk()"/>.

      When a new hard disk object is created from scratch, an image file for it
      is not automatically created. To do it, you need to specify a
      valid <link to="#filePath">file path</link>, and call
      <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>.
      When it is done, the hard disk object can be registered by calling
      <link to="IVirtualBox::registerHardDisk()"/> and then
      <link to="IMachine::attachHardDisk()">attached</link> to
      virtual machines.

      The <link to="IHardDisk::description">description</link>
      of the VMDK hard disk is stored in the VirtualBox
      configuration file, so it can be changed (at appropriate
      times) even when
      <link to="IHardDisk::accessible">accessible</link> returns
      <tt>false</tt>.  However, the hard disk must not be
      attached to a running virtual machine.

      <note>
        In the current imlementation, the type of all VMDK hard disks
        is <link to="HardDiskType::Writethrough">Writethrough</link> and cannot
        be changed.
      </note>

    </desc>

    <attribute name="filePath" type="wstring">
      <desc>

        Full file name of the VMDK image of this hard disk. For
        newly created hard disk objects, this value is <tt>null</tt>.

        When assigning a new path, it can be absolute (full path) or relative
        to the <link to="IVirtualBox::homeFolder"> VirtualBox home
        directory</link>. If only a file name without any path is given,
        the <link to="ISystemProperties::defaultVDIFolder"> default VDI
        folder</link> will be used as a path to the image file.

        When reading this propery, a full path is always returned.

        <note>
          This property cannot be changed when <link to="#created"/>
          returns <tt>true</tt>.
        </note>

      </desc>
    </attribute>

    <attribute name="created" type="boolean" readonly="yes">
      <desc>

        Whether the virual disk image is created or not. For newly created
        hard disk objects or after a successful invocation of
        <link to="#deleteImage()"/>, this value is <tt>false</tt> until
        <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>
        is called.

      </desc>
    </attribute>

    <method name="createDynamicImage">

      <desc>

        Starts creating a dymically expanding hard disk image in the
        background. The previous image associated with this object, if
        any, must be deleted using <link to="#deleteImage"/>, otherwise
        the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link> within
          this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Maximum logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="createFixedImage">
      <desc>

        Starts creating a fixed-size hard disk image in the background.  The
        previous image, if any, must be deleted using
        <link to="#deleteImage"/>, otherwise the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link> within
          this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="deleteImage">
      <desc>

        Deletes the existing hard disk image. The hard disk must not be
        registered within this VirtualBox installation, otherwise the
        operation will fail.

        <note>
          After this operation succeeds, it will be impossible to register the
          hard disk until the image file is created again.
        </note>

        <note>
          This operation is valid only for non-differencing hard disks, after
          they are unregistered using
          <link to="IVirtualBox::unregisterHardDisk()"/>.
        </note>

      </desc>
    </method>

  </interface>

  <!--
  // ICustomHardDisk
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="ICustomHardDisk" extends="$unknown"
     uuid="a7b0236d-3ff4-47c0-a4aa-ddc4ddc1141a"
     wsmap="managed"
     >
    <desc>
      The ICustomHardDisk interface represents a specific type of
      <link to="IHardDisk" /> that is supported through a third-party plugin.

      This interface allows to add support for custom hard disk formats to
      VirtualBox.

      Objects that support this interface also support the
      <link to="IHardDisk"/> interface.

      Hard disks using custom hard disk formats can be either opened using
      <link to="IVirtualBox::openHardDisk()"/> or created from scratch using
      <link to="IVirtualBox::createHardDisk()"/>.

      When a new hard disk object is created from scratch, an image file for
      it is not automatically created. To do it, you need to specify a
      valid <link to="#location">location</link>, and call
      <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>.
      When it is done, the hard disk object can be registered by calling
      <link to="IVirtualBox::registerHardDisk()"/> and then
      <link to="IMachine::attachHardDisk()">attached</link> to
      virtual machines.

      The <link to="IHardDisk::description">description</link>
      of the hard disk is stored in the VirtualBox
      configuration file, so it can be changed (at appropriate
      times) even when
      <link to="IHardDisk::accessible">accessible</link> returns
      <tt>false</tt>.  However, the hard disk must not be
      attached to a running virtual machine.

    </desc>

    <attribute name="location" type="wstring">
      <desc>

        Location of this custom hard disk. For
        newly created hard disk objects, this value is <tt>null</tt>.

        The format of the location string is plugin-dependent. In case if the
        plugin uses a regular file in the local file system to store hard disk
        data, then the location is a file path and the following rules apply:
        <ul>
          <li>
            when assigning a new path, it must be absolute (full path) or
            relative to the <link to="IVirtualBox::homeFolder"> VirtualBox
            home directory</link>.  If only a file name without any path is
            given, the <link to="ISystemProperties::defaultVDIFolder"> default
            VDI folder</link> will be used as a path to the image file.
          </li>
          <li>
            When reading this propery, a full path is always returned.
          </li>
        </ul>

        <note>
          This property cannot be changed when <link to="#created"/>
          returns <tt>true</tt>.
        </note>

      </desc>
    </attribute>

    <attribute name="format" type="wstring" readonly="yes">
      <desc>

      The plugin name of the image file.

      </desc>
    </attribute>

    <attribute name="created" type="boolean" readonly="yes">
      <desc>

        Whether the virual disk image is created or not. For newly created
        hard disk objects or after a successful invocation of
        <link to="#deleteImage()"/>, this value is <tt>false</tt> until
        <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>
        is called.

      </desc>
    </attribute>

    <method name="createDynamicImage">

      <desc>

        Starts creating a dymically expanding hard disk image in the
        background. The previous image associated with this object, if
        any, must be deleted using <link to="#deleteImage"/>, otherwise
        the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link> within
          this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Maximum logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="createFixedImage">
      <desc>

        Starts creating a fixed-size hard disk image in the background.  The
        previous image, if any, must be deleted using
        <link to="#deleteImage"/>, otherwise the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link> within
          this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="deleteImage">
      <desc>

        Deletes the existing hard disk image. The hard disk must not be
        registered within this VirtualBox installation, otherwise the
        operation will fail.

        <note>
          After this operation succeeds, it will be impossible to register the
          hard disk until the image file is created again.
        </note>

        <note>
          This operation is valid only for non-differencing hard disks, after
          they are unregistered using
          <link to="IVirtualBox::unregisterHardDisk()"/>.
        </note>

      </desc>
    </method>

  </interface>

  <!--
  // IVHDImage
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVHDImage" extends="$unknown"
     uuid="163b88c3-7552-424a-8205-daf17a004747"
     wsmap="managed"
     >
    <desc>

      The IVHDImage interface represents <link to="IHardDisk">virtual hard
      disks</link> that use Virtual PC Virtual Machine Disk image files to store
      hard disk data.

      Hard disks using VHD images can be either opened using
      <link to="IVirtualBox::openHardDisk()"/> or created from
      scratch using <link to="IVirtualBox::createHardDisk()"/>.

      Objects that support this interface also support the
      <link to="IHardDisk"/> interface.

      When a new hard disk object is created from scatch, an image file for it
      is not automatically created. To do it, you need to specify a
      valid <link to="#filePath">file path</link>, and call
      <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>.
      When it is done, the hard disk object can be registered by calling
      <link to="IVirtualBox::registerHardDisk()"/> and then
      <link to="IMachine::attachHardDisk()">attached</link> to
      virtual machines.

      The <link to="IHardDisk::description">description</link>
      of the VHD hard disk is stored in the VirtualBox
      configuration file, so it can be changed (at appropriate
      times) even when
      <link to="IHardDisk::accessible">accessible</link> returns
      <tt>false</tt>.  However, the hard disk must not be
      attached to a running virtual machine.

      <note>
        In the current imlementation, the type of all VHD hard disks
        is <link to="HardDiskType::Writethrough">Writethrough</link> and cannot
        be changed.
      </note>

    </desc>

    <attribute name="filePath" type="wstring">
      <desc>

        Full file name of the VHD image of this hard disk. For
        newly created hard disk objects, this value is <tt>null</tt>.

        When assigning a new path, it can be absolute (full path) or relative
        to the <link to="IVirtualBox::homeFolder"> VirtualBox home
        directory</link>. If only a file name without any path is given,
        the <link to="ISystemProperties::defaultVDIFolder"> default VDI
        folder</link> will be used as a path to the image file.

        When reading this propery, a full path is always returned.

        <note>
          This property cannot be changed when <link to="#created"/>
          returns <tt>true</tt>. In this case, the specified file name can be
          absolute (full path) or relative to
          the <link to="IVirtualBox::homeFolder"> VirtualBox home
          directory</link>.  If only a file name without any path is given,
          the <link to="ISystemProperties::defaultVDIFolder"> default VDI
          folder</link> will be used as a path to the image file.
        </note>

      </desc>
    </attribute>

    <attribute name="created" type="boolean" readonly="yes">
      <desc>

        Whether the virual disk image is created or not. For newly created
        hard disk objects or after a successful invocation of
        <link to="#deleteImage()"/>, this value is <tt>false</tt> until
        <link to="#createFixedImage()"/> or <link to="#createDynamicImage()"/>
        is called.

      </desc>
    </attribute>

    <method name="createDynamicImage">

      <desc>

        Starts creating a dymically expanding hard disk image in the
        background. The previous image associated with this object, if
        any, must be deleted using <link to="#deleteImage"/>, otherwise
        the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
         <link to="IVirtualBox::registerHardDisk()">registered</link> within
          this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Maximum logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="createFixedImage">
      <desc>

        Starts creating a fixed-size hard disk image in the background.  The
        previous image, if any, must be deleted using
        <link to="#deleteImage"/>, otherwise the operation will fail.

        <note>
          After the returned progress object reports that the
          operation is complete, this hard disk object can be
          <link to="IVirtualBox::registerHardDisk()">registered</link> within
          this VirtualBox installation.
        </note>

      </desc>

      <param name="size" type="unsigned long long" dir="in">
        <desc>Logical size of the hard disk in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>

    </method>

    <method name="deleteImage">
      <desc>

        Deletes the existing hard disk image. The hard disk must not be
        registered within this VirtualBox installation, otherwise the
        operation will fail.

        <note>
          After this operation succeeds, it will be impossible to register the
          hard disk until the image file is created again.
        </note>

        <note>
          This operation is valid only for non-differencing hard disks, after
          they are unregistered using
          <link to="IVirtualBox::unregisterHardDisk()"/>.
        </note>

      </desc>
    </method>

  </interface>

  <!--
  // IDVDImage
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IDVDImageEnumerator" type="IDVDImage"
     uuid="9BE77C8D-E1BE-4bf2-A67B-B4DD3D2B0F28"
     />

  <collection
     name="IDVDImageCollection" type="IDVDImage"
     enumerator="IDVDImageEnumerator"
     uuid="AE7053FA-ADD2-4ea4-AFCF-24D5F8DDED64"
     readonly="yes"
     >
    <method name="findByPath">
      <desc>
        Searches this collection for a DVD image with the given disk path.
        <note>
          The method returns an error if the given name does not
          correspond to any DVD image in the collection.
        </note>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Name of the DVD image's file system location.</desc>
      </param>
      <param name="image" type="IDVDImage" dir="return">
        <desc>Found DVD image object</desc>
      </param>
    </method>
  </collection>

  <interface
     name="IDVDImage" extends="$unknown"
     uuid="140FFF03-E479-4194-8562-ABC4F8171009"
     wsmap="managed"
     >
    <desc>

      The IDVDImage interface represents a file containing the image
      of the DVD or CD disk.

      <h3>Image Accessibility</h3>

      The <link to="#accessible"/> attribute of the image object
      defines the accessibility state of the image file. If the
      value of this attribute is <tt>false</tt> then some image
      attributes may contain invalid or outdated values (for example, the
      the image file size) until a new accessibility
      check is done that returns <tt>true</tt>.

      <note>
        Because of the possible slowness of the accessibility check,
        it is not implicitly performed upon the VirtualBox server startup
        (to prevent the application freeze). In partcular, this means that
        if you try to read image properties that depend on the
        accessibility state without first reading the value of the
        <link to="#accessible"/> attribute and ensuring it's value is
        <tt>true</tt>, you will get wrong (zero) values.
      </note>

    </desc>
    <attribute name="id" type="uuid" readonly="yes">
      <desc>UUID of the CD/DVD image.</desc>
    </attribute>

    <attribute name="filePath" type="wstring" readonly="yes">
      <desc>Full file name of the CD/DVD image.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>

        Whether the CD/DVD image is currently accessible or not.
        The image, for example, can be unaccessible if it is placed
        on a network share that is not available by the time
        this property is read.

        The accessibility check is performed automatically every time
        this attribute is read. You should keep it in mind that this check
        may be slow and can block the calling thread for a long time (for
        example, if the network share where the image is located is down).

        The following attributes of the image object are considered
        to be invalid when this attribute is <tt>false</tt>:
        <ul>
          <li><link to="#size"/></li>
        </ul>

      </desc>
    </attribute>

    <attribute name="size" type="unsigned long long" readonly="yes">
      <desc>Size of the ISO image in bytes.</desc>
    </attribute>

  </interface>


  <!--
  // IDVDDrive
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IDVDDrive" extends="$unknown"
     uuid="d9bd101a-8079-4fb9-bad1-31bf32482b75"
     wsmap="managed"
     >
    <desc>
      The IDVDDrive interface represents the virtual CD/DVD drive of the
      virtual machine. Used in <link to="IMachine::DVDDrive"/>.
    </desc>
    <attribute name="state" type="DriveState" readonly="yes">
      <desc>Current drive state.</desc>
    </attribute>

    <attribute name="passthrough" type="boolean">
      <desc>
        When a host drive is mounted and passthrough is enabled
        the guest will be able to directly send SCSI commands to
        the host drive. This enables the guest to use CD/DVD writers
        but is potentially dangerous.
      </desc>
    </attribute>

    <method name="mountImage">
      <desc>Mounts the specified image.</desc>
      <param name="imageId" type="uuid" dir="in"/>
    </method>

    <method name="captureHostDrive">
      <desc>Captures the specified host drive.</desc>
      <param name="drive" type="IHostDVDDrive" dir="in"/>
    </method>

    <method name="unmount">
      <desc>Unmounts the currently mounted image/device.</desc>
    </method>

    <method name="getImage">
      <desc>Gets the currently mounted image ID.</desc>
      <param name="image" type="IDVDImage" dir="return"/>
    </method>

    <method name="getHostDrive">
      <desc>Gets the currently mounted image ID.</desc>
      <param name="drive" type="IHostDVDDrive" dir="return"/>
    </method>

  </interface>

  <!--
  // IFloppyImage
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IFloppyImageEnumerator" type="IFloppyImage"
     uuid="902C4089-76B7-41f1-91E8-49A261A28A2C"
     />

  <collection
     name="IFloppyImageCollection" type="IFloppyImage"
     enumerator="IFloppyImageEnumerator"
     uuid="327A8928-8572-446e-AD9A-18FE30E81F3F"
     readonly="yes">
    <method name="findByPath">
      <desc>
        Searches this collection for a floppy image with the given disk path.
        <note>
          The method returns an error if the given name does not
          correspond to any floppy image in the collection.
        </note>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Name of the floppy image's file system location.</desc>
      </param>
      <param name="image" type="IFloppyImage" dir="return">
        <desc>Found Floppy image object</desc>
      </param>
    </method>
  </collection>

  <interface
     name="IFloppyImage" extends="$unknown"
     uuid="CC696755-EA98-4ffe-9DC5-C003047034AB"
     wsmap="managed"
     >
    <desc>

      The IFloppyImage interface represents a file containing the image
      of a floppy disk.

      <h3>Image Accessibility</h3>

      The <link to="#accessible"/> attribute of the image object
      defines the accessibility state of the image file. If the
      value of this attribute is <tt>false</tt> then some image
      attributes may contain invalid or outdated values (for example, the
      the image file size) until a new accessibility
      check is done that returns <tt>true</tt>.

      <note>
        Because of the possible slowness of the accessibility check,
        it is not implicitly performed upon the VirtualBox server startup
        (to prevent the application freeze). In partcular, this means that
        if you try to read image properties that depend on the
        accessibility state without first reading the value of the
        <link to="#accessible"/> attribute and ensuring it's value is
        <tt>true</tt>, you will get wrong (zero) values.
      </note>

    </desc>
    <attribute name="id" type="uuid" readonly="yes">
      <desc>UUID of the floppy image.</desc>
    </attribute>

    <attribute name="filePath" type="wstring" readonly="yes">
      <desc>Full file name of the floppy image.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>

        Whether the floppy image is currently accessible or not.
        The image, for example, can be unaccessible if it is placed
        on a network share that is not available by the time
        this property is read.

        The accessibility check is performed automatically every time
        this attribute is read. You should keep it in mind that this check
        may be slow and can block the calling thread for a long time (for
        example, if the network share where the image is located is down).

        The following attributes of the image object are considered
        to be invalid when this attribute is <tt>false</tt>:
        <ul>
          <li><link to="#size"/></li>
        </ul>

      </desc>
    </attribute>

    <attribute name="size" type="unsigned long" readonly="yes">
      <desc>Size of the floppy image in bytes.</desc>
    </attribute>

  </interface>


  <!--
  // IFloppyDrive
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IFloppyDrive" extends="$unknown"
     uuid="E9318F71-78D2-4b00-863C-B7CB0030A2D9"
     wsmap="managed"
     >
    <desc>
      The IFloppyDrive interface represents the virtual floppy drive of the
      virtual machine. Used in <link to="IMachine::FloppyDrive" />.
    </desc>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the floppy drive is enabled. If it is disabled,
        the floppy drive will not be reported to the guest.
      </desc>
    </attribute>

    <attribute name="state" type="DriveState" readonly="yes">
      <desc>Current drive state.</desc>
    </attribute>

    <method name="mountImage">
      <desc>Mounts the specified image.</desc>
      <param name="imageId" type="uuid" dir="in"/>
    </method>

    <method name="captureHostDrive">
      <desc>Captures the specified host drive.</desc>
      <param name="drive" type="IHostFloppyDrive" dir="in"/>
    </method>

    <method name="unmount">
      <desc>Unmounts the currently mounted image/device.</desc>
    </method>

    <method name="getImage">
      <desc>Gets the currently mounted image ID.</desc>
      <param name="image" type="IFloppyImage" dir="return"/>
    </method>

    <method name="getHostDrive">
      <desc>Gets the currently mounted image ID.</desc>
      <param name="drive" type="IHostFloppyDrive" dir="return"/>
    </method>

  </interface>


  <!--
  // IKeyboard
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IKeyboard" extends="$unknown"
     uuid="FD443EC1-000A-4F5B-9282-D72760A66916"
     wsmap="managed"
     >
    <desc>
      The IKeyboard interface represents the virtual machine's keyboard. Used
      in <link to="IConsole::keyboard"/>.

      Through this interface, the virtual machine's virtual keyboard can be controlled. One
      can send keystrokes to the virtual machine and send the Ctrl-Alt-Del sequence to it.
    </desc>
    <method name="putScancode">
      <desc>Sends a scancode to the keyboard.</desc>
      <param name="scancode" type="long" dir="in"/>
    </method>

    <method name="putScancodes">
      <desc>Sends an array of scancode to the keyboard.</desc>
      <param name="scancodes" type="long" dir="in" array="count"/>
      <param name="count" type="unsigned long" dir="in"/>
      <param name="codesStored" type="unsigned long" dir="return"/>
    </method>

    <method name="putCAD">
      <desc>Sends the Ctrl-Alt-Del sequence to the keyboard.</desc>
    </method>

  </interface>


  <!--
  // IMouse
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MouseButtonState"
    uuid="03131722-2EC5-4173-9794-0DACA46673EF"
  >
    <desc>
      Mouse button state.
    </desc>

    <const name="LeftButton"        value="0x01"/>
    <const name="RightButton"       value="0x02"/>
    <const name="MiddleButton"      value="0x04"/>
    <const name="WheelUp"           value="0x08"/>
    <const name="WheelDown"         value="0x10"/>
    <const name="MouseStateMask"    value="0x1F"/>
  </enum>

  <interface
     name="IMouse" extends="$unknown"
     uuid="FD443EC1-0006-4F5B-9282-D72760A66916"
     wsmap="managed"
     >
    <desc>
      The IMouse interface represents the virtual machine's mouse. Used in
      <link to="IConsole::mouse"/>.

      Through this interface, the virtual machine's virtual mouse can be
      controlled.
    </desc>

    <attribute name="absoluteSupported" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS supports absolute mouse pointer positioning
        or not.
        <note>
          VirtualBox Guest Tools need to be installed to the guest OS
          in order to enable absolute mouse positioning support.
          You can use the <link to="IConsoleCallback::onMouseCapabilityChange"/>
          callback to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEventAbsolute"/></see>
      </desc>
    </attribute>

    <method name="putMouseEvent">
      <desc>
        Initiates a mouse event using relative pointer movements
        along x and y axis.
      </desc>

      <param name="dx" type="long" dir="in">
        <desc>
          Amout of pixels the mouse should move to the right.
          Negative values move the mouse to the left.
        </desc>
      </param>
      <param name="dy" type="long" dir="in">
        <desc>
          Amout of pixels the mouse should move downwards.
          Negative values move the mouse upwards.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwize wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of <tt>1</tt> means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

    <method name="putMouseEventAbsolute">
      <desc>
        Positions the mouse pointer using absolute x and y coordinates.
        These coordinates are expressed in pixels and
        start from <tt>[1,1]</tt> which corresponds to the top left
        corner of the virtual display.

        <note>
          This method will have effect only if absolute mouse
          positioning is supported by the guest OS.
        </note>

        <see><link to="#absoluteSupported"/></see>
      </desc>

      <param name="x" type="long" dir="in">
        <desc>
          X coordinate of the pointer in pixels, starting from <tt>1</tt>.
        </desc>
      </param>
      <param name="y" type="long" dir="in">
        <desc>
          Y coordinate of the pointer in pixels, starting from <tt>1</tt>.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amout of mouse wheel moves.
          Positive values describe clockwize wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of <tt>1</tt> means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

  </interface>

  <!--
  // IDisplay
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="FramebufferAccelerationOperation"
    uuid="f0e5ebbe-dc8e-4e2d-916e-53baa3844df8"
  >
    <desc>
      Framebuffer acceleration operation.
    </desc>

    <const name="SolidFillAcceleration"   value="1"/>
    <const name="ScreenCopyAcceleration"  value="2"/>
  </enum>

  <enum
    name="FramebufferPixelFormat"
    uuid="6b27d1fc-4f2c-4e9c-a166-01d06540305d"
  >
    <desc>
      Format of the video memory buffer. Constants represented by this enum can
      be used to test for particular values of <link
      to="IFramebuffer::pixelFormat"/>. See also <link
      to="IFramebuffer::requestResize()"/>.

      See also www.fourcc.org for more informantion about FOURCC pixel formats.
    </desc>

    <const name="Opaque"                  value="0xFFFFFFFF">
      <desc>
        Unknown buffer format. The user may not assume any particular
        format of the buffer.
      </desc>
    </const>
    <const name="FOURCC_RGB"              value="0x32424752">
      <desc>
        Basic RGB format. <link to="IFramebuffer::bitsPerPixel"/> determines
        the bit layout.
      </desc>
    </const>
  </enum>

  <interface
     name="IFramebuffer" extends="$unknown"
     uuid="af431304-5b09-40e2-94da-3c3cb03822c1"
     wsmap="suppress"
     >
    <attribute name="address" type="octet" mod="ptr" readonly="yes">
      <desc>Address of the start byte of the framebuffer.</desc>
    </attribute>

    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>Framebuffer width, in pixels.</desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>Framebuffer height, in pixels.</desc>
    </attribute>

    <attribute name="bitsPerPixel" type="unsigned long" readonly="yes">
      <desc>
        Color depth, in bits per pixel. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat::FOURCC_RGB">FOURCC_RGB</link>, valid values
        are: 8, 15, 16, 24 and 32.
      </desc>
    </attribute>

    <attribute name="bytesPerLine" type="unsigned long" readonly="yes">
      <desc>
        Scan line size, in bytes. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat::FOURCC_RGB">FOURCC_RGB</link>, the
        size of the scan line must be aligned to 32 bits.
      </desc>
    </attribute>

    <attribute name="pixelFormat" type="unsigned long" readonly="yes">
      <desc>
        Framebuffer pixel format. It's either one of the values defined by <link
        to="FramebufferPixelFormat"/> or a raw FOURCC code.
        <note>
          This attribute must never return <link
          to="PixelFormat::Opaque"/> -- the format of the buffer
          <link to="#address"/> points to must be always known.
        </note>
      </desc>
    </attribute>

    <attribute name="usesGuestVRAM" type="boolean" readonly="yes">
      <desc>
        Defines whether this framebuffer uses the virtual video card's memory
        buffer (guest VRAM) directly or not. See <link
        to="IFramebuffer::requestResize()"/> for more information.
      </desc>
    </attribute>

    <attribute name="heightReduction" type="unsigned long" readonly="yes">
      <desc>
        Hint from the framebuffer about how much of the standard
        screen height it wants to use for itself. This information is
        exposed to the guest through the VESA BIOS and VMMDev interface
        so that it can use it for determining its video mode table. It
        is not guaranteed that the guest respects the value.
      </desc>
    </attribute>

    <attribute name="overlay" type="IFramebufferOverlay" readonly="yes">
      <desc>
        An alpha-blended overlay which is superposed over the framebuffer.
        The initial purpose is to allow the display of icons providing
        information about the VM state, including disk activity, in front
        ends which do not have other means of doing that.  The overlay is
        designed to controlled exclusively by IDisplay.  It has no locking
        of its own, and any changes made to it are not guaranteed to be
        visible until the affected portion of IFramebuffer is updated.  The
        overlay can be created lazily the first time it is requested.  This
        attribute can also return NULL to signal that the overlay is not
        implemented.
      </desc>
    </attribute>

    <method name="lock">
      <desc>
        Locks the framebuffer.
        Gets called by the IDisplay object where this framebuffer is
        bound to.
      </desc>
    </method>

    <method name="unlock">
      <desc>
        Unlocks the framebuffer.
        Gets called by the IDisplay object where this framebuffer is
        bound to.
      </desc>
    </method>

    <method name="notifyUpdate">
      <desc>
        Informs about an update.
        Gets called by the display object where this buffer is
        registered.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="finished" type="boolean" dir="return"/>
    </method>

    <method name="requestResize">
      <desc>
        Requests a size and pixel format change.

        There are two modes of working with the video buffer of the virtual
        machine. The <i>indirect</i> mode implies that the IFramebuffer
        implementation allocates a memory buffer for the requested display mode
        and provides it to the virtual machine. In <i>direct</i> mode, the
        IFramebuffer implementation uses the memory buffer allocated and owned
        by the virtual machine. This buffer represents the video memory of the
        emulated video adapter (so called <i>guest VRAM</i>). The direct mode is
        usually faster because the implementation gets a raw pointer to the
        guest VRAM buffer which it can directly use for visualising the contents
        of the virtual display, as opposed to the indirect mode where the
        contents of guest VRAM are copied to the memory buffer provided by
        the implementation every time a display update occurs.

        It is important to note that the direct mode is really fast only when
        the implementation uses the given guest VRAM buffer directly, for
        example, by blitting it to the window representing the virtual machine's
        display, which saves at least one copy operation comparing to the
        indirect mode. However, using the guest VRAM buffer directly is not
        always possible: the format and the color depth of this buffer may be
        not supported by the target window, or it may be unknown (opaque) as in
        case of text or non-linear multi-plane VGA video modes. In this case,
        the indirect mode (that is always available) should be used as a
        fallback: when the guest VRAM contents are copied to the
        implementation-provided memory buffer, color and format conversion is
        done authomatically by the underlying code.

        The @a pixelFormat parameter defines whether the direct mode is
        available or not. If @a pixelFormat is <link
        to="PixelFormat::Opaque"/> then direct access to the guest
        VRAM buffer is not available -- the @a VRAM, @a bitsPerPixel and @a
        bytesPerLine parameters must be ignored and the implementation must use
        the indirect mode (where it provides its own buffer in one of the
        supported formats). In all other cases, @a pixelFormat together with @a
        bitsPerPixel and @a bytesPerLine define the format of the video memory
        buffer pointed to by the @a VRAM parameter and the implementation is
        free to choose which mode to use. To indicate that this framebuffer uses
        the direct mode, the implementation of the <link to="#usesGuestVRAM"/>
        attribute must return <tt>true</tt> and <link to="#address"/> must
        return exactly the same address that is passed in the @a VRAM parameter
        of this method; otherwise it is assumed that the indirect strategy is
        chosen.

        The @a width and @a height parameters represent the size of the
        requested display mode in both modes. In case of indirect mode, the
        provided memory buffer should be big enough to store data of the given
        display mode. In case of direct mode, it is guaranteed that the given @a
        VRAM buffer contains enough space to represent the display mode of the
        given size. Note that this framebuffer's <link to="#width"/> and <link
        to="#height"/> attributes must return exactly the same values as
        passed to this method after the resize is completed (see below).

        The @a finished output parameter determines if the implementation has
        finished resizing the framebuffer or not. If, for some reason, the
        resize cannot be finished immediately during this call, @a finished
        must be set to @c false, and the implementation must call
        <link to="IDisplay::resizeCompleted()"/> after it has returned from
        this method as soon as possible. If @a finished is @c false, the
        machine will not call any framebuffer methods until
        <link to="IDisplay::resizeCompleted()"/> is called.

        Note that if the direct mode is chosen, the <link to="#bitsPerPixel"/>,
        <link to="#bytesPerLine"/> and <link to="#pixelFormat"/> attributes of
        this framebuffer must return exactly the same values as specified in the
        parameters of this method, after the resize is completed. If the
        indirect mode is chosen, these attributes must return values describing
        the format of the implementation's own memory buffer <link
        to="#address"/> points to. Note also that the <link to="#bitsPerPixel"/>
        value must always correlate with <link to="#pixelFormat"/>. Note that
        the <link to="#pixelFormat"/> attribute must never return <link
        to="PixelFormat::Opaque"/> regardless of the selected mode.

        <note>
          This method is called by the IDisplay object under the
          <link to="#lock()"/> provided by this IFramebuffer
          implementation. If this method returns @c false in @a finished, then
          this lock is not released until
          <link to="IDisplay::resizeCompleted()"/> is called.
        </note>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Logical screen number. Must be used in the corresponding call to
          <link to="IDisplay::resizeCompleted()"/> if this call is made.
        </desc>
      </param>
      <param name="pixelFormat" type="unsigned long" dir="in">
        <desc>
          Pixel format of the memory buffer pointed to by @a VRAM.
          See also <link to="FramebufferPixelFormat"/>.
        </desc>
      </param>
      <param name="VRAM" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the virtual video card's VRAM (may be @c null).</desc>
      </param>
      <param name="bitsPerPixel" type="unsigned long" dir="in">
        <desc>Color depth, bits per pixel.</desc>
      </param>
      <param name="bytesPerLine" type="unsigned long" dir="in">
        <desc>Size of one scan line, in bytes.</desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>Width of the guest display, in pixels.</desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>Height of the guest display, in pixels.</desc>
      </param>
      <param name="finished" type="boolean" dir="return">
        <desc>
          Can the VM start using the new framebuffer immediately
          after this method returns or it should wait for
          <link to="IDisplay::resizeCompleted()"/>.
        </desc>
      </param>
    </method>

    <method name="operationSupported">
      <desc>
        Returns whether the given acceleration operation is supported
        by the IFramebuffer implementation. If not, the display object
        will not attempt to call the corresponding IFramebuffer entry
        point. Even if an operation is indicated to supported, the
        IFramebuffer implementation always has the option to return non
        supported from the corresponding acceleration method in which
        case the operation will be performed by the display engine. This
        allows for reduced IFramebuffer implementation complexity where
        only common cases are handled.
      </desc>
      <param name="operation" type="FramebufferAccelerationOperation" dir="in"/>
      <param name="supported" type="boolean" dir="return"/>
    </method>

    <method name="videoModeSupported">
      <desc>
        Returns whether the framebuffer implementation is willing to
        support a given video mode. In case it is not able to render
        the video mode (or for some reason not willing), it should
        return false. Usually this method is called when the guest
        asks the VMM device whether a given video mode is supported
        so the information returned is directly exposed to the guest.
        It is important that this method returns very quickly.
      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bpp" type="unsigned long" dir="in"/>
      <param name="supported" type="boolean" dir="return"/>
    </method>

    <method name="solidFill">
      <desc>
        Fills the specified rectangle on screen with a solid color.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="color" type="unsigned long" dir="in"/>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="copyScreenBits">
      <desc>
        Copies specified rectangle on the screen.
      </desc>
      <param name="xDst" type="unsigned long" dir="in"/>
      <param name="yDst" type="unsigned long" dir="in"/>
      <param name="xSrc" type="unsigned long" dir="in"/>
      <param name="ySrc" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="getVisibleRegion">
      <desc>
        Returns the visible region of this framebuffer.

        If the @a rectangles parameter is <tt>NULL</tt> then the value of the
        @a count parameter is ignored and the number of elements necessary to
        describe the current visible region is returned in @a countCopied.

        If @a rectangles is not <tt>NULL</tt> but @a count is less
        than the required number of elements to store region data, the method
        will report a failure. If @a count is equal or greater than the
        required number of elements, then the actual number of elements copied
        to the provided array will be returned in @a countCopied.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the <tt>RTRECT</tt> array to receive region data.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of <tt>RTRECT</tt> elements in the @a rectangles array.</desc>
      </param>
      <param name="countCopied" type="unsigned long" dir="return">
        <desc>Number of elements copied to the @a rectangles array.</desc>
      </param>
    </method>

    <method name="setVisibleRegion">
      <desc>
        Suggests a new visible region to this framebuffer.  This region
        represents the area of the VM display which is a union of regions of
        all top-level windows of the guest operating system running inside the
        VM (if the Guest Additions for this system support this
        functionality). This information may be used by the frontends to
        implement the seamless desktop integration feature.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          The IFramebuffer implementation must make a copy of the provided
          array of rectangles.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the <tt>RTRECT</tt> array.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of <tt>RTRECT</tt> elements in the @a rectangles array.</desc>
      </param>
    </method>

  </interface>

  <interface
     name="IFramebufferOverlay" extends="IFrameBuffer"
     uuid="0bcc1c7e-e415-47d2-bfdb-e4c705fb0f47"
     wsmap="suppress"
     >
    <desc>
      The IFramebufferOverlay interface represents an alpha blended overlay
      for displaying status icons above an IFramebuffer.  It is always created
      not visible, so that it must be explicitly shown.  It only covers a
      portion of the IFramebuffer, determined by its width, height and
      co-ordinates.  It is always in packed pixel little-endian 32bit ARGB (in
      that order) format, and may be written to directly.  Do re-read the
      width though, after setting it, as it may be adjusted (increased) to
      make it more suitable for the front end.
    </desc>
    <attribute name="x" type="unsigned long" readonly="yes">
      <desc>X position of the overlay, relative to the framebuffer.</desc>
    </attribute>

    <attribute name="y" type="unsigned long" readonly="yes">
      <desc>Y position of the overlay, relative to the framebuffer.</desc>
    </attribute>

    <attribute name="visible" type="boolean" readonly="no">
      <desc>
        Whether the overlay is currently visible.
      </desc>
    </attribute>

    <attribute name="alpha" type="unsigned long" readonly="no">
      <desc>
        The global alpha value for the overlay.  This may or may not be
        supported by a given front end.
      </desc>
    </attribute>

    <method name="move">
      <desc>
        Changes the overlay's position relative to the IFramebuffer.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
    </method>

  </interface>

  <interface
     name="IDisplay" extends="$unknown"
     uuid="09789f63-4525-48e5-a5e4-1080453b0eab"
     wsmap="suppress"
     >
    <desc>
      The IDisplay interface represents the virtual machine's display.

      The object implementing this interface is contained in each
      <link to="IConsole::display"/> attribute and represents the visual
      output of the virtual machine.

      The virtual display supports pluggable output targets represented by the
      IFramebuffer interface. Examples of the output target are a window on
      the host computer or an RDP sessoin's display on a remote computer.
    </desc>
    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>Current display width.</desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>Current display height.</desc>
    </attribute>

    <attribute name="bitsPerPixel" type="unsigned long" readonly="yes">
      <desc>
        Current guest display color depth. Note that this may differ
        from <link to="IFramebuffer::bitsPerPixel"/>.
      </desc>
    </attribute>

    <method name="setupInternalFramebuffer">
      <desc>
        Prepares an internally managed framebuffer.
      </desc>
      <param name="depth" type="unsigned long" dir="in"/>
    </method>

    <method name="lockFramebuffer">
      <desc>
        Requests access to the internal framebuffer.
      </desc>
      <param name="address" type="octet" mod="ptr" dir="return"/>
    </method>

    <method name="unlockFramebuffer">
      <desc>
        Releases access to the internal framebuffer.
      </desc>
    </method>

    <method name="registerExternalFramebuffer">
      <desc>
        Registers an external framebuffer.
      </desc>
      <param name="framebuffer" type="IFramebuffer" dir="in"/>
    </method>

    <method name="setFramebuffer">
      <desc>
        Sets the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="in"/>
    </method>

    <method name="getFramebuffer">
      <desc>
        Queries the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="out"/>
      <param name="xOrigin" type="long" dir="out"/>
      <param name="yOrigin" type="long" dir="out"/>
    </method>

    <method name="setVideoModeHint">
      <desc>
        Asks VirtualBox to request the given video mode from
        the guest. This is just a hint and it cannot be guaranteed
        that the requested resolution will be used. Guest Additions
        are required for the request to be seen by guests. The caller
        should issue the request and wait for a resolution change and
        after a timeout retry.

        Specifying <tt>0</tt> for either @a width, @a height or @a bitsPerPixel
        parameters means that the corresponding values should be taken from the
        current video mode (i.e. left unchanged).

        If the guest OS supports multi-monitor configuration then the @a display
        parameter specifies the number of the guest display to send the hint to:
        <tt>0</tt> is the primary display, <tt>1</tt> is the first secondary and
        so on. If the multi-monitor configuration is not supported, @a display
        must be <tt>0</tt>.

      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bitsPerPixel" type="unsigned long" dir="in"/>
      <param name="display" type="unsigned long" dir="in"/>
    </method>

    <method name="setSeamlessMode">
      <desc>
        Enables or disables seamless guest display rendering (seamless desktop
        integration) mode.
        <note>
          Calling this method has no effect if <link
          to="IGuest::supportsSeamless"/> returns <tt>false</tt>.
        </note>
      </desc>
      <param name="enabled" type="boolean" dir="in"/>
    </method>

    <method name="takeScreenShot">
      <desc>
        Takes a screen shot of the requested size and copies it to the
        32-bpp buffer allocated by the caller.
      </desc>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="drawToScreen">
      <desc>
        Draws a 32-bpp image of the specified size from the given buffer
        to the given point on the VM display.
      </desc>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="invalidateAndUpdate">
      <desc>
        Does a full invalidation of the VM display and instructs the VM
        to update it.
      </desc>
    </method>

    <method name="resizeCompleted">
      <desc>
        Signals that a framebuffer has completed the resize operation.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
    </method>

    <method name="updateCompleted">
      <desc>
        Signals that a framebuffer has completed the update operation.
      </desc>
    </method>

  </interface>

  <!--
  // INetworkAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="NetworkAttachmentType"
    uuid="8730d899-d036-4925-bc63-e58f3486f4bf"
  >
    <desc>
      Network attachment type.
    </desc>

    <const name="Null"                  value="0">
      <desc><tt>null</tt> value. Also means "not attached".</desc>
    </const>
    <const name="NAT"                   value="1"/>
    <const name="HostInterface"         value="2"/>
    <const name="Internal"              value="3"/>
  </enum>

  <enum
    name="NetworkAdapterType"
    uuid="156b17b9-5d61-4d54-be90-62e37dda848d"
  >
    <desc>
      Network adapter type.
    </desc>

    <const name="Null"                  value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="Am79C970A"             value="1"/>
    <const name="Am79C973"              value="2"/>
    <const name="I82540EM"              value="3"/>
    <const name="I82543GC"              value="4"/>
  </enum>

  <interface
     name="INetworkAdapter" extends="$unknown"
     uuid="a876d9b1-68d9-43b1-9c68-ddea0a473663"
     wsmap="managed"
     >
    <attribute name="adapterType" type="NetworkAdapterType">
      <desc>
        Type of the virtual network adapter. Depending on this value,
        VirtualBox will provide a different virtual network hardware
        to the guest.
      </desc>
    </attribute>

    <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this adapter is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getNetworkAdapter"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the network adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain this network adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>

    <attribute name="MACAddress" type="wstring">
      <desc>
        Ethernet MAC address of the adapter, 12 hexadecimal characters. When setting
        it to NULL, VirtualBox will generate a unique MAC address.
      </desc>
    </attribute>

    <attribute name="attachmentType" type="NetworkAttachmentType" readonly="yes"/>

    <attribute name="hostInterface" type="wstring">
      <desc>
        Name of the Host Network Interface that is currently in use. NULL will be returned
        if no device has been allocated. On Linux, setting this refers to a permanent TAP
        device. However, a file descriptor has precedence over the interface name on Linux.
        Note that when VBox allocates a TAP device, this property will not be set, i.e. the
        interface name would have to be determined using the file descriptor and /proc/self/fd.
      </desc>
    </attribute>

<if target="xpidl">
    <attribute name="TAPFileDescriptor" type="long">
      <desc>
        File descriptor of the TAP device. It can either be setup by the caller
        which has to supply an existing valid file handle allocated in the parent
        process of the VM process or allocated by VirtualBox. The value is -1 if it
        has not been defined. This property is non persistent, i.e. it will not be
        stored in the VM's configuration data and thus has to be set at each startup.
      </desc>
    </attribute>
    <attribute name="TAPSetupApplication" type="wstring">
      <desc>
        Application to start to configure the TAP device.
        It is being passed two parameters, 1) the file handle (as ascii),
        2) the TAP device name if it is available.
      </desc>
    </attribute>
    <attribute name="TAPTerminateApplication" type="wstring">
      <desc>
        Application to start before closing a TAP device.
        It is being passed two parameters, 1) the file handle (as ascii),
        2) the TAP device name if it is available.
      </desc>
    </attribute>
</if>

    <attribute name="internalNetwork" type="wstring">
      <desc>
        Name of the internal network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="NATNetwork" type="wstring">
      <desc>
        Name of the NAT network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="cableConnected" type="boolean">
      <desc>
        Flag whether the adapter reports the cable as connected or not.
        It can be used to report offline situations to a VM.
      </desc>
    </attribute>

    <attribute name="lineSpeed" type="unsigned long">
      <desc>
        Line speed reported by custom drivers, in units of 1 kbps.
      </desc>
    </attribute>

    <attribute name="traceEnabled" type="boolean">
      <desc>
        Flag whether network traffic from/to the network card should be traced.
        Can only be toggled when the VM is turned off.
      </desc>
    </attribute>

    <attribute name="traceFile" type="wstring">
      <desc>
        Filename where a network trace will be stored. If not set, VBox-pid.pcap
        will be used.
      </desc>
    </attribute>

    <method name="attachToNAT">
      <desc>
        Attach the network adapter to the Network Address Translation (NAT) interface.
      </desc>
    </method>

    <method name="attachToHostInterface">
      <desc>
        Attach the network adapter to a host interface. On Linux, the TAP
        setup application will be executed if configured and unless a device
        name and/or file descriptor has been set, a new TAP interface will be
        created.
      </desc>
    </method>

    <method name="attachToInternalNetwork">
      <desc>
        Attach the network adapter to an internal network.
      </desc>
    </method>

    <method name="detach">
      <desc>
        Detach the network adapter
      </desc>
    </method>
  </interface>


  <!--
  // ISerialPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="PortMode"
    uuid="b266f43c-2e93-46b3-812b-c20e600e867b"
  >
    <desc>
      The PortMode enumeration represents possible communicaton modes for
      the virtual serial port device.
    </desc>

    <const name="Disconnected"        value="0">
      <desc>Virtual device is not attached to any real host device.</desc>
    </const>
    <const name="HostPipe"            value="1">
      <desc>Virtual device is attached to a host pipe.</desc>
    </const>
    <const name="HostDevice"          value="2">
      <desc>Virtual device is attached to a host device.</desc>
    </const>
  </enum>

  <interface
     name="ISerialPort" extends="$unknown"
     uuid="937f6970-5103-4745-b78e-d28dcf1479a8"
     wsmap="managed"
     >

    <desc>
      The ISerialPort interface represents the virtual serial port device.

      The virtual serial port device acts like an ordinary serial port
      inside the virtual machine. This device communicates to the real
      serial port hardware in one of two modes: host pipe or host device.

      In host pipe mode, the #path attribute specifies the path to the pipe on
      the host computer that represents a serial port. The #server attribute
      determines if this pipe is created by the virtual machine process at
      machine startup or it must already exist before starting machine
      execution.

      In host device mode, the #path attribute specifies the name of the
      serial port device on the host computer.

      There is also a third communication mode: the disconnected mode. In this
      mode, the guest OS running inside the virtual machine will be able to
      detect the serial port, but all port write operations will be discarded
      and all port read operations will return no data.

      <see>IMachine::getSerialPort</see>
    </desc>

     <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this serial port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getSerialPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the serial port is enabled. If disabled,
        the serial port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the serial port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the serial port.</desc>
    </attribute>

    <attribute name="hostMode" type="PortMode">
      <desc>How is this port connected to the host.</desc>
    </attribute>

    <attribute name="server" type="boolean">
      <desc>
        Flag whether this serial port acts as a server (creates a new pipe on
        the host) or as a client (uses the existing pipe). This attribute is
        used only when #hostMode is PortMode::HostPipePort.
      </desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Path to the serial port's pipe on the host when #hostMode is
        PortMode::HostPipePort, or the host serial device name when #hostMode
        is PortMode::HostDevicePort. In either of the above cases, setting a
        @c null or an empty string as the attribute's value will result into
        an error. Otherwise, the value of this property is ignored.
      </desc>
    </attribute>

  </interface>

  <!--
  // IParallelPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IParallelPort" extends="$unknown"
     uuid="0c925f06-dd10-4b77-8de8-294d738c3214"
     wsmap="managed"
     >

    <desc>
      The IParallelPort interface represents the virtual parallel port device.

      The virtual parallel port device acts like an ordinary parallel port
      inside the virtual machine. This device communicates to the real
      parallel port hardware using the name of the parallel device on the host
      computer specified in the #path attribute.

      Each virtual parallel port device is assigned a base I/O address and an
      IRQ number that will be reported to the guest operating system and used
      to operate the given parallel port from within the virtual machine.

      <see>IMachine::getParallelPort</see>
    </desc>

     <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this parallel port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getParallelPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the parallel port is enabled. If disabled,
        the parallel port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the parallel port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the parallel port.</desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Host parallel device name. If this parallel port is enabled, setting a
        @c null or an empty string as this attribute's value will result into
        an error.
      </desc>
    </attribute>

  </interface>


  <!--
  // IMachineDebugger
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IMachineDebugger" extends="$unknown"
     uuid="b3a02721-556a-4481-9d47-052a3f8cff90"
     wsmap="suppress"
     >
    <method name="resetStats">
      <desc>
        Reset VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="dumpStats">
      <desc>
        Dumps VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="getStats">
      <desc>
        Get the VM statistics in a XMLish format.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
      <param name="withDescriptions" type="boolean" dir="in">
        <desc>Whether to include the descriptions.</desc>
      </param>
      <param name="stats" type="wstring" dir="out">
        <desc>The XML document containing the statistics.</desc>
      </param>
    </method>

    <attribute name="singlestep" type="boolean">
      <desc>Switch for enabling singlestepping.</desc>
    </attribute>

    <attribute name="recompileUser" type="boolean">
      <desc>Switch for forcing code recompilation for user mode code.</desc>
    </attribute>

    <attribute name="recompileSupervisor" type="boolean">
      <desc>Switch for forcing code recompilation for supervisor mode code.</desc>
    </attribute>

    <attribute name="PATMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the PATM component.</desc>
    </attribute>

    <attribute name="CSAMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the CSAM component.</desc>
    </attribute>

    <attribute name="logEnabled" type="boolean">
      <desc>Switch for enabling and disabling logging.</desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of CPU hardware
        virtualization extensions
      </desc>
    </attribute>

    <attribute name="PAEEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the Physical
        Address Extension CPU feature.
      </desc>
    </attribute>

    <attribute name="virtualTimeRate" type="unsigned long">
      <desc>
        The rate at which the virtual time runs expressed as a percentage.
        The accepted range is 2% to 20000%.
      </desc>
    </attribute>

    <!-- @todo method for setting log flags, groups and destination! -->

    <attribute name="VM" type="unsigned long long" readonly="yes">
      <desc>
        Gets the VM handle. This is only for internal use while
        we carve the details of this interface.
      </desc>
    </attribute>

  </interface>

  <!--
  // IUSBController
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IUSBController" extends="$unknown"
     uuid="f4c2d3dc-f109-4da7-93b1-ec28973ac89f"
     wsmap="managed"
     >
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the USB controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any USB controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="enabledEhci" type="boolean">
      <desc>
        Flag whether the USB EHCI controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain a USB EHCI controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="USBStandard" type="unsigned short" readonly="yes">
      <desc>
        USB standard version which the controller implements.
        This is a BCD which means that the major version is in the
        high byte and minor version is in the low byte.
      </desc>
    </attribute>

    <attribute name="deviceFilters" type="IUSBDeviceFilterCollection" readonly="yes">
      <desc>
        List of USB device filters associated with the machine.

        If the machine is currently running, these filters are activated
        every time a new (supported) USB device is attached to the host
        computer that was not ignored by global filters
        (<link to="IHost::USBDeviceFilters"/>).

        These filters are also activated when the machine is powered up.
        They are run against a list of all currently available USB
        devices (in states
        <link to="USBDeviceState::Available">Available</link>,
        <link to="USBDeviceState::Busy">Busy</link>,
        <link to="USBDeviceState::Held">Held</link>) that were not previously
        ignored by global filters.

        If at least one filter matches the USB device in question, this
        device is automatically captured (attached to) the virtual USB
        controller of this machine.

        <see>IUSBDeviceFilter, ::IUSBController</see>
      </desc>
    </attribute>

    <method name="createDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to <tt>null</tt> (any match),
        <i>active</i> is <tt>false</tt> (the filter is not active).

        The created filter can then be added to the list of filters using
        <link to="#insertDeviceFilter()"/>.

        <see>#deviceFilters</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from <tt>0</tt>. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added to the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to inster a
          filter that is already in the collection, will return an
          error.
        </note>

        <see>#deviceFilters</see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from <tt>0</tt>. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <see>#deviceFilters</see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Removed USB device filter.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IUSBDeviceEnumerator" type="IUSBDevice"
     uuid="aefe00f7-eb8a-454b-9ea4-fd5ad93c0e99"
     />

  <collection
     name="IUSBDeviceCollection" type="IUSBDevice"
     enumerator="IUSBDeviceEnumerator"
     uuid="e31f3248-90dd-4ca2-95f0-6b36042d96a2"
     readonly="yes"
     >
    <method name="findById">
      <desc>
        Searches this collection for a USB device with the given UUID.
        <note>
          The method returns an error if the given UUID does not
          correspond to any USB device in the collection.
        </note>
        <see>IUSBDevice::id</see>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findByAddress">
      <desc>
        Searches this collection for a USB device with the given
        host address.
        <note>
          The method returns an error if the given address does not
          correspond to any USB device in the collection.
        </note>
        <see>IUSBDevice::address</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

  </collection>

  <interface
     name="IUSBDevice" extends="$unknown"
     uuid="850af07b-9ee8-48c2-b6b0-f6d0acbf63c3"
     wsmap="managed"
     >
    <desc>
      The IUSBDevice interface represents a virtual USB device attached to the
      virtual machine.

      A collection of objects implementing this interface is stored in the
      <link to="IConsole::USBDevices"/> attribute which lists all USB devices
      attached to a running virtual machine's USB controller.
    </desc>

    <attribute name="id" type="uuid" readonly="yes">
      <desc>
        Unique USB device ID. This ID is built from #vendorId,
        #productId, #revision and #serialNumber.
      </desc>
    </attribute>

    <attribute name="vendorId" type="unsigned short" readonly="yes">
      <desc>Vendor ID.</desc>
    </attribute>

    <attribute name="productId" type="unsigned short" readonly="yes">
      <desc>Product ID.</desc>
    </attribute>

    <attribute name="revision" type="unsigned short" readonly="yes">
      <desc>
        Product revision number. This is a packed BCD represented as
        unsigned short. The high byte is the integer part and the low
        byte is the decimal.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring" readonly="yes">
      <desc>Manufacturer string.</desc>
    </attribute>

    <attribute name="product" type="wstring" readonly="yes">
      <desc>Product string.</desc>
    </attribute>

    <attribute name="serialNumber" type="wstring" readonly="yes">
      <desc>Serial number string.</desc>
    </attribute>

    <attribute name="address" type="wstring" readonly="yes">
      <desc>Host specific address of the device.</desc>
    </attribute>

    <attribute name="port" type="unsigned short" readonly="yes">
      <desc>
        Host USB port number the device is physically
        coonected to.
      </desc>
    </attribute>

    <attribute name="version" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the device - 1 or 2.
      </desc>
    </attribute>

    <attribute name="portVersion" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the host USB port the device is
        physically coonected to - 1 or 2. For devices not connected to
        anything this will have the same value as the version attribute.
      </desc>
    </attribute>

    <attribute name="remote" type="boolean" readonly="yes">
      <desc>
        Whether the device is physically connected to a remote VRDP
        client or to a local host machine.
      </desc>
    </attribute>

  </interface>


  <!--
  // IUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="IUSBDeviceFilterEnumerator" type="IUSBDeviceFilter"
     uuid="d5109c61-93e7-4726-926b-0dee1020da56"
     />

  <collection
     name="IUSBDeviceFilterCollection" type="IUSBDeviceFilter"
     enumerator="IUSBDeviceFilterEnumerator"
     uuid="4fa3fc99-ceb1-4bf5-a9cb-e962d825c1ef"
     readonly="yes"
     />

  <interface
     name="IUSBDeviceFilter" extends="$unknown"
     uuid="d6831fb4-1a94-4c2c-96ef-8d0d6192066d"
     wsmap="managed"
     >
    <desc>
      The IUSBDeviceFilter interface represents an USB device filter used
      to perform actions on a group of USB devices.

      This type of filters is used by running virtual machines to
      automatically capture selected USB devices once they are physically
      attached to the host computer.

      A USB device is matched to the given device filter if and only if all
      attributes of the device match the corresponding attributes of the
      filter (that is, attributes are joined together using the logical AND
      operation). On the other hand, all together, filters in the list of
      filters carry the semantics of the logical OR operation. So if it is
      desirable to create a match like "this vendor id OR this product id",
      one needs to create two filters and specify "any match" (see below)
      for unused attributes.

      All filter attributes used for matching are strings. Each string
      is an expression representing a set of values of the corresponding
      device attribute, that will match the given filter. Currently, the
      following filtering expressions are supported:

      <ul>
        <li><i>Interval filters</i>. Used to specify valid intervals for
          integer device attributes (Vendor ID, Product ID and Revision).
          The format of the string is:

          <tt>int:((m)|([m]-[n]))(,(m)|([m]-[n]))*</tt>

          where <tt>m</tt> and <tt>n</tt> are integer numbers, either in octal
          (starting from <tt>0</tt>), hexadecimal (starting from <tt>0x</tt>)
          or decimal (otherwise) form, so that <tt>m &lt; n</tt>. If <tt>m</tt>
          is ommitted before a dash (<tt>-</tt>), the minimum possible integer
          is assumed; if <tt>n</tt> is ommitted after a dash, the maximum
          possible integer is assummed.
        </li>
        <li><i>Boolean filters</i>. Used to specify acceptable values for
          boolean device attributes. The format of the string is:

          <tt>true|false|yes|no|0|1</tt>

        </li>
        <li><i>Exact match</i>. Used to specify a single value for the given
          device attribute. Any string that does't start with <tt>int:</tt>
          represents the exact match. String device attributes are compared to
          this string including case of symbols. Integer attributes are first
          converted to a string (see individual filter attributes) and then
          compared ignoring case.

        </li>
        <li><i>Any match</i>. Any value of the corresponding device attribute
          will match the given filter. An empty or <tt>null</tt> string is
          used to construct this type of filtering expressions.

        </li>
      </ul>

      <note>
        On the Windows host platform, interval filters are not currently
        available. Also all string filter attributes
        (<link to="#manufacturer"/>, <link to="#product"/>,
        <link to="#serialNumber"/>) are ignored, so they behave as
        <i>any match</i> no matter what string expression is specified.
      </note>

      <see>IUSBController::deviceFilters, IHostUSBDeviceFilter</see>
    </desc>

    <attribute name="name" type="wstring">
      <desc>
        Visible name for this filter.
        This name is used to visually distungish one filter from another,
        so it can neither be <tt>null</tt> nor an empty string.
      </desc>
    </attribute>

    <attribute name="active" type="boolean">
      <desc>Whether this filter active or has been temporarily disabled.</desc>
    </attribute>

    <attribute name="vendorId" type="wstring">
      <desc>
        <link to="IUSBDevice::vendorId">Vendor ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="productId" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="revision" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product revision number</link>
        filter. The string representation for the <i>exact matching</i>
        has the form <tt>IIFF</tt>, where <tt>I</tt> is the decimal digit
        of the integer part of the revision, and <tt>F</tt> is the
        decimal digit of its fractional part (including leading and
        trailing zeroes).
        Note that for interval filters, it's best to use the hexadecimal
        form, because the revision is stored as a 16 bit packed BCD value;
        so the expression <tt>int:0x0100-0x0199</tt> will match any
        revision from <tt>1.0</tt> to <tt>1.99</tt>.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring">
      <desc>
        <link to="IUSBDevice::manufacturer">Manufacturer</link> filter.
      </desc>
    </attribute>

    <attribute name="product" type="wstring">
      <desc>
        <link to="IUSBDevice::product">Product</link> filter.
      </desc>
    </attribute>

    <attribute name="serialNumber" type="wstring">
      <desc>
        <link to="IUSBDevice::serialNumber">Serial number</link> filter.
      </desc>
    </attribute>

    <attribute name="port" type="wstring">
      <desc>
        <link to="IUSBDevice::port">Host USB port</link> filter.
      </desc>
    </attribute>

    <attribute name="remote" type="wstring">
      <desc>
        <link to="IUSBDevice::remote">Remote state</link> filter.
        <note>
          This filter makes sense only for machine USB filters,
          i.e. it is ignored by IHostUSBDeviceFilter objects.
        </note>
      </desc>
    </attribute>

    <attribute name="maskedInterfaces" type="unsigned long">
      <desc>
       This is an advanced option for hiding one or more USB interfaces
       from the guest. The value is a bitmask where the bits that are set
       means the corresponding USB interface should be hidden, masked off
       if you like.
       This feature only works on Linux hosts.
      </desc>
    </attribute>

  </interface>


  <!--
  // IHostUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
     name="USBDeviceState"
     uuid="b99a2e65-67fb-4882-82fd-f3e5e8193ab4"
     >
    <desc>
      USB device state. This enumeration represents all possible states
      of the USB device physically attached to the host computer regarding
      its state on the host computer and availability to guest computers
      (all currently running virtual machines).

      Once a supported USB device is attached to the host, global USB
      filters (<link to="IHost::USBDeviceFilters"/>) are activated. They can
      either ignore the device, or put ot to #Held state, or do nothing. Unless
      the device is ignored by global filters, filters of all currently running
      guests (<link to="IUSBController::deviceFilters"/>) are activated that can
      put it to #Captured state.

      If the device was ignored by global filters, or didn't match
      any filters at all (including guest ones), it is handled by the host
      in a normal way. In this case, the device state is determined by
      the host and can be one of #Unavailable, #Busy or #Available, depending on
      the current device usage.

      Besides auto-capturing based on filters, the device can be manually
      captured by guests (<link to="IConsole::attachUSBDevice()"/>) if its
      state is #Busy, #Available or #Held.

      <note>
        Due to differences in USB stack implementations in Linux and Win32,
        states #Busy and #Available are applicable only to the Linux version of
        the product. This also means that (<link
        to="IConsole::attachUSBDevice()"/>) can only succeed on Win32 if
        the device state is #USBDeviceHeld.
      </note>

      <see>IHostUSBDevice, IHostUSBDeviceFilter</see>
    </desc>

    <const name="NotSupported"          value="0">
      <desc>
        Not supported by the VirtualBox server, not available to guests.
      </desc>
    </const>
    <const name="Unavailable"           value="1">
      <desc>
        Being used by the host computer exclusively,
        not available to guests.
      </desc>
    </const>
    <const name="Busy"                  value="2">
      <desc>
        Being used by the host computer, potentially available to guests.
      </desc>
    </const>
    <const name="Available"             value="3">
      <desc>
        Not used by the host computer, available to guests.
        The host computer can also start using the device at any time.
      </desc>
    </const>
    <const name="Held"                  value="4">
      <desc>
        Held by the VirtualBox server (ignored by the host computer),
        available to guests.
      </desc>
    </const>
    <const name="Captured"              value="5">
      <desc>
        Captured by one of the guest computers, not available
        to anybody else.
      </desc>
    </const>
  </enum>

  <enumerator
     name="IHostUSBDeviceEnumerator" type="IHostUSBDevice"
     uuid="a0c55136-939f-4d20-b9d3-4d406f08bfa5"
     />

  <collection
     name="IHostUSBDeviceCollection" type="IHostUSBDevice"
     enumerator="IHostUSBDeviceEnumerator"
     uuid="f9d3f96d-b027-4994-b589-70bb9ee0d364"
     readonly="yes"
     >
    <method name="findById">
      <desc>
        Searches this collection for a USB device with the given UUID.
        <note>
          The method returns an error if the given UUID does not
          correspond to any USB device in the collection.
        </note>
        <see>IHostUSBDevice::id</see>
      </desc>
      <param name="id" type="uuid" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findByAddress">
      <desc>
        Searches this collection for a USB device with the given
        host address.
        <note>
          The method returns an error if the given address does not
          correspond to any USB device in the collection.
        </note>
        <see>IHostUSBDevice::address</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

  </collection>

  <interface
     name="IHostUSBDevice" extends="IUSBDevice"
     uuid="173b4b44-d268-4334-a00d-b6521c9a740a"
     wsmap="managed"
     >
    <desc>
      The IHostUSBDevice interface represents a physical USB device attached
      to the host computer.

      Besides properties inherited from IUSBDevice, this interface adds the
      <link to="#state"/> property that holds the courrent state of the USB
      device.

      <see>IHost::USBDevices, IHost::USBDeviceFilters</see>
    </desc>

    <attribute name="state" type="USBDeviceState" readonly="yes">
      <desc>
        Current state of the device.
      </desc>
    </attribute>

    <!-- @todo add class, subclass, bandwidth, configs, interfaces endpoints and such later. -->

  </interface>


  <!--
  // IHostUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="USBDeviceFilterAction"
    uuid="cbc30a49-2f4e-43b5-9da6-121320475933"
  >
    <desc>
      Actions for host USB device filters.
      <see>IHostUSBDeviceFilter, USBDeviceState</see>
    </desc>

    <const name="Null"          value="0">
      <desc><tt>null</tt> value. Never used by the API.</desc>
    </const>
    <const name="Ignore"        value="1">
      <desc>Ignore the matched USB device.</desc>
    </const>
    <const name="Hold"          value="2">
      <desc>Hold the matched USB device.</desc>
    </const>
  </enum>

  <enumerator
     name="IHostUSBDeviceFilterEnumerator" type="IHostUSBDeviceFilter"
     uuid="ff735211-903e-4642-9c37-189eb44579fe"
     />

  <collection
     name="IHostUSBDeviceFilterCollection" type="IHostUSBDeviceFilter"
     enumerator="IHostUSBDeviceFilterEnumerator"
     uuid="1a80458b-87f1-4a74-995d-04e2330119e0"
     readonly="yes"
     />

  <interface
     name="IHostUSBDeviceFilter" extends="IUSBDeviceFilter"
     uuid="4cc70246-d74a-400f-8222-3900489c0374"
     wsmap="managed"
     >
    <desc>
      The IHostUSBDeviceFilter interface represents a global filter for a
      physical USB device used by the host computer. Used indirectly in
      <link to="IHost::USBDeviceFilters"/>.

      Using filters of this type, the host computer determines the initial
      state of the USB device after it is physically attached to the
      host's USB controller.

      <note>
        The <link to="#remote"/> attribute is ignored by this type of
        filters, because it makes sense only for
        <link to="IUSBController::deviceFilters">machine USB filters</link>.
      </note>

      <see>IHost::USBDeviceFilters</see>
    </desc>

    <attribute name="action" type="USBDeviceFilterAction">
      <desc>
        Action performed by the host when an attached USB device
        matches this filter.
      </desc>
    </attribute>

  </interface>

  <!--
  // IAudioAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="AudioDriverType"
    uuid="4bcc3d73-c2fe-40db-b72f-0c2ca9d68496"
  >
    <desc>
      Host audio driver type.
    </desc>

    <const name="Null"          value="0">
      <desc><tt>null</tt> value. Also means "dummy audio driver".</desc>
    </const>
    <const name="WinMM"         value="1"/>
    <const name="OSS"           value="2"/>
    <const name="ALSA"          value="3"/>
    <const name="DirectSound"   value="4"/>
    <const name="CoreAudio"     value="5"/>
    <const name="MMPM"          value="6"/>
    <const name="Pulse"         value="7"/>
    <const name="SolAudio"      value="8"/>
  </enum>

  <enum
    name="AudioControllerType"
    uuid="7afd395c-42c3-444e-8788-3ce80292f36c"
  >
    <desc>
      Virtual audio controller type.
    </desc>

    <const name="AC97" value="0"/>
    <const name="SB16" value="1"/>
  </enum>

  <interface
     name="IAudioAdapter" extends="$unknown"
     uuid="921873db-5f3f-4b69-91f9-7be9e535a2cb"
     wsmap="managed"
     >
    <desc>
        The IAudioAdapter interface represents the virtual audio adapter of
        the virtual machine. Used in <link to="IMachine::audioAdapter"/>.
    </desc>
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the audio adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any audio adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>
    <attribute name="audioController" type="AudioControllerType">
      <desc>
        The audio hardware we emulate.
      </desc>
    </attribute>
    <attribute name="audioDriver" type="AudioDriverType">
      <desc>
        Audio driver the adapter is connected to. This setting
        can only be changed when the VM is not running.
      </desc>
    </attribute>
  </interface>

  <!--
  // IVRDPServer
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="VRDPAuthType"
    uuid="3d91887a-b67f-4b33-85bf-2da7ab1ea83a"
  >
    <desc>
      VRDP authentication type.
    </desc>

    <const name="Null"            value="0">
      <desc><tt>null</tt> value. Also means "no authentication".</desc>
    </const>
    <const name="External"        value="1"/>
    <const name="Guest"           value="2"/>
  </enum>

  <interface
     name="IVRDPServer" extends="$unknown"
     uuid="ed9d31ae-867f-45fc-b727-6740084d1883"
     wsmap="managed"
     >
    <attribute name="enabled" type="boolean">
      <desc>VRDP server status.</desc>
    </attribute>

    <attribute name="port" type="unsigned long">
      <desc>
        VRDP server port number.
        <note>
          Setting the value of this property to <tt>0</tt> will reset the port
          number to the default value which is
          currently <tt>3389</tt>. Reading this property will always return a
          real port number, even after it has been set to <tt>0</tt> (in which
          case the default port is returned).
        </note>
      </desc>
    </attribute>

    <attribute name="netAddress" type="wstring">
      <desc>VRDP server address.</desc>
    </attribute>

    <attribute name="authType" type="VRDPAuthType">
      <desc>VRDP authentication method.</desc>
    </attribute>

    <attribute name="authTimeout" type="unsigned long">
      <desc>Timeout for guest authentication. Milliseconds.</desc>
    </attribute>

    <attribute name="allowMultiConnection" type="boolean">
      <desc>
        Flag whether multiple simultaneous connections to the VM are permitted.
        Note that this will be replaced by a more powerful mechanism in the future.
      </desc>
    </attribute>

  </interface>


  <!--
  // ISharedFolder
  /////////////////////////////////////////////////////////////////////////
  -->

  <enumerator
     name="ISharedFolderEnumerator" type="ISharedFolder"
     uuid="1d420fd8-e7c1-4511-abf4-a504dc6d0cbf"
     />

  <collection
     name="ISharedFolderCollection" type="ISharedFolder"
     enumerator="ISharedFolderEnumerator"
     uuid="9c7e2282-bb16-4fa7-9138-f383c5e02353"
     readonly="yes">

    <method name="findByName">
      <desc>
        Searches this collection for a shared folder with the given logical
        name.
        <note>
          The method returns an error if the given name does not correspond to
          any shared folder in the collection.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to search for</desc>
      </param>
      <param name="sharedFolder" type="ISharedFolder" dir="return">
        <desc>Found shared folder object</desc>
      </param>
    </method>

  </collection>

  <interface
     name="ISharedFolder" extends="$unknown"
     uuid="8b0c5f70-9139-4f97-a421-64d5e9c335d5"
     wsmap="struct"
     >
    <desc>
      The ISharedFolder interface represents a folder in the host computer's
      file system accessible from the guest OS running inside a virtual
      machine using an associated logical name.

      There are three types of shared folders:
      <ul>
        <li><i>Global</i> (<link to="IVirtualBox::sharedFolders"/>), shared
        folders available to all virtual machines.</li>
        <li><i>Permanent</i> (<link to="IMachine::sharedFolders"/>),
        VM-specific shared folders available to the given virtual machine at
        startup.</li>
        <li><i>Transient</i> (<link to="IConsole::sharedFolders"/>),
        VM-specific shared folders created in the session context (for
        example, when the virtual machine is running) and automatically
        discarded when the session is closed (the VM is powered off).</li>
      </ul>

      Logical names of shared folders must be unique within the given scope
      (global, permanent or transient). However, they do not need to be unique
      across scopes. In this case, the definitioin of the shared folder in a
      more specific scope takes precedence over definitions in all other
      scopes. The order of precedence is (more specific to more general):
      <ol>
        <li>Transient definitions</li>
        <li>Permanent definitions</li>
        <li>Global definitions</li>
      </ol>

      For example, if MyMachine has a shared folder named
      <tt>C_DRIVE</tt> (that points to <tt>C:\\</tt>), then cretaing a
      transient shared folder named <tt>C_DRIVE</tt> (that points
      to <tt>C:\\\\WINDOWS</tt>) will change the definition
      of <tt>C_DRIVE</tt> in the guest OS so
      that <tt>\\\\VBOXSVR\\C_DRIVE</tt> will give access
      to <tt>C:\\WINDOWS</tt> instead of <tt>C:\\</tt> on the host
      PC. Removing the transient shared folder <tt>C_DRIVE</tt> will restore
      the prevoious (permanent) definition of <tt>C_DRIVE</tt> that points
      to <tt>C:\\</tt> if it still exists.

      Note that permanent and transient shared folders of different machines
      are in different name spaces, so they don't overlap and don't need to
      have unique logical names.

      <note>With the COM API, this is an interface like all the others. With the webservice,
        this is mapped to a structure, so querying the attribute will not return an object,
        but a complete structure.</note>

      <note>
        Global shared folders are not implemented in the current vesion of the
        product.
      </note>
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>Logical name of the shared folder.</desc>
    </attribute>

    <attribute name="hostPath" type="wstring" readonly="yes">
      <desc>Full path to the shared folder in the host file system.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is currently
        accessible or not.
        For example, the folder can be unaccessible if it is placed
        on the network share that is not available by the time
        this property is read.
      </desc>
    </attribute>

    <attribute name="writable" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is writable or
        not.
      </desc>
    </attribute>

  </interface>

  <!--
  // ISession
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IInternalSessionControl" extends="$unknown"
     uuid="37838967-2430-4bb1-8acc-1b5b2c383d44"
     internal="yes"
     wsmap="suppress"
     >
    <method name="getPID">
      <desc>PID of the process that has created this Session object.
      </desc>
      <param name="pid" type="unsigned long" dir="return"/>
    </method>

    <method name="getRemoteConsole">
      <desc>Returns the console object suitable for remote control.</desc>
      <param name="console" type="IConsole" dir="return"/>
    </method>

    <method name="assignMachine">
      <desc>
        Assigns the machine object associated with this direct-type
        session or informs the session that it will be a remote one
        (if machine = NULL).
      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="assignRemoteMachine">
      <desc>
        Assigns the machine and the (remote) console object associated with
        this remote-type session.
      </desc>
      <param name="machine" type="IMachine" dir="in"/>
      <param name="console" type="IConsole" dir="in"/>
    </method>

    <method name="updateMachineState">
      <desc>
        Updates the machine state in the VM process.
        Must be called only in certain cases
        (see the method implementation).
      </desc>
      <param name="aMachineState" type="MachineState" dir="in"/>
    </method>

    <method name="uninitialize">
      <desc>
        Uninitializes (closes) this session. Used by VirtualBox to close
        the corresponding remote session when the direct session dies
        or gets closed.
      </desc>
    </method>

    <method name="onDVDDriveChange">
      <desc>
        Triggered when settings of the DVD drive object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onFloppyDriveChange">
      <desc>
        Triggered when settings of the floppy drive object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Triggered when settions of a network adapter of the
        associated virtual machine have changed.
      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in"/>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Triggered when settions of a serial port of the
        associated virtual machine have changed.
      </desc>
      <param name="serialPort" type="ISerialPort" dir="in"/>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Triggered when settings of a parallel port of the
        associated virtual machine have changed.
      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in"/>
    </method>

    <method name="onVRDPServerChange">
      <desc>
        Triggered when settings of the VRDP server object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Triggered when settings of the USB controller object of the
        associated virtual machine have changed.
      </desc>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Triggered when a permanent (global or machine) shared folder has been
        created or removed.
        <note>
          We don't pass shared folder parameters in this notification because
          the order in which parallel notifications are delivered is not defined,
          therefore it could happen that these parameters were outdated by the
          time of processing this notification.
        </note>
      </desc>
      <param name="global" type="boolean" dir="in"/>
    </method>

    <method name="onUSBDeviceAttach">
      <desc>
        Triggered when a request to capture a USB device (as a result
        of matched USB filters or direct call to
        <link to="IConsole::attachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
        describes a failure.
      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
      <param name="maskedInterfaces" type="unsigned long" dir="in"/>
    </method>

    <method name="onUSBDeviceDetach">
      <desc>
        Triggered when a request to release the USB device (as a result
        of machine termination or direct call to
        <link to="IConsole::detachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
      </desc>
      <param name="id" type="uuid" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
    </method>

    <method name="onShowWindow">
      <desc>
        Called by <link to="IMachine::canShowConsoleWindow()"/> and by
        <link to="IMachine::showConsoleWindow()"/> in order to notify
        console callbacks
        <link to="IConsoleCallback::onCanShowWindow()"/>
        and <link to="IConsoleCallback::onShowWindow()"/>.
      </desc>
      <param name="check" type="boolean" dir="in"/>
      <param name="canShow" type="boolean" dir="out"/>
      <param name="winId" type="unsigned long long" dir="out"/>
    </method>

  </interface>

  <interface
     name="ISession" extends="$dispatched"
     uuid="12F4DCDB-12B2-4ec1-B7CD-DDD9F6C5BF4D"
     wsmap="managed"
     >
    <desc>
      The ISession interface represents a serialization primitive for virtual
      machines.

      Within VirtualBox, every time one wishes to manipulate a virtual machine
      (for example, change its settings or start execution), an instance of
      the ISession interface is required. One first creates a local session
      object that implements the ISession interface and then passes the
      created object with the method call that opens the given session and
      thus initiates the machine manipulation. The session serves several
      purposes: it identifies to the inter-process VirtualBox code which
      process is currently working with the virtual machine, and it ensures
      that there are no incompatible requests from several processes for the
      same virtual machine.

      How sessions objects are used depends on whether you use the Main API
      via COM or via the web service:

      <ul>
      <li>When using the COM API directly, an object of the Session class from the
      VirtualBox type library needs to be created. In regular COM C++ client code,
      this can be done by calling <tt>createLocalObject()</tt>, a standard COM API.
      This object will  then act as a local session object in further calls to open
      a session.
      </li>

      <li>In the webservice, the session manager (IWebsessionManager) instead creates
      one session object automatically when <link to="IWebsessionManager::logon" />
      is called. A managed object reference to that session object can be retrieved by
      calling <link to="IWebsessionManager::getSessionObject" />. This session object
      reference can then be used to open sessions.
      </li>
      </ul>

      Sessions are mainly used in two variations:

      <ul>
      <li>
      To start a virtual machine in a separate process, one would call
      <link to="IVirtualBox::openRemoteSession"/>, which requires a session
      object as its first parameter. This session then identifies the caller
      and lets him control the started machine (for example, pause machine
      execution or power it down) as well as be notified about machine
      execution state changes.
      </li>

      <li>To alter machine settings, or to start machine execution within the
      current process, one needs to open a direct session for the machine first by
      calling <link to="IVirtualBox::openSession"/>. While a direct session
      is open within one process, no any other process may open another direct
      session for the same machine. This prevents the machine from being changed
      by other processes while it is running or while the machine is being configured.
      </li>
      </ul>

      One also can attach to an existing direct session alreay opened by
      another process (for example, in order to send a control request to the
      virtual machine such as the pause or the reset request). This is done by
      calling <link to="IVirtualBox::openExistingSession"/>.

      <note>
        Unless you are trying to write a new VirtualBox front-end that
        performs direct machine execution (like the VirtualBox or VBoxSDL
        frontends), don't call <link to="IConsole::powerUp"/> in a direct
        session opened by <link to="IVirtualBox::openSession"/> and use this
        session only to change virtual machine settings. If you simply want to
        start virtual machine execution using one of the existing frontends
        (for example the VirtualBox GUI frontend), use
        <link to="IVirtualBox::openRemoteSession"/>. In the latter case, on
        sucess, the machine will be powered up for you by the front-end so you
        don't need to call <link to="IConsole::powerUp"/> too.
      </note>
    </desc>

    <attribute name="state" type="SessionState" readonly="yes">
      <desc>Current state of this session.</desc>
    </attribute>

    <attribute name="type" type="SessionType" readonly="yes">
      <desc>
        Type of this session. The value of this attribute is valid only
        if the session is currently open (i.e. its #state is SessionType::SessionOpen),
        otherwise an error will be returned.
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>Machine object associated with this session.</desc>
    </attribute>

    <attribute name="console" type="IConsole" readonly="yes">
      <desc>Console object associated with this session.</desc>
    </attribute>

    <method name="close">
      <desc>
        Closes this session.
        <note>
          If a direct session for a machine opened with
          <link to="IVirtualBox::openSession()"/> is not explicitly
          closed when the application terminates, the state of the
          machine will be set to <link to="MachineState::Aborted"/>
          on the server. Generally, it is recommended to close all
          open sessions explicitly before terminating the application
          (no matter what is the reason of the termination).
        </note>
      </desc>
    </method>

  </interface>

  <!--
  // ISATAController
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="ISATAController" extends="$unknown"
    uuid="9a4b868b-1376-4533-8ef5-065b8e8cedff"
    wsmap="managed"
  >
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the SATA controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any SATA controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="portCount" type="unsigned long">
      <desc>
        The number of usable ports on the sata controller.
        It ranges from 1 to 30.
      </desc>
    </attribute>

    <method name="GetIDEEmulationPort">
      <desc>Gets the corresponding port number which is emulated as an IDE device.</desc>
      <param name="devicePosition" type="long" dir="in"/>
      <param name="portNumber" type="long" dir="return"/>
    </method>

    <method name="SetIDEEmulationPort">
      <desc>Sets the port number which is emulated as an IDE device.</desc>
      <param name="devicePosition" type="long" dir="in"/>
      <param name="portNumber" type="long" dir="in"/>
    </method>

  </interface>

<if target="wsdl">

  <!--
  // IManagedObjectRef
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IManagedObjectRef" extends="$unknown"
     uuid="9474d09d-2313-46de-b568-a42b8718e8ed"
     internal="yes"
     wsmap="managed"
     wscpp="hardcoded"
     >
    <desc>
      Webservice only: Managed object reference.

      Only within the webservice, a managed object reference (which is really
      an opaque number) allows a webservice client to address an object
      that lives in the address space of the webservice server.

      Behind each managed object reference, there is a COM object that lives
      in the webservice server's address space. The COM object is not freed
      until the managed object reference is released, either by an explicit
      call to  <link to="IManagedObjectRef::release" /> or by logging off from
      the webservice (<link to="IWebsessionManager::logoff" />), which releases
      all objects created during the webservice session.

      Whenever a method call of the VirtualBox API returns a COM object, the
      webservice representation of that method will instead return a
      managed object reference, which can then be used to invoke methods
      on that object.
    </desc>

    <method name="getInterfaceName">
      <desc>
        Returns the name of the interface that this managed object represents,
        for example, "IMachine", as a string.
      </desc>
      <param name="return" type="wstring" dir="return"/>
    </method>

    <method name="release">
      <desc>
        Releases this managed object reference and frees the resources that
        were allocated for it in the webservice server process. After calling
        this method, the identifier of the reference can no longer be used.
      </desc>
    </method>

  </interface>

  <!--
  // IWebsessionManager
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IWebsessionManager" extends="$unknown"
     uuid="dea1b4c7-2de3-418a-850d-7868617f7733"
     internal="yes"
     wsmap="global"
     wscpp="hardcoded"
     >
    <desc>
      Webservice only: Websession manager. This provides essential services
      to webservice clients.
    </desc>
    <method name="logon">
      <desc>
        Logs a new client onto the webservice and returns a managed object reference to
        the IVirtualBox instance, which the client can then use as a basis to further
        queries, since all calls to the VirtualBox API are based on the IVirtualBox
        interface, in one way or the other.
      </desc>
      <param name="username" type="wstring" dir="in"/>
      <param name="password" type="wstring" dir="in"/>
      <param name="return" type="wstring" dir="return"/>
    </method>

    <method name="getSessionObject">
      <desc>
        Returns a managed object reference to the internal ISession object that was created
        for this web service session when the client logged on.

        <see>ISession</see>
      </desc>
      <param name="refIVirtualBox" type="wstring" dir="in"/>
      <param name="return" type="wstring" dir="return"/>
    </method>

    <method name="logoff">
      <desc>
        Logs off the client who has previously logged on with <link to="IWebsessionManager::logoff" />
        and destroys all resources associated with the session (most importantly, all
        managed objects created in the server while the session was active).
      </desc>
      <param name="refIVirtualBox" type="wstring" dir="in"/>
    </method>

  </interface>

</if>

  <module name="VBoxSVC" context="LocalServer">
    <class name="VirtualBox" uuid="B1A7A4F2-47B9-4A1E-82B2-07CCD5323C3F"
           namespace="virtualbox.org">
      <interface name="IVirtualBox" default="yes"/>
    </class>
  </module>

  <module name="VBoxC" context="InprocServer" threadingModel="Free">
    <class name="Session" uuid="3C02F46D-C9D2-4f11-A384-53F0CF917214"
           namespace="virtualbox.org">
      <interface name="ISession" default="yes"/>
    </class>
  </module>

</library>

</idl>
