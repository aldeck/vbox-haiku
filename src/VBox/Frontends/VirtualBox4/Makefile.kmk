# $Id$
## @file
# Makefile for the VirtualBox Qt GUI.
#

#
# Copyright (C) 2006-2007 innotek GmbH
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#

# include qmake project file
include VBoxUI.pro

# Import QDesigner UI sources
VirtualBox_QT_UISRCS3 := $(FORMS)
# Import translation sources
VirtualBox_QT_TRANSLATIONS := $(TRANSLATIONS)

# reset things to avoid possible conflicts with kBuild
TEMPLATE :=
LANGUAGE :=
FORMS :=
TRANSLATIONS :=
IMAGES :=

VBOX_WITH_REGISTRATION := 1
VBOX_WITH_REGISTRATION_REQUEST := 1

DEPTH = ../../../..
include $(PATH_KBUILD)/header.kmk

# Disable the debugger for now, this is another story.
VBOX_WITH_DEBUGGER_GUI :=
DEFS := $(filter-out VBOX_WITH_DEBUGGER_GUI,$(DEFS))

#
# Handmade configuration of qt4 - very annoying, this needs to
# be cleaned up properly later some time (not important now).
#
ifndef VBOX_PATH_QT4
 if1of ($(USERNAME), bird)
  # gentoo (64-bit)
  VBOX_PATH_QT4          ?= /usr
  VBOX_PATH_QT4_BIN      ?= /usr/bin
  VBOX_PATH_QT4_INCLUDE  ?= /usr/include/qt4
  VBOX_PATH_QT4_LIB      ?= /usr/lib/qt4
  VBOX_PATH_QT4_LIB64    ?= /usr/lib/qt4
  VBOX_PATH_QT4_SHARE    ?= /usr/share/qt4
 endif
endif
VBOX_PATH_QT4          ?= /usr
VBOX_PATH_QT4_BIN      ?= $(VBOX_PATH_QT4)/bin
VBOX_PATH_QT4_INCLUDE  ?= $(VBOX_PATH_QT4)/include
VBOX_PATH_QT4_LIB      ?= $(VBOX_PATH_QT4)/lib
VBOX_PATH_QT4_LIB64    ?= $(VBOX_PATH_QT4)/lib64
VBOX_PATH_QT4_SHARE    ?= $(VBOX_PATH_QT4)

VBOX_MODULE_QT4     = QtCore QtGui QtNetwork Qt3Support
VBOX_DEFS_QT4       = QT_CORE_LIB QT_GUI_LIB QT_NETWORK_LIB QT_QT3SUPPORT_LIB

ifeq ($(BUILD_TARGET),darwin)
 VBOX_MODULE_QT4    += QtSql QtXml
 VBOX_DEFS_QT4       = QT_SQL_LIB QT_XML_LIB
 VBOX_INCS_QT4       = $(foreach mod, $(VBOX_MODULE_QT4), $(join $(join /Library/Frameworks/, $(mod)), .framework/Headers))
 VBOX_LIBS_QT4       =
else
 VBOX_INCS_QT4       = \
	$(VBOX_PATH_QT4_SHARE)/mkspecs/linux-g++ \
	$(addprefix $(VBOX_PATH_QT4_INCLUDE)/, $(VBOX_MODULE_QT4) Qt) \
	$(VBOX_PATH_QT4_INCLUDE)
 VBOX_LIBS_QT4       = $(VBOX_MODULE_QT4)
endif

# Warn about all what you know about porting qt3->qt4.
# Disable this if you like to see something on your screen.
#VBOX_DEFS_QT4 += QT3_SUPPORT_WARNINGS
# Some default defs
VBOX_DEFS_QT4 += QT3_SUPPORT QT_SHARED HAVE_CONFIG_H QT_NO_DEBUG

VBOX_UIC3      ?= $(VBOX_PATH_QT4_BIN)/uic3
VBOX_UIC4      ?= $(VBOX_PATH_QT4_BIN)/uic
VBOX_MOC4      ?= $(VBOX_PATH_QT4_BIN)/moc
VBOX_RCC4      ?= $(VBOX_PATH_QT4_BIN)/rcc
VBOX_LUPDATE4  ?= $(VBOX_PATH_QT4_BIN)/lupdate
VBOX_LRELEASE4 ?= $(VBOX_PATH_QT4_BIN)/lrelease

# Template copy from the qt3 stuff. Appended a "4" on the
# relevant places.

#
# Template for building Qt GUI executables.
#

TEMPLATE_VBOXQT4GUIEXE = VBox Qt4 GUI Executable
TEMPLATE_VBOXQT4GUIEXE_DEFS = IN_RING3 QT_NO_DEBUG QT_THREAD_SUPPORT $(ARCH_BITS_DEFS) $(VBOX_DEFS_QT4)
TEMPLATE_VBOXQT4GUIEXE_INCS = \
	$(VBOX_PATH_SDK)/include \
    $(VBOX_INCS_QT4)

ifeq ($(BUILD_TARGET),win)
 # drag in library configuration (we need QMAKE_PRL_DEFINES)
 ifneq ($(LIB_QT_PRL),)
  include $(LIB_QT_PRL)
 endif
 TEMPLATE_VBOXQT4GUIEXE_TOOL = $(VBOX_VCC_TOOL)
 TEMPLATE_VBOXQT4GUIEXE_DEFS += \
    _WIN32_WINNT=0x0500 UNICODE _UNICODE \
    QT_DLL _CRT_SECURE_NO_DEPRECATE \
    $(QMAKE_PRL_DEFINES)
 ## @todo VCC70 flags?
 ifdef VBOX_USE_VCC80
  TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS = \
	-nologo -Zm200 -W3 -MD -Zi -EHsc -Zc:wchar_t-
  TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS.debug = -RTCsu
 else
  TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS = \
	-nologo -Zm200 -W3 -MD -Zi -GX
  TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS.debug = -GZ
 endif
 TEMPLATE_VBOXQT4GUIEXE_INCS += \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_ATLMFC_INC)
 TEMPLATE_VBOXQT4GUIEXE_LDFLAGS = \
	/NOD /NOLOGO /INCREMENTAL:NO /MAPINFO:EXPORTS /DEBUG \
	/DELAYLOAD:oleaut32.dll
 TEMPLATE_VBOXQT4GUIEXE_SDKS = WINPSDK
 TEMPLATE_VBOXQT4GUIEXE_LIBS = \
	$(LIB_QT) \
	$(LIB_QTMAIN) \
	$(LIB_RUNTIME) \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcprt.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcrt.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/oldnames.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/delayimp.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_ATLMFC_LIB)/atls.lib
 TEMPLATE_VBOXQT4GUIEXE_POST_CMDS = $(VBOX_SIGN_IMAGE_CMDS)

else # the gcc guys:
 TEMPLATE_VBOXQT4GUIEXE_TOOL = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXQT4GUIEXE_DEFS.linux = _REENTRANT

 TEMPLATE_VBOXQT4GUIEXE_DEFS.solaris = _REENTRANT

 TEMPLATE_VBOXQT4GUIEXE_INCS += \
	$(LIB_SDL_INC)
 TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS = \
	-pipe -Wall -W -frtti -fno-exceptions -Wno-non-virtual-dtor \
	-Wno-long-long -fshort-wchar -fno-strict-aliasing \
	$(VBOX_GCC_fvisibility-hidden) $(VBOX_GCC_fvisibility-inlines-hidden)
 TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS.x86 = -m32
 TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS.amd64 = -m64
 TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS.linux = -pthread
 TEMPLATE_VBOXQT4GUIEXE_LDFLAGS.x86 = -m32
 TEMPLATE_VBOXQT4GUIEXE_LDFLAGS.amd64 = -m64
 TEMPLATE_VBOXQT4GUIEXE_LIBS = \
	$(VBOX_LIBS_QT4) \
	$(LIB_SDL) \
	$(LIB_RUNTIME) \
	$(LIB_REM) \
	$(LIB_VMM)

 ifeq ($(BUILD_TARGET_ARCH),amd64)
  TEMPLATE_VBOXQT4GUIEXE_LIBPATH = \
	$(VBOX_PATH_QT4_LIB64) $(VBOX_PATH_QT4_LIB)
 else
  TEMPLATE_VBOXQT4GUIEXE_LIBPATH = \
	$(VBOX_PATH_QT4_LIB)
 endif

 ifeq ($(BUILD_TARGET),linux)
  TEMPLATE_VBOXQT4GUIEXE_LDFLAGS += $(VBOX_LD_as_needed)
 else ifeq ($(BUILD_TARGET),darwin)
  TEMPLATE_VBOXQT4GUIEXE_LDFLAGS += $(foreach mod, $(VBOX_MODULE_QT4), -framework $(mod)) \
  	-framework Carbon -framework QuickTime -bind_at_load
  TEMPLATE_VBOXQT4GUIEXE_LIBS +=
  TEMPLATE_VBOXQT4GUIEXE_LIBPATH +=
 else ifeq ($(BUILD_TARGET),os2)
  # drag in library configuration (we need QMAKE_PRL_DEFINES)
  ifneq ($(LIB_QT_PRL),)
   include $(LIB_QT_PRL)
  endif
  TEMPLATE_VBOXQT4GUIEXE_DEFS += $(QMAKE_PRL_DEFINES)
  TEMPLATE_VBOXQT4GUIEXE_LIBS +=
  TEMPLATE_VBOXQT4GUIEXE_LIBPATH +=
 else
  TEMPLATE_VBOXQT4GUIEXE_INCS += \
	$(VBOX_XCURSOR_INCS)
  TEMPLATE_VBOXQT4GUIEXE_LIBS += \
    $(VBOX_XCURSOR_LIBS) \
	Xext \
	X11 \
	m \
	$(LIB_PTHREAD)
  TEMPLATE_VBOXQT4GUIEXE_LIBPATH += \
	$(VBOX_LIBPATH_X11)
  ifeq ($(BUILD_TARGET),freebsd)
   TEMPLATE_VBOXQT4GUIEXE_INCS += \
	/usr/include \
	/usr/X11R6/include \
	/usr/local/include
  endif
  ifeq ($(BUILD_TARGET),solaris)
   TEMPLATE_VBOXQT4GUIEXE_LDFLAGS += '-R$$(VBOX_ORIGIN):$$(VBOX_ORIGIN)/qtgcc/lib'
   TEMPLATE_VBOXQT4GUIEXE_LIBS += \
	rt socket nsl
  endif
 endif

endif

# Add COM/XPCOM stuff
TEMPLATE_VBOXQT4GUIEXE_LIBS            += \
	$(PATH_LIB)/VBoxCOM$(VBOX_SUFF_LIB)
ifdef VBOX_WITH_XPCOM
 ## @todo may be worth creating the VBOX_XPCOM SDK def
 TEMPLATE_VBOXQT4GUIEXE_DEFS            += VBOX_WITH_XPCOM
 TEMPLATE_VBOXQT4GUIEXE_INCS            += \
	$(VBOX_XPCOM_INCS)
 TEMPLATE_VBOXQT4GUIEXE_LIBS            += \
	$(LIB_XPCOM)
endif

#
# Template for building Qt GUI components.
#
TEMPLATE_VBOXQT4GUI = VBox Qt GUI Components
TEMPLATE_VBOXQT4GUI_EXTENDS = VBOXQTGUIEXE
TEMPLATE_VBOXQT4GUI_LIBS = $(filter-out $(QTMAIN),$(TEMPLATE_VBOXQT4GUIEXE_LIBS))
ifeq ($(BUILD_TARGET),darwin)
 TEMPLATE_VBOXQT4GUI_LDFLAGS = $(filter-out -framework Carbon -framework QuickTime -bind_at_load,$(TEMPLATE_VBOXQT4GUIEXE_LDFLAGS))
endif
ifeq ($(filter-out solaris.x86 %.amd64,$(BUILD_TARGET).$(BUILD_TARGET_ARCH)),)
 ifneq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXQT4GUI_DEFS     = PIC $(TEMPLATE_VBOXQT4GUIEXE_DEFS)
  TEMPLATE_VBOXQT4GUI_CFLAGS   = -fPIC $(TEMPLATE_VBOXQT4GUIEXE_CFLAGS)
  TEMPLATE_VBOXQT4GUI_CXXFLAGS = -fPIC $(TEMPLATE_VBOXQT4GUIEXE_CXXFLAGS)
  TEMPLATE_VBOXQT4GUI_LDFLAGS  = -fPIC $(TEMPLATE_VBOXQT4GUIEXE_LDFLAGS)
 endif
endif


#
# exclude inappropriate UI content
#
ifndef VBOX_WITH_REGISTRATION
VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxRegistrationDlg.ui,$(VirtualBox_QT_UISRCS3))
endif


#
# filter ported UI content
#
VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxAboutDlg.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxAboutDlg.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxCloseVMDlg.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxCloseVMDlg.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxNewVMWzd.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxNewVMWzd.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxNewHDWzd.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxNewHDWzd.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxVMFirstRunWzd.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxVMFirstRunWzd.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxRegistrationDlg.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxRegistrationDlg.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxSharedFoldersSettings.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxSharedFoldersSettings.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxSnapshotDetailsDlg.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxSnapshotDetailsDlg.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxVMInformationDlg.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxVMInformationDlg.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxTakeSnapshotDlg.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxTakeSnapshotDlg.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxSnapshotsWgt.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxSnapshotsWgt.ui

VirtualBox_QT_UISRCS3 := $(filter-out ui/VBoxVMLogViewer.ui,$(VirtualBox_QT_UISRCS3))
VirtualBox_QT_UISRCS4 += ui/VBoxVMLogViewer.ui


#
# The targets.
#
PROGRAMS = VirtualBox
ifeq ($(filter-out freebsd linux openbsd netbsd solaris,$(BUILD_TARGET)),) # X11
DLLS = VBoxKeyboard
OTHERS = $(PATH_BIN)/vboxkeyboard.tar.gz
endif
INSTALLS = VirtualBox.nls

ifeq ($(BUILD_TARGET),os2)
 DLLS += VBoxHlp
 ifneq ($(strip $(VBOX_DLL_QT)),)
  INSTALLS += qt.dll
  qt.dll_INST = $(INST_BIN)
  qt.dll_SOURCES += \
	$(VBOX_DLL_QT)=>$(not-dir $(VBOX_DLL_QT))
 endif
endif


#
# VBoxHlp - helper DLL for OS/2.
#
VBoxHlp_ASTOOL      = NASM
VBoxHlp_ASFLAGS     = -f obj
VBoxHlp_DEFS        = IN_RING3 IN_VBOXHLP
VBoxHlp_CXXFLAGS    = -fno-exceptions
VBoxHlp_LDFLAGS     = -nostdlib -los2
VBoxHlp_LDFLAGS    += -Zlinker option -Zlinker manyautodata
VBoxHlp_SOURCES     = \
	src/os2/VBoxHlp.asm \
	src/os2/VBoxHlp.cpp


#
# VBoxKeyboard - keyboard library for X11.
#
VBoxKeyboard_TEMPLATE = VBOXR3
VBoxKeyboard_SOURCES  = \
	src/linux/keyboard-new.c
VBoxKeyboard_TARSOURCES = \
	$(VBoxKeyboard_SOURCES) \
	src/linux/COPYING.LIB \
	src/linux/keyboard.h \
	src/linux/keyboard-layouts.h \
	src/linux/keyboard-list.h \
	src/linux/keyboard-tables.h \
	src/linux/Makefile
VBoxKeyboard_LIBS     = X11
VBoxKeyboard_LIBPATH  = $(VBOX_LIBPATH_X11)


#
# vboxkeyboard.tar.gz - the LGPLed keyboard library must always be
# redistributed with usable sources.
#
SOURCE_DIRECTORY = vboxkeyboard
DIRECTORY_PREFIX = src/linux/

$(PATH_TARGET)/$(SOURCE_DIRECTORY):
	$(MKDIR) -p $(@D)
	$(LN_SYMLINK) $(abspath $(PATH_CURRENT))/$(DIRECTORY_PREFIX) $@

$(PATH_BIN)/vboxkeyboard.tar.gz: $(VBoxKeyboard_TARSOURCES) $(PATH_TARGET)/$(SOURCE_DIRECTORY)
	$(call MSG_TOOL,tar/gzip,,$@)
	$(QUIET)cd $(PATH_TARGET) && tar -chf - $(addprefix $(SOURCE_DIRECTORY)/,$(subst $(DIRECTORY_PREFIX),,$(VBoxKeyboard_TARSOURCES))) | gzip - > $@


#
# VirtualBox - The GUI program.
#
VirtualBox_TEMPLATE = VBOXQT4GUIEXE
VirtualBox_NAME     = VirtualBox4
VirtualBox_SDKS.win = WINPSDK DXSDK
#ifeq ($(filter-out freebsd linux netbsd openbsd os2 solaris,$(BUILD_TARGET)),) - later
ifeq ($(filter-out freebsd linux netbsd openbsd os2,$(BUILD_TARGET)),) # X11 + os2
VirtualBox_SDKS += LIBSDL
endif

ifeq ($(BUILD_TARGET),darwin)
# For the launch trick we need different inode numbers.
VirtualBox_INST = $(INST_BIN)VirtualBox4 $(INST_BIN)VirtualBoxVM4

 # For testing iChat Theater stuff change
 # the sdk path
 ifdef VBOX_WITH_ICHAT_THEATER
  VBOX_PATH_MACOSX_SDK = /Developer/SDKs/MacOSX10.5.sdk
 endif

endif

ifndef VBOX_OSE
ifeq ($(filter-out freebsd linux netbsd openbsd solaris,$(BUILD_TARGET)),) # linux only, yea, right.
# Note: I'm doing this right here because the GUI will _not_ run
#       without that file which might be annoying for developers!
$(VBOX_LICENSE_BIN): $(VBOX_LICENSE_SRC)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(CP) $< $@

$(PATH_BIN)/VirtualBox: $(VBOX_LICENSE_BIN)
endif
endif

# Each nls/VirtualBox_xx_YY.ts file must have a qt_xx_YY.ts counterpart
VirtualBox_QT_TRANSLATIONS_QT := \
	$(patsubst nls/VirtualBox_%.ts,nls/qt_%.ts,\
		$(filter nls/VirtualBox_%.ts,$(VirtualBox_QT_TRANSLATIONS)))

# QDesigner UI sources are imported from VBoxUI.pro as VirtualBox_QT_UISRC

# Headers containing definitions of classes that use the Q_OBJECT macro
VirtualBox_QT_MOCHDRS = \
	include/QIWidgetValidator.h \
	include/QIHotKeyEdit.h \
	include/QIStatusBar.h \
	include/QIStateIndicator.h \
	include/QIMessageBox.h \
	include/QIRichLabel.h \
	include/QIAbstractWizard.h \
	include/QIAbstractDialog.h \
	include/VBoxGlobalSettings.h \
	include/VBoxUtils.h \
	include/VBoxGlobal.h \
	include/VBoxVMListBox.h \
	include/VBoxMediaComboBox.h \
	include/VBoxSelectorWnd.h \
	include/VBoxConsoleWnd.h \
	include/VBoxConsoleView.h \
	include/VBoxProblemReporter.h \
	include/VBoxDownloaderWgt.h \
	include/VBoxNetworkFramework.h \
	include/VBoxAboutDlg.h \
	include/VBoxCloseVMDlg.h \
	include/VBoxNewVMWzd.h \
	include/VBoxNewHDWzd.h \
	include/VBoxVMFirstRunWzd.h \
	include/VBoxRegistrationDlg.h \
	include/VBoxSharedFoldersSettings.h \
	include/VBoxSnapshotDetailsDlg.h \
	include/VBoxVMInformationDlg.h \
	include/VBoxTakeSnapshotDlg.h \
	include/VBoxSnapshotsWgt.h \
	include/VBoxVMLogViewer.h

# Sources containing local definitions of classes that use the Q_OBJECT macro
VirtualBox_QT_MOCSRCS = src/VBoxSelectorWnd.cpp
ifeq ($(filter-out freebsd linux netbsd openbsd solaris,$(BUILD_TARGET)),) # X11
VirtualBox_QT_MOCSRCS += src/VBoxGlobal.cpp
endif
ifdef VBOX_WITH_XPCOM
VirtualBox_QT_MOCSRCS += src/COMDefs.cpp
endif

# UI headers (ui.h) containing local definitions of classes that use the Q_OBJECT macro
VirtualBox_QT_MOCUIHDRS = \
	ui/VBoxVMSettingsDlg.ui.h \
	ui/VBoxVMLogViewer.ui.h


# All generated sources. Note: this list MUST be in sync with Qt source
# generation rules defined somewhere below!
VirtualBox_GENSRCS = \
	$(foreach moc,$(notdir $(basename $(VirtualBox_QT_MOCHDRS))), $(PATH_VirtualBox)/moc/moc_$(moc).cpp) \
	$(foreach ui,$(notdir $(basename $(VirtualBox_QT_UISRCS3))), $(PATH_VirtualBox)/ui/$(ui).cpp $(PATH_VirtualBox)/moc/moc_$(ui).cpp) \
	$(PATH_VirtualBox)/ui/vbox_image_collection.cpp

# All generated headers. Note: this list MUST be in sync with Qt source
# generation rules defined somewhere below!
VirtualBox_GENHDRS = \
	$(foreach mocui,$(notdir $(basename $(VirtualBox_QT_MOCUIHDRS))), $(PATH_VirtualBox)/moc/$(mocui).moc) \
	$(foreach moc,$(notdir $(basename $(VirtualBox_QT_MOCSRCS))), $(PATH_VirtualBox)/moc/$(moc).moc) \
	$(foreach ui,$(notdir $(basename $(VirtualBox_QT_UISRCS3))), $(PATH_VirtualBox)/ui/$(ui).h) \
	$(foreach ui,$(notdir $(basename $(VirtualBox_QT_UISRCS4))), $(PATH_VirtualBox)/ui/$(ui).gen.h)

# All existing .ui.h files for known .ui sources
VirtualBox_QT_UIHDRS = \
	$(wildcard $(addsuffix .h,$(VirtualBox_QT_UISRCS3)))

# All header files
VirtualBox_HEADERS = \
	$(wildcard include/*.h) \
	$(VirtualBox_GENHDRS) \
	$(VirtualBox_QT_UIHDRS)


VirtualBox_SOURCES = \
	$(VirtualBox_GENSRCS) \
	src/main.cpp \
	src/COMDefs.cpp \
	src/QIWidgetValidator.cpp \
	src/QIHotKeyEdit.cpp \
	src/QIStateIndicator.cpp \
	src/QIStatusBar.cpp \
	src/QIMessageBox.cpp \
	src/QIRichLabel.cpp \
	src/QIAbstractWizard.cpp \
	src/QIAbstractDialog.cpp \
	src/VBoxDefs.cpp \
	src/VBoxGlobalSettings.cpp \
	src/VBoxGlobal.cpp \
	src/VBoxMediaComboBox.cpp \
	src/VBoxProblemReporter.cpp \
	src/VBoxSelectorWnd.cpp \
	src/VBoxConsoleView.cpp \
	src/VBoxConsoleWnd.cpp \
	src/VBoxDownloaderWgt.cpp \
	src/VBoxVMListBox.cpp \
	src/VBoxFrameBuffer.cpp \
	src/HappyHttp.cpp \
	src/VBoxNetworkFramework.cpp \
	src/VBoxAboutDlg.cpp \
	src/VBoxCloseVMDlg.cpp \
	src/VBoxNewVMWzd.cpp \
	src/VBoxNewHDWzd.cpp \
	src/VBoxVMFirstRunWzd.cpp \
	src/VBoxRegistrationDlg.cpp \
	src/VBoxSharedFoldersSettings.cpp \
	src/VBoxSnapshotDetailsDlg.cpp \
	src/VBoxVMInformationDlg.cpp \
	src/VBoxTakeSnapshotDlg.cpp \
	src/VBoxSnapshotsWgt.cpp \
	src/VBoxVMLogViewer.cpp

ifeq ($(filter-out freebsd linux netbsd openbsd solaris,$(BUILD_TARGET)),) # X11
VirtualBox_SOURCES += \
	src/linux/XKeyboard-new.cpp
endif

VirtualBox_SOURCES.win += \
	src/win32/VirtualBox.rc

VirtualBox_SOURCES.win += \
	src/VBoxFBDDRAW.cpp

VirtualBox_SOURCES.darwin = \
	src/darwin/DarwinKeyboard.cpp \
	src/darwin/DarwinCursor.cpp \
	src/darwin/VBoxUtils-darwin.cpp \
	src/VBoxFBQuartz2D.cpp
#	src/darwin/VBoxAquaStyle.cpp \

ifdef VBOX_WITH_ICHAT_THEATER
 VirtualBox_SOURCES.darwin += \
	 src/darwin/VBoxIChatTheaterWrapper.m
endif

ifneq ($(BUILD_TARGET),win)
src/HappyHttp.cpp_CXXFLAGS += -fexceptions
src/VBoxDownloaderWgt.cpp_CXXFLAGS += -fexceptions
src/VBoxNetworkFramework.cpp_CXXFLAGS += -fexceptions
endif
src/HappyHttp.cpp_CXXFLAGS.linux += -O2

## @todo how to detect what tool is used?
## @todo GCC3 seems to lack -Wno-missing-base-class-initializer, so we use
#  more generic -Wno-extra
ifdef VBOX_WITH_XPCOM
src/COMDefs.cpp_CXXFLAGS  = $(VBOX_GCC_Wno-extra)
endif

VirtualBox_DEFS           = VBOX_GUI_SEPARATE_VM_PROCESS
VirtualBox_DEFS.debug     = VBOX_GUI_DEBUG VBOX_CHECK_STATE # QT_FATAL_ASSERT
VirtualBox_DEFS.darwin    = VBOX_GUI_USE_QUARTZ2D VBOX_GUI_USE_QIMAGE VBOX_WITHOUT_QHTTP
VirtualBox_DEFS.freebsd   = VBOX_GUI_USE_QIMAGE VBOX_GUI_USE_SDL
VirtualBox_DEFS.linux     = VBOX_GUI_USE_SDL
VirtualBox_DEFS.netbsd    = VBOX_GUI_USE_QIMAGE VBOX_GUI_USE_SDL
VirtualBox_DEFS.openbsd   = VBOX_GUI_USE_QIMAGE VBOX_GUI_USE_SDL
VirtualBox_DEFS.os2       = VBOX_GUI_USE_QIMAGE VBOX_GUI_USE_SDL QT_DLL
VirtualBox_DEFS.solaris   = VBOX_GUI_USE_QIMAGE #VBOX_GUI_USE_SDL
VirtualBox_DEFS.win       = VBOX_GUI_USE_QIMAGE UNICODE QT_DLL
VirtualBox_DEFS.win.amd64 = VBOX_WITHOUT_QHTTP
#ifndef VBOX_OSE
 VirtualBox_DEFS.darwin  += VBOX_WITH_HACKED_QT
#endif
ifdef VBOX_WITH_ICHAT_THEATER
 VirtualBox_DEFS.darwin += VBOX_WITH_ICHAT_THEATER
endif
ifneq ($(BUILD_TYPE),release)
 # non-release builds has some extra features.
 VirtualBox_DEFS.win     += VBOX_GUI_USE_DDRAW
 VirtualBox_DEFS.linux   += VBOX_GUI_USE_QIMAGE
endif
ifdef VBOX_WITH_REGISTRATION
 VirtualBox_DEFS         += VBOX_WITH_REGISTRATION
endif
ifdef VBOX_WITH_REGISTRATION_REQUEST
 VirtualBox_DEFS         += VBOX_WITH_REGISTRATION_REQUEST
endif
ifdef VBOX_WITH_ALSA
 VirtualBox_DEFS         += VBOX_WITH_ALSA
endif
ifdef VBOX_WITH_PULSE
 VirtualBox_DEFS         += VBOX_WITH_PULSE
endif
ifdef VBOX_OSE
 VirtualBox_DEFS         += VBOX_OSE
endif
ifdef VBOX_WITH_DEBUGGER_GUI
 VirtualBox_DEFS         += VBOX_WITH_DEBUGGER_GUI_MENU
endif

VirtualBox_INCS           = \
	./include \
	$(PATH_VirtualBox)/ui \
	$(PATH_VirtualBox)/moc \
	$(PATH_VirtualBox)/include \


ifeq ($(BUILD_TYPE),release)
 VirtualBox_LDFLAGS.win  += /SUBSYSTEM:windows
else
 VirtualBox_LDFLAGS.linux+= -rdynamic # for backtrace_symbols()
 ifeq ($(USERNAME),dmik)
  VirtualBox_LDFLAGS.win += /SUBSYSTEM:windows
 else
  VirtualBox_LDFLAGS.win += /SUBSYSTEM:console
 endif
endif
VirtualBox_LDFLAGS.os2    = -Zlinker /PM:PM -Zno-fork
VirtualBox_LDFLAGS.darwin = -framework IOKit -framework AppKit -framework ApplicationServices -framework Foundation -lz
ifdef VBOX_WITH_ICHAT_THEATER
 VirtualBox_LDFLAGS.darwin += -framework InstantMessage -framework QuartzCore
endif
VirtualBox_LIBS.win       = \
	$(PATH_SDK_WINPSDK_LIB)/Htmlhelp.Lib \
	$(PATH_SDK_DXSDK_LIB)/ddraw.lib \
	$(PATH_SDK_DXSDK_LIB)/dxguid.lib
VirtualBox_LIBS.os2      += $(PATH_DLL)/VBoxHlp$(VBOX_SUFF_DLL)
ifeq ($(filter-out freebsd linux netbsd openbsd solaris,$(BUILD_TARGET)),) # X11
VirtualBox_LIBS          += $(PATH_DLL)/VBoxKeyboard$(VBOX_SUFF_DLL)
endif


ifdef VBOX_WITH_DEBUGGER_GUI ## @todo make this dynamically loadable and ship with release builds too.
 ifeq ($(BUILD_TARGET),win)
  VirtualBox_LIBS        += $(PATH_LIB)/VBoxDbg$(VBOX_SUFF_LIB)
 else
  VirtualBox_LIBS        += $(PATH_DLL)/VBoxDbg$(VBOX_SUFF_DLL)
 endif
endif

WRAPPERSFILE        = $(PATH_VirtualBox)/include/COMWrappers.h
WRAPPERSINCFILE     = include/COMDefs.h
WRAPPERSTEMPLATE    = include/COMWrappers.xsl
XIDLFILE            = ../../Main/idl/VirtualBox.xidl


# generated files we need to clean manually
OTHER_CLEAN           = \
	$(VirtualBox_GENSRCS) \
	$(VirtualBox_GENHDRS) \
	$(WRAPPERSFILE) \
	$(PATH_BIN)/vboxkeyboard.tar.gz


#
# On Mac OS X (darwin) we need to install icon resources and compusory bundle contents.
#
INSTALLS.darwin += VirtualBox.app
VirtualBox.app_INST = $(INST_VIRTUALBOX)Contents/
VirtualBox.app_MODE = 644
VirtualBox.app_SOURCES = \
	src/darwin/PkgInfo \
	$(PATH_TARGET)/Info.plist \
	images/VirtualBox.icns=>Resources/virtualbox.icns

$(PATH_TARGET)/Info.plist: src/darwin/Info.plist $(VBOX_VERSION_MK) | $(call DIRDEP,$(PATH_TARGET))
	$(call MSG_GENERATE,VirtualBox.app,$<,$@)
	$(QUIET)$(RM) -f $@
	$(QUIET)$(SED) \
		-e 's/@VBOX_VERSION_STRING@/$(VBOX_VERSION_STRING)/g' \
		-e 's/@VBOX_VERSION_MAJOR@/$(VBOX_VERSION_MAJOR)/g' \
		-e 's/@VBOX_VERSION_MINOR@/$(VBOX_VERSION_MINOR)/g' \
		-e 's/@VBOX_VERSION_BUILD@/$(VBOX_VERSION_BUILD)/g' \
		$< > $@

INSTALLS.darwin += VirtualBoxVM.app
VirtualBoxVM.app_INST = $(VirtualBox.app_INST)Resources/VirtualBoxVM.app/Contents/
VirtualBoxVM.app_MODE = 644
VirtualBoxVM.app_SOURCES = \
	src/darwin/VM-PkgInfo=>PkgInfo \
	$(PATH_TARGET)/VM-Info.plist=>Info.plist \
	images/VirtualBox.icns=>Resources/virtualbox.icns
VirtualBoxVM.app_SYMLINKS = \
	MacOS=>../../../MacOS/

$(PATH_TARGET)/VM-Info.plist: src/darwin/VM-Info.plist $(VBOX_VERSION_MK) | $(call DIRDEP,$(PATH_TARGET))
	$(call MSG_GENERATE,VirtualBoxVM.app,$<,$@)
	$(QUIET)$(RM) -f $@
	$(QUIET)$(SED) \
		-e 's/@VBOX_VERSION_STRING@/$(VBOX_VERSION_STRING)/g' \
		-e 's/@VBOX_VERSION_MAJOR@/$(VBOX_VERSION_MAJOR)/g' \
		-e 's/@VBOX_VERSION_MINOR@/$(VBOX_VERSION_MINOR)/g' \
		-e 's/@VBOX_VERSION_BUILD@/$(VBOX_VERSION_BUILD)/g' \
		--output $@ $<

#
# Translation installation
#
VirtualBox.nls_INST = $(INST_BIN)nls/
VirtualBox.nls_SOURCES =  $(patsubst %.ts,$(PATH_VirtualBox)/nls/%.qm,$(notdir $(VirtualBox_QT_TRANSLATIONS)))
VirtualBox.nls_SOURCES += $(patsubst %.ts,$(PATH_VirtualBox)/nls/%.qm,$(notdir $(VirtualBox_QT_TRANSLATIONS_QT)))
VirtualBox.nls_MODE = 644


#
# Testcase for the darwin keyboard routines.
#
ifdef VBOX_WITH_TESTCASES
PROGRAMS.darwin += tstDarwinKeyboard
tstDarwinKeyboard_TEMPLATE = VBOXR3TSTEXE
tstDarwinKeyboard_INCS = include
tstDarwinKeyboard_SOURCES = \
	src/darwin/tstDarwinKeyboard.cpp \
	src/darwin/DarwinKeyboard.cpp
tstDarwinKeyboard_LDFLAGS = -framework IOKit -framework Carbon
tstDarwinKeyboard_LIBS = \
	$(LIB_RUNTIME)
endif



# Commit the magic.
# (note: before custom rules that make usage of generated variables!).
include $(PATH_KBUILD)/footer.kmk



#
# Qt source file generation rules
#

## @todo move QT source generation macros to kBuild

##  Generate a rule to create a MOC source file from a header containing
#   classes that use the Q_OBJECT macro.
#   @param  $mochdr     header file with Q_OBJECT
define def_qt_gen_src_moc

$(eval mocsrc := $(PATH_$(target))/moc/moc_$(notdir $(basename $(mochdr))).cpp)

$(target)_GENSRCS_REAL += $(mocsrc)

$(mocsrc): $(mochdr)
	$$(call MSG_TOOL,moc,$(target),$(mochdr),$$@)
	$$(QUIET)$$(MKDIR) -p $$(@D)
	$$(QUIET)$$(VBOX_MOC4) \
		$(addprefix -D,$($(target)_DEFS)) \
		$(addprefix -I,$($(target)_INCS)) \
		$(mochdr) -o $$@

endef

##  Generate a rule to create a MOC include file from a source containing
#   local classes that use the Q_OBJECT macro. This include is then included
#   by that source, so it must be generated before the source gets compiled.
#   @param  $mocsrc     source file with Q_OBJECT
define def_qt_gen_inc_moc

$(eval mocobj := $(PATH_$(target)_$(mocsrc))/$(notdir $(basename $(mocsrc)))$(VBOX_SUFF_OBJ))
$(eval mocinc := $(PATH_$(target))/moc/$(notdir $(basename $(mocsrc))).moc)

$(target)_GENHDRS_REAL += $(mocinc)

$(mocobj): $(mocinc)

.NOTPARALLEL: $(mocinc)
$(mocinc): $(mocsrc)
	$$(call MSG_TOOL,moc,$(target),$(mocsrc),$$@)
	$$(QUIET)$$(MKDIR) -p $$(@D)
	$$(QUIET)$$(VBOX_MOC4) \
		$(addprefix -D,$($(target)_DEFS)) \
		$(addprefix -I,$($(target)_INCS)) \
		-i $(mocsrc) -o $$@

endef

##  Generate a rule to create a MOC include file from a UI header (ui.h) containing
#   local classes that use the Q_OBJECT macro. This include is then included
#   by that header, so it must be generated before the UI source gets compiled.
#   @param  $mocuihdr     UI header file with Q_OBJECT
define def_qt_gen_inc_mocuihdr

$(eval uisrc    := $(PATH_$(target))/ui/$(notdir $(basename $(basename $(mocuihdr)))).cpp)
$(eval uiobj    := $(PATH_$(target)_$$(uisrc))/$(notdir $(basename $$(uisrc)))$(VBOX_SUFF_OBJ))
$(eval mocuiinc := $(PATH_$(target))/moc/$(notdir $(basename $(mocuihdr))).moc)

$(target)_GENHDRS_REAL += $(mocuiinc)

.NOTPARALLEL: $(mocuiinc)
$(uisrc): $(mocuiinc)
$(mocuiinc): $(mocuihdr)
	$$(call MSG_TOOL,moc,$(target),$(mocuihdr),$$@)
	$$(QUIET)$$(MKDIR) -p $$(@D)
	$$(QUIET)$$(VBOX_MOC4) \
		$(addprefix -D,$($(target)_DEFS)) \
		$(addprefix -I,$($(target)_INCS)) \
		-i $(mocuihdr) -o $$@

endef

##  Generate a rule to create a header and source files from an UI3
#   definition source (.ui).
#   @param  $uifile       UI definintion source file
define def_qt_gen_src_ui3

$(eval uisrc  := $(PATH_$(target))/ui/$(notdir $(basename $(uifile))).cpp)
$(eval uihdr  := $(PATH_$(target))/ui/$(notdir $(basename $(uifile))).h)
$(eval mocsrc := $(PATH_$(target))/moc/moc_$(notdir $(basename $(uifile))).cpp)

$(target)_GENSRCS_REAL += $(uisrc) $(mocsrc)
$(target)_GENHDRS_REAL += $(uihdr)

.NOTPARALLEL: $(uihdr)
$(uihdr): $(uifile) | $$(call DIRDEP,$(dir $(uihdr)))
	$$(call MSG_TOOL,uic,$(target),$(uifile),$$@)
	$$(QUIET)$$(VBOX_UIC3) $(uifile) -o $$@

$(uisrc): $(uihdr) $(uifile) $(wildcard $(uifile).h) | $$(call DIRDEP,$(dir $(uisrc)))
	$$(call MSG_TOOL,uic,$(target),$(uifile),$$@)
	$$(QUIET)$$(VBOX_UIC3) -impl $(uihdr) $(uifile) -o $$@

#$$(QUIET)$$(VBOX_UIC3) $(uifile) -i $(uihdr) -o $$@

$(mocsrc): $(uihdr) | $$(call DIRDEP,$(dir $(mocsrc)))
	$$(call MSG_TOOL,moc,$(target),$(uihdr),$$@)
	$$(QUIET)$$(VBOX_MOC4) \
		$(addprefix -D,$($(target)_DEFS)) \
		$(addprefix -I,$($(target)_INCS)) \
		$(uihdr) -o $$@

endef

##  Generate a rule to create a header file from an UI4
#   definition source (.ui).
#   @param  $uifile       UI definintion source file
define def_qt_gen_src_ui4

$(eval uihdr  := $(PATH_$(target))/ui/$(notdir $(basename $(uifile))).gen.h)

$(target)_GENHDRS_REAL += $(uihdr)

.NOTPARALLEL: $(uihdr)
$(uihdr): $(uifile) | $$(call DIRDEP,$(dir $(uihdr)))
	$$(call MSG_TOOL,uic,$(target),$(uifile),$$@)
	$$(QUIET)$$(VBOX_UIC4) $(uifile) -o $$@

# we assume that the generated header is at least included by
# the normal header with the same name
include/$(notdir $(basename $(uifile))).h: $(uihdr)

endef

##  Generate a rule to create a .qm file from a NLS translation
#   source (.ts).
#   @param  $tsfile       Translation source file
define def_qt_gen_nls

$(eval qmfile  := $(PATH_$(target))/nls/$(notdir $(basename $(tsfile))).qm)

OTHER_CLEAN += $(qmfile)

# Note that we use -nocompress in lrelease to avoid stripping comments and
# other information from .qm files. If we don't do that, we get .qm files two
# times smaller, but QTranslator::findMessage() will start searching for
# translations in all existing contexts in case if it cannot find it in the
# original context (which is of course not acceptable, no matter if it's a
# special Qt "feature" or just a bug).

$(qmfile): $(tsfile) | $$(call DIRDEP,$(dir $(qmfile)))
	$$(call MSG_TOOLS,lrelease,$(target),$(tsfile),$$@)
	$$(QUIET)$$(VBOX_LRELEASE4) -nocompress $(tsfile) -qm $$@

endef

## Generate rules for generating the Qt source for a target.
# @param   $target  Target name.
define def_qt_gen_src

# moc srcs from hdrs with Q_OBJECT
$(foreach mochdr,$($(target)_QT_MOCHDRS),$(eval $(def_qt_gen_src_moc)))
# moc includes from srcs with Q_OBJECT
$(foreach mocsrc,$($(target)_QT_MOCSRCS),$(eval $(def_qt_gen_inc_moc)))
# moc includes from UI headers with Q_OBJECT
$(foreach mocuihdr,$($(target)_QT_MOCUIHDRS),$(eval $(def_qt_gen_inc_mocuihdr)))
# UI3 sources
$(foreach uifile,$($(target)_QT_UISRCS3),$(eval $(def_qt_gen_src_ui3)))
# UI4 sources
$(foreach uifile,$($(target)_QT_UISRCS4),$(eval $(def_qt_gen_src_ui4)))
# NLS files
$(foreach tsfile,$($(target)_QT_TRANSLATIONS),$(eval $(def_qt_gen_nls)))
$(foreach tsfile,$($(target)_QT_TRANSLATIONS_QT),$(eval $(def_qt_gen_nls)))
# dirs
$$(call DIRDEP,$(PATH_$(target))/ui/) \
$$(call DIRDEP,$(PATH_$(target))/moc/) \
$$(call DIRDEP,$(PATH_$(target))/nls/):
	$$(call MSG_MKDIR,$$@)
	$$(QUIET)$$(MKDIR) -p $$@

endef

# Generate Qt source rules.
$(foreach target,VirtualBox,$(eval $(def_qt_gen_src)))


# Generate COM Wrappers
.NOTPARALLEL: $(WRAPPERSFILE) $(WRAPPERSINCFILE)

$(WRAPPERSINCFILE): $(WRAPPERSFILE)

$(WRAPPERSFILE): $(XIDLFILE) $(WRAPPERSTEMPLATE) | $(call DIRDEP,$(PATH_VirtualBox)/include/)
	$(call MSG_TOOL,xsltproc,VirtualBox,$<,$@)
	$(QUIET)$(VBOX_XSLTPROC) -o $@ $(WRAPPERSTEMPLATE) $<

$(call DIRDEP,$(PATH_VirtualBox)/include/):
	$(call MSG_MKDIR,$@)
	$(QUIET)$(MKDIR) -p $@

# this is actually necessary only for Win32 target with disabled dependencies
define def_wrapper_deps
$(src): $(WRAPPERSFILE) $(WRAPPERSINCFILE)
endef

$(foreach src,$(VirtualBox_SOURCES),$(eval $(def_wrapper_deps)))

# grep the images out of the resource file for dependency tracking
VirtualBox_QT_IMAGES = $(shell $(SED) '/images/!d;{s/^.*\(images\/.*\)<.*$$/\1/}' VirtualBox.qrc)

$(PATH_VirtualBox)/ui/vbox_image_collection.cpp: VirtualBox.qrc $(VirtualBox_QT_IMAGES)
	$(call MSG_TOOL,rcc,VirtualBox,$<,$@)
	$(QUIET)$(VBOX_RCC4) -o $@  $<

VirtualBox_GENSRCS += $(PATH_VirtualBox)/ui/vbox_image_collection.cpp

#
# Hand made dependencies go here.
# Basically, here are dependencies for generated UI source files that
# include generated headers in turn.
#

# Make all generated UI sources dependent on all generated headers (since they
# may include them).  This is safer than indifidual dependencies above but
# currently disabled, because will cause all UI sources to be rebuilt one a
# single one changes.
#$(patsubst %,$(PATH_VirtualBox)/ui/%.cpp,$(notdir $(basename $(VirtualBox_QT_UISRCS3)))) : $(VirtualBox_GENHDRS)


#
# Custom targets
#

# Update all known NLS translation (.ts) files in the nls/ subdirectory.
# NOTE: This target is intened to be run only by the GUI maintainer shortly
# before a new product release. VirtualBox_xx_YY.ts is a template for new
# languages and should never be actually translated or installed.
updatenls: $(VirtualBox_SOURCES) $(VirtualBox_HEADERS)
	$(call MSG_L1,lupdate all languages (nls/*.ts))
	$(QUIET)$(VBOX_LUPDATE4) $^ -ts $(VirtualBox_QT_TRANSLATIONS) nls/VirtualBox_xx_YY.ts


#
# Test targets
#

test:
	@echo ====================
	@echo $(VirtualBox_GENSRCS) | $(SED) -e "s/ /\n/g"
	@echo --------------------
	@echo $(VirtualBox_GENSRCS_REAL) | $(SED) -e "s/ /\n/g"
	@echo ====================
	@echo $(VirtualBox_GENHDRS) | $(SED) -e "s/ /\n/g"
	@echo --------------------
	@echo $(VirtualBox_GENHDRS_REAL) | $(SED) -e "s/ /\n/g"
	@echo ====================

test2:
	@echo $(OTHER_CLEAN) | $(SED) -e "s/ /\n/g"

test3:
	@echo $(VirtualBox_HEADERS) | $(SED) -e "s/ /\n/g"

testwrappers: $(WRAPPERSFILE)

