# $Id$
## @file
# The Recompiler Sub-Makefile.
#
#
# Copyright (C) 2006-2007 Sun Microsystems, Inc.
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
# Clara, CA 95054 USA or visit http://www.sun.com if you need
# additional information or have any questions.
#


SUB_DEPTH = ../..
include $(KBUILD_PATH)/subheader.kmk

# For 64-bit Windows we currently use gcc (due to MSVC unaware of such a novel
# thing as C99, a lot of GCC extensions deployed by QEMU and calling convention
# differences) to cross-compile code to Linux/ELF and dynamically generate invocation wrappers.
if1of (win.amd64, $(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
 REM_MOD              = VBoxREM2
 SYSMODS              += VBoxREM2
else
 REM_MOD              = VBoxREM
endif

TEMPLATE_DUMMY = dummy template (move to kBuild)
ifeq ($(KBUILD_TARGET), win)
 $(REM_MOD)_TOOL.win.x86    = MINGW32
 $(REM_MOD)_TOOL.win.amd64  = XGCCAMD64LINUX
 $(REM_MOD)_TEMPLATE        = DUMMY
 $(REM_MOD)_SDKS.win.x86    = W32API
 $(REM_MOD)_ASFLAGS         = -x assembler-with-cpp
 $(REM_MOD)_CFLAGS          = -Wall -g -fno-omit-frame-pointer -fno-strict-aliasing
 $(REM_MOD)_CFLAGS.debug    = -O0
 $(REM_MOD)_CFLAGS.release += -fno-gcse -O2
 $(REM_MOD)_CFLAGS.profile  = $($(REM_MOD)_CFLAGS.release)
 $(REM_MOD)_CFLAGS.kprofile = $($(REM_MOD)_CFLAGS.release)

 IMPORT_LIBS          += VBoxREMImp
 DLLS                 += VBoxREM

 VBoxREM_LIBS           =   \
	$(LIB_VMM)          \
	$(LIB_RUNTIME)

 USE_REM_IMP = 1
else

 # Just keep it here, if need to experiment with older compilers in the future
 TOOL_GCC3V3 = description
 TOOL_GCC3V3_EXTENDS = GCC3
 TOOL_GCC3V3_CC = $(firstword $(which gcc-4.2 gcc-4.1 gcc-3.4 gcc-3.4.6 gcc-3.3 gcc-3.3.6  gcc-3.2))
 TOOL_GCC3V3_COMPILE_C_DEPEND =
 TOOL_GCC3V3_COMPILE_C_DEPORD =
 TOOL_GCC3V3_COMPILE_C_OUTPUT =
 define TOOL_GCC3V3_COMPILE_C_CMDS
	$(QUIET)$(TOOL_GCC3V3_CC) -c\
		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
		-o $(obj)\
		$(abspath $(source))
 endef
 #target-i386/op_helper.c_TOOL = GCC3V3

 $(REM_MOD)_TEMPLATE  = VBOXR3NP

 IMPORT_LIBS          += VBoxREM
endif

# VBOX_WITH_64_BITS_GUESTS = 1

# For 32-bit targets when enabled 64-bit guests we build 2 REM DLLs: 
#  with 64-bit support (slow and buggy at the moment) VBOXREM64
#  only 32-bit support (faster, stable, but not suitable for 64-bit guests) VBOXREM
# During the runtime, we load appropriate library, depending on guest settings.
if1of (x86, $(KBUILD_TARGET_ARCH))
 ifdef VBOX_WITH_64_BITS_GUESTS
  USE_VBOXREM64 := 1
 endif
else
 USE_VBOXREM64 :=
endif

OTHER_CLEAN          +=

#
# Globals
#
VBOX_PATH_RECOMPILER_SRC := $(PATH_SUB_CURRENT)

# The VBoxREM.[dll|so|..] or VBoxREM2.rel.
#
$(REM_MOD)_DEFS             = IN_REM_R3 REM_INCLUDE_CPU_H
$(REM_MOD)_DEFS            += REM_PHYS_ADDR_IN_TLB
$(REM_MOD)_DEFS            += VBOX_WITH_NEW_RECOMPILER
#$(REM_MOD)_DEFS           += DEBUG_ALL_LOGGING DEBUG_DISAS DEBUG_PCALL DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.
$(REM_MOD)_DEFS.linux      = _GNU_SOURCE
ifdef VBOX_SOLARIS_10
 $(REM_MOD)_DEFS.solaris = HOST_SOLARIS=10
else
 $(REM_MOD)_DEFS.solaris = HOST_SOLARIS=11
endif

$(REM_MOD)_INCS             = 	  \
	Sun 			  \
	target-i386 		  \
	tcg                       \
	fpu 			  \
	$(PATH_$(REM_MOD)) 	  \
	$(PATH_ROOT)/src/VBox/VMM \
	.

$(REM_MOD)_SOURCES          = 	\
	VBoxRecompiler.c 	\
	cpu-exec.c 		\
	exec.c 			\
	translate-all.c 	\
	host-utils.c            \
	cutils.c                \
	tcg/tcg.c               \
        tcg/tcg-dyngen.c        \
	tcg/tcg-runtime.c       \
	fpu/softfloat-native.c  \
	target-i386/op_helper.c \
	target-i386/helper.c 	\
	target-i386/translate.c

ifeq ($(KBUILD_TARGET_ARCH),amd64)
 $(REM_MOD)_DEFS             += __x86_64__
 $(REM_MOD)_INCS             +=  tcg/x86_64
else
 $(REM_MOD)_DEFS             += __i386__
 $(REM_MOD)_INCS             +=  tcg/i386
endif

$(REM_MOD)_SOURCES.debug += \
	Sun/testmath.c
$(REM_MOD)_SOURCES.win.x86  = $(REM_MOD).def
ifneq ($(REM_MOD),VBoxREM2)
 $(REM_MOD)_POST_CMDS       = $(VBOX_SIGN_IMAGE_CMDS)
endif

ifeq ($(REM_MOD),VBoxREM2)
#
# The VBoxREM2 wrapper.
#
VBoxREM_TEMPLATE       = VBOXR3
VBoxREM_DEFS           = IN_REM_R3 $(if $(VBOX_WITH_VMI),VBOX_WITH_VMI,)
VBoxREM_DEFS          += VBOX_WITH_NEW_RECOMPILER
VBoxREM_SOURCES        =   \
	VBoxREMWrapper.cpp \
	VBoxREMWrapperA.asm

$(REM_MOD)_TEMPLATE        = VBOXNOCRTGAS
$(REM_MOD)_DEFS           += LOG_USE_C99 $(ARCH_BITS_DEFS)

# This doesn't fit in IPRT because it requires GAS and is LGPL.
$(REM_MOD)_SOURCES        += \
	Sun/e_powl-$(KBUILD_TARGET_ARCH).S

$(REM_MOD)_INCS           += \
        Sun/crt
$(REM_MOD)_LIBS           = \
	$(PATH_LIB)/RuntimeR3NoCRTGCC$(VBOX_SUFF_LIB)
$(REM_MOD)_SYSSUFF        = .rel

endif

$(REM_MOD)_CFLAGS.profile  = $($(REM_MOD)_CFLAGS.release)
$(REM_MOD)_CFLAGS.kprofile = $($(REM_MOD)_CFLAGS.release)

$(REM_MOD)_DEFS           += IN_RING3 $(ARCH_BITS_DEFS)
#$(REM_MOD)_DEFS          += DEBUG_DISAS DEBUG_PCALL DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.

$(REM_MOD)_LDFLAGS.darwin  = -install_name $(VBOX_DYLD_EXECUTABLE_PATH)/$(REM_MOD).dylib -undefined dynamic_lookup
$(REM_MOD)_LDFLAGS.l4      = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib -Wl,--no-undefined
$(REM_MOD)_LDFLAGS.linux   = $(VBOX_LD_as_needed)
$(REM_MOD)_LDFLAGS.os2     = -Zomf
$(REM_MOD)_LDFLAGS.debug   = -g
$(REM_MOD)_LDFLAGS.solaris = -mimpure-text

# Temporary hack, to allow running with oldish GCC
$(REM_MOD)_DEFS.win.x86   += GCC_WITH_BUGGY_REGPARM


ifdef USE_VBOXREM64
 # Currently we never mix USE_VBOXREM64 and VBoxREM2, so can always use VBoxREM
 # @todo: assert for that? use $(REM_MOD) instead? 
 # But loading logic got to be updated too.
 ifeq ($(KBUILD_TARGET), win)
  DLL                  += VBoxREM64
 else
  IMPORT_LIBS          += VBoxREM64
 endif
 VBoxREM64_EXTENDS = $(REM_MOD)
 VBoxREM64_EXTEND_BY = appending 
 VBoxREM64_DEFS := $($(REM_MOD)_DEFS) VBOX_ENABLE_VBOXREM64
endif

ifdef USE_REM_IMP
#
# The VBoxREM import library.
#
# This is a HACK to get around (a) the cyclic dependency between VBoxVMM and
# VBoxREM during linking and (b) the recursive build ordering which means VBoxREM
# won't be built until after all the other DLLs.
#
VBoxREMImp_TEMPLATE         = VBOXR3
 if1of ($(KBUILD_TARGET), os2 win)
VBoxREMImp_INST             = $(INST_LIB)
 else
VBoxREMImp_NAME             = VBoxREM
VBoxREMImp_INST             = $(INST_LIB)
 endif
VBoxREMImp_SOURCES.win      = VBoxREM.def
VBoxREMImp_SOURCES.os2      = $(PATH_VBoxREMImp)/VBoxREMOS2.def
 ifeq ($(filter win os2,$(KBUILD_TARGET)),)
VBoxREMImp_SOURCES          = $(PATH_VBoxREMImp)/VBoxREMImp.c
VBoxREMImp_CLEAN            = $(PATH_VBoxREMImp)/VBoxREMImp.c
 endif
 ifneq ($(filter-out darwin os2 win,$(KBUILD_TARGET)),)
VBoxREMImp_SONAME           = VBoxREM$(SUFF_DLL)
 endif
VBoxREMImp_LDFLAGS.l4       = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib

$$(PATH_VBoxREMImp)/VBoxREMImp.c: $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(VBOX_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(APPEND) -t $@ '#ifdef VBOX_HAVE_VISIBILITY_HIDDEN'
	$(QUIET)$(APPEND)    $@ '# define EXPORT __attribute__((visibility("default")))'
	$(QUIET)$(APPEND)    $@ '#else'
	$(QUIET)$(APPEND)    $@ '# define EXPORT'
	$(QUIET)$(APPEND)    $@ '#endif'
	$(QUIET)$(APPEND)    $@ ''
	$(QUIET)$(SED) -f $(VBOX_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed --append $@ $<

$$(PATH_VBoxREMImp)/VBoxREMOS2.def: $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(SED) \
		-e 's/^[ \t][ \t]*REMR3/    _REMR3/' \
		-e 's/\.[Dd][Ll][Ll]//' \
		-e 's/^LIBRARY .*/LIBRARY VBoxREM INITINSTANCE TERMINSTANCE\nDATA MULTIPLE\n/' \
		--output $@ \
		$<
endif # USE_REM_IMP

#
# The math testcase as a standalone program for testing and debugging purposes.
#
## @todo This is a bit messy because of MINGW32.
testmath_ASFLAGS.amd64  = -m amd64
testmath_CFLAGS         = -Wall -g
testmath_CFLAGS.release = -O3
testmath_LDFLAGS        = -g
testmath_DEFS           = MATHTEST_STANDALONE
testmath_DEFS          += VBOX_WITH_NEW_RECOMPILER
testmath_SOURCES        = Sun/testmath.c
#testmath_SOURCES        += $(PATH_LIB)/RuntimeR3NoCRTGCC$(VBOX_SUFF_LIB)


include $(KBUILD_PATH)/subfooter.kmk
