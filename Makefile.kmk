# $Id$
## @file
# Top level makefile.
#

#
# Copyright (C) 2006-2007 Sun Microsystems, Inc.
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
# Clara, CA 95054 USA or visit http://www.sun.com if you need
# additional information or have any questions.
#

DEPTH = .
include $(KBUILD_PATH)/header.kmk

ifdef VBOX_WITH_DOCS
 ifndef VBOX_ONLY_ADDITIONS
  SUBDIRS = doc/manual
 endif
endif
SUBDIRS += src

ifndef VBOX_ONLY_ADDITIONS
#
# Install external binaries (mostly redistributable parts of tools we use).
# This must be done *before* we build the manual.
#
# To avoid dragging in unnecessary tools and sdks here, we don't use the .win
# and .linux property suffixes.
#
INSTALLS = bin

bin_INST = $(INST_BIN)

# The SDL DLLs
if1of ($(KBUILD_TARGET), win os2)
 ifneq ($(VBOX_WITH_VBOXSDL)$(VBOX_WITH_VBOXBFE),)
  include $(KBUILD_PATH)/sdks/LIBSDL.kmk
  bin_SOURCES += \
	$(DLL_SDK_LIBSDL_SDL)
  ifdef VBOX_WITH_SECURELABEL
   bin_SOURCES += \
	$(DLL_SDK_LIBSDL_SDLTTF)
  endif
  ifeq ($(KBUILD_TARGET),os2)
   bin_SOURCES += \
	$(DLL_SDK_LIBSDL_FSLIB)
  endif
 endif
endif


# The Qt DLLs.
ifneq ($(VBOX_WITH_QTGUI),)
 if1of ($(KBUILD_TARGET), win os2)
  #include $(KBUILD_PATH)/sdks/QT3.kmk
  #bin_SOURCES += \
  #	$(DLL_SDK_QT3_QT)
  ifneq ($(strip $(VBOX_DLL_QT)),)
   bin_SOURCES += \
	$(VBOX_DLL_QT)=>$(not-dir $(VBOX_DLL_QT))
  endif
  ifdef VBOX_QT_BINARIES
   bin_SOURCES += $(VBOX_QT_BINARIES)
  endif
 else ifeq ($(VBOX_MUST_INSTALL_LIB_QT),1)
   bin_SOURCES += \
	$(LIB_QT)
 endif
endif


# The compiler runtime DLLs.
ifeq ($(KBUILD_TARGET).$(VBOX_WITHOUT_COMPILER_REDIST),win.)
 ifdef VBOX_USE_VCC80
  include $(KBUILD_PATH)/tools/VCC80X86.kmk
  include $(KBUILD_PATH)/tools/VCC80AMD64.kmk
  bin_SOURCES.x86 += \
	$(PATH_TOOL_VCC80X86)/redist/x86/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest=>Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest \
	$(PATH_TOOL_VCC80X86)/redist/x86/Microsoft.VC80.CRT/msvcr80.dll=>Microsoft.VC80.CRT/msvcr80.dll \
	$(PATH_TOOL_VCC80X86)/redist/x86/Microsoft.VC80.CRT/msvcp80.dll=>Microsoft.VC80.CRT/msvcp80.dll \
	$(PATH_TOOL_VCC80X86)/redist/x86/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest=>testcase/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest \
	$(PATH_TOOL_VCC80X86)/redist/x86/Microsoft.VC80.CRT/msvcr80.dll=>testcase/Microsoft.VC80.CRT/msvcr80.dll \
	$(PATH_TOOL_VCC80X86)/redist/x86/Microsoft.VC80.CRT/msvcp80.dll=>testcase/Microsoft.VC80.CRT/msvcp80.dll
  bin_SOURCES.amd64 += \
	$(PATH_TOOL_VCC80AMD64)/redist/amd64/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest=>Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest \
	$(PATH_TOOL_VCC80AMD64)/redist/amd64/Microsoft.VC80.CRT/msvcr80.dll=>Microsoft.VC80.CRT/msvcr80.dll \
	$(PATH_TOOL_VCC80AMD64)/redist/amd64/Microsoft.VC80.CRT/msvcp80.dll=>Microsoft.VC80.CRT/msvcp80.dll \
	$(PATH_TOOL_VCC80AMD64)/redist/amd64/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest=>testcase/Microsoft.VC80.CRT/Microsoft.VC80.CRT.manifest \
	$(PATH_TOOL_VCC80AMD64)/redist/amd64/Microsoft.VC80.CRT/msvcr80.dll=>testcase/Microsoft.VC80.CRT/msvcr80.dll \
	$(PATH_TOOL_VCC80AMD64)/redist/amd64/Microsoft.VC80.CRT/msvcp80.dll=>testcase/Microsoft.VC80.CRT/msvcp80.dll
 endif
 ifndef VBOX_USE_VCC80
  VBOX_INSTALL_VCC70_RT = 1
 endif
 ifeq ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH),win.x86)
  VBOX_INSTALL_VCC70_RT = 1
 endif
 ifdef VBOX_INSTALL_VCC70_RT
  include $(KBUILD_PATH)/tools/VCC70.kmk
  ## @todo Move these defines to VCC70.
  DLL_TOOL_VCC70_MSVCR71 ?= $(PATH_TOOL_VCC70)/bin/msvcr71.dll
  ifneq ($(wildcard $(DLL_TOOL_VCC70_MSVCR71)),)
   bin_SOURCES += \
	$(DLL_TOOL_VCC70_MSVCR71)=>msvcr71.dll \
	$(DLL_TOOL_VCC70_MSVCR71)=>testcase/msvcr71.dll
  endif
  DLL_TOOL_VCC70_MSVCP71 ?= $(PATH_TOOL_VCC70)/bin/msvcp71.dll
  ifneq ($(wildcard $(DLL_TOOL_VCC70_MSVCP71)),)
   bin_SOURCES += \
	$(DLL_TOOL_VCC70_MSVCP71)=>msvcp71.dll \
	$(DLL_TOOL_VCC70_MSVCP71)=>testcase/msvcp71.dll
   endif
  DLL_TOOL_VCC70_MSVCRT  ?= $(PATH_TOOL_VCC70)/bin/msvcrt.dll
  ifneq ($(wildcard $(DLL_TOOL_VCC70_MSVCRT)),)
   bin_SOURCES += \
	$(DLL_TOOL_VCC70_MSVCRT)=>msvcrt.dll \
	$(DLL_TOOL_VCC70_MSVCRT)=>testcase/msvcrt.dll
  endif
 endif
endif


#
# Install additions iso from the build server.
# The $(CP)/$(RM) stuff can be replaced by a simple $(TOUCH) once that has
# been added to kBuild.
#
## @todo need kmk_builtin_touch!
ifdef VBOX_WITH_ADDITIONS_FROM_BUILD_SERVER
INSTALLS += buildserver-additions
buildserver-additions_INST = $(INST_ADDITIONS)
buildserver-additions_MODE = 0644
buildserver-additions_SOURCES = $(PATH_TARGET)/VBoxGuestAdditions.iso
buildserver-additions_CLEANS = $(PATH_TARGET)/VBoxGuestAdditions.iso $(PATH_TARGET)/VBoxGuestAdditions.iso.tmp

$(PATH_TARGET)/VBoxGuestAdditions.iso: $(VBOX_SVN_REV_KMK) $(PATH_DEVTOOLS)/bin/additions.sh | $(call DIRDEP, $(PATH_TARGET))
	$(RM) -f $(PATH_TARGET)/VBoxGuestAdditions.iso $(PATH_TARGET)/VBoxGuestAdditions.iso.tmp
#	$(PATH_DEVTOOLS)/bin/additions.sh --cmd fetch --filename $(PATH_TARGET)/VBoxGuestAdditions.iso.tmp
	$(KMK) --affinity 1 -f $(MAKEFILE) buildserver-additions-affinity-hack
	$(CP) -f $(PATH_TARGET)/VBoxGuestAdditions.iso.tmp $(PATH_TARGET)/VBoxGuestAdditions.iso
	$(RM) -f $(PATH_TARGET)/VBoxGuestAdditions.iso.tmp

buildserver-additions-affinity-hack:
	$(SHELL) $(PATH_DEVTOOLS)/bin/additions.sh --cmd fetch --filename $(PATH_TARGET)/VBoxGuestAdditions.iso.tmp
endif


#
# Install staged binaries on platforms where we can't cross
# compile things.
#
ifn1of ($(KBUILD_TARGET), l4 linux win)
 VBOX_PATH_STAGED ?= .

 # Additions.
 ifndef VBOX_WITH_LINUX_ADDITIONS
  ifndef VBOX_WITH_WIN32_ADDITIONS
   ifneq ($(wildcard $(VBOX_PATH_STAGED)/VBoxGuestAdditions.iso),)
    INSTALLS += staged-additions
    staged-additions_INST = $(INST_ADDITIONS)
    staged-additions_MODE = 0644
    staged-additions_SOURCES = $(VBOX_PATH_STAGED)/VBoxGuestAdditions.iso
   endif
  endif
 endif

 # guesttool.exe
 ifndef VBOX_WITH_WIN32_ADDITIONS
  ifneq ($(wildcard $(VBOX_PATH_STAGED)/guesttool.exe),)
   INSTALLS += staged-guesttool
   staged-guesttool_INST = $(INST_BIN)
   staged-guesttool_SOURCES = $(VBOX_PATH_STAGED)/guesttool.exe
  endif
 endif

endif

endif # !VBOX_ONLY_ADDITIONS


include $(KBUILD_PATH)/footer.kmk


#
# Generate documentation.
# (This should be converted into a separate pass or merged with an existing one later.)
#
docs: docs.Core
	$(KMK) -C src/VBox/Main docs
	$(KMK) -C src/VBox/Runtime docs

docs.Core: $(PATH_TARGET)/docs.Core



#
# The core (VMM+REM+Devices+Main) documentation.
#
# This includes so much because we wish to have the complete CFGM
# and GCFGM lists.
#
OTHER_CLEAN += \
	$(PATH_TARGET)/Doxyfile \
	$(PATH_TARGET)/Doxyfile.dep

DOXYGEN_INPUT_DIRS = \
	include/iprt \
	include/VBox \
	include/VBox/com \
	include/VBox/HostServices \
	src/VBox/VMM \
	src/VBox/VMM/VMMR0 \
	src/VBox/VMM/VMMGC \
	src/VBox/VMM/VMMAll \
	src/VBox/VMM/PATM \
	src/VBox/VMM/PATM/VMMR0 \
	src/VBox/VMM/PATM/VMMGC \
	src/VBox/VMM/PATM/VMMAll \
	src/VBox/VMM/VMMSwitcher \
	src/VBox/Debugger \
	src/VBox/Devices/ \
	src/VBox/Devices/Audio \
	src/VBox/Devices/Bus \
	src/VBox/Devices/Graphics \
	src/VBox/Devices/Graphics/BIOS \
	src/VBox/Devices/Input \
	src/VBox/Devices/Networking \
	src/VBox/Devices/PC \
	src/VBox/Devices/PC/BIOS \
	src/VBox/Devices/Parallel \
	src/VBox/Devices/Serial \
	src/VBox/Devices/Storage \
	src/VBox/Devices/VBoxHDDFormats \
	src/VBox/Devices/VBoxHDDFormats/StorageCraft \
	src/VBox/Devices/USB \
	src/VBox/Devices/USB/darwin \
	src/VBox/Devices/USB/linux \
	src/VBox/Devices/USB/os2 \
	src/VBox/Devices/USB/solaris \
	src/VBox/Devices/USB/vrdp \
	src/VBox/Devices/USB/win32 \
	src/VBox/Devices/VMMDev \
	src/VBox/Main/include \
	src/VBox/Main/include/hgcm \
	src/VBox/Main/ \
	src/VBox/Main/glue \
	src/VBox/Main/hgcm \
	src/VBox/Main/webservice \
	src/VBox/Main/xml \
	src/VBox/Main/darwin \
	src/VBox/Main/linux \
	src/VBox/Main/os2 \
	src/VBox/Main/solaris \
	src/VBox/Main/win32 \
	src/VBox/HostServices/ \
	src/VBox/HostServices/SharedClipboard \
	src/VBox/HostServices/SharedFolders \
	src/VBox/HostServices/SharedOpenGL \
	src/VBox/HostDrivers/Support \
	src/VBox/HostDrivers/Support/darwin \
	src/VBox/HostDrivers/Support/freebsd \
	src/VBox/HostDrivers/Support/l4 \
	src/VBox/HostDrivers/Support/linux \
	src/VBox/HostDrivers/Support/os2 \
	src/VBox/HostDrivers/Support/solaris \
	src/VBox/HostDrivers/Support/win \
	src/VBox/HostDrivers/VBoxTAP/ \
	src/VBox/HostDrivers/VBoxTAP/win \
	src/VBox/HostDrivers/VBoxTAP/darwin \
	src/VBox/HostDrivers/VBoxUSB/ \
	src/VBox/HostDrivers/VBoxUSB/darwin \
	src/VBox/HostDrivers/VBoxUSB/os2 \
	src/VBox/HostDrivers/VBoxUSB/win \
	src/VBox/HostDrivers/VBoxUSB/win/Device \
	src/VBox/HostDrivers/VBoxUSB/win/Device/amd64 \
	src/VBox/HostDrivers/VBoxUSB/win/Device/x86 \
	src/VBox/HostDrivers/VBoxUSB/win/Filter \
	src/VBox/HostDrivers/VBoxUSB/win/Install \
	src/VBox/HostDrivers/VBoxUSB/win/Monitor \
	src/VBox/HostDrivers/VBoxUSB/win/Monitor/win32 \
	src/VBox/HostDrivers/VBoxUSB/win/Monitor/win64 \
	src/VBox/HostDrivers/VBoxUSB/win/usbd \

# These must come first in order to make things look nice.
DOXYGEN_INPUT_FIRST =\
	$(PATH_ROOT)/doc/VBox-doc.c \
	$(PATH_ROOT)/doc/VBox-CodingGuidelines.cpp \
	$(PATH_ROOT)/src/VBox/VMM/VMMCodingGuidelines.cpp \
	$(PATH_ROOT)/src/VBox/VMM/VMMDocsRawMode.cpp \
	$(PATH_ROOT)/include/VBox/cdefs.h \
	$(PATH_ROOT)/include/VBox/vmapi.h \
	$(PATH_ROOT)/include/VBox/vmm.h \
	$(PATH_ROOT)/include/VBox/cpum.h \
	$(PATH_ROOT)/include/VBox/mm.h \
	$(PATH_ROOT)/include/VBox/pgm.h \
	$(PATH_ROOT)/include/VBox/selm.h \
	$(PATH_ROOT)/include/VBox/trpm.h \
	$(PATH_ROOT)/include/VBox/patm.h \
	$(PATH_ROOT)/include/VBox/dbgf.h \
	$(PATH_ROOT)/include/VBox/stam.h \
	$(PATH_ROOT)/include/VBox/em.h \
	$(PATH_ROOT)/include/VBox/pdm.h \
	$(PATH_ROOT)/include/VBox/rem.h \
	$(PATH_ROOT)/include/VBox/iom.h \
	$(PATH_ROOT)/include/VBox/cfgm.h \
	$(PATH_ROOT)/include/VBox/tm.h \
	$(PATH_ROOT)/include/VBox/csam.h \
	$(PATH_ROOT)/include/VBox/ssm.h \
	$(PATH_ROOT)/include/VBox/hwaccm.h \
	$(PATH_ROOT)/include/VBox/hwacc_svm.h \
	$(PATH_ROOT)/include/VBox/hwacc_vmx.h \
	$(PATH_ROOT)/\
	$(PATH_ROOT)/src/VBox/VMM/CFGMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/CPUMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/DBGFInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/EMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/HWACCMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/IOMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/MMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/PDMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/PGMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/PATM/CSAMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/PATM/PATMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/REMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/SELMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/SSMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/STAMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/TMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/TRPMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/VMInternal.h \
	$(PATH_ROOT)/src/VBox/VMM/VMMInternal.h \
	$(PATH_ROOT)/\
	$(PATH_ROOT)/include/VBox/vm.h \
	\
	$(PATH_ROOT)/include/VBox/sup.h \
	$(PATH_ROOT)/include/VBox/VBoxHDD.h \
	$(PATH_ROOT)/include/VBox/types.h \
	$(PATH_ROOT)/include/VBox/err.h \
	$(PATH_ROOT)/include/VBox/x86.h \
	$(PATH_ROOT)/include/VBox/cpumdis.h \
	$(PATH_ROOT)/include/VBox/dbggui.h \
	$(PATH_ROOT)/include/VBox/dis.h \
	$(PATH_ROOT)/include/VBox/disopcode.h \
	$(PATH_ROOT)/include/VBox/intnet.h \
	$(PATH_ROOT)/include/VBox/settings.h \
	$(PATH_ROOT)/include/VBox/pci.h \
	$(PATH_ROOT)/include/VBox/scsi.h \
	$(PATH_ROOT)/include/VBox/shflsvc.h \
	$(PATH_ROOT)/include/VBox/hgcmsvc.h \
	$(PATH_ROOT)/include/VBox/usb.h \
	$(PATH_ROOT)/include/VBox/vusb.h \
	$(PATH_ROOT)/\
	$(PATH_ROOT)/include/VBox/log.h \
	$(PATH_ROOT)/include/VBox/param.h \
	$(PATH_ROOT)/include/VBox/version.h

DOXYGEN_INPUT := \
	$(filter-out %.cpp.h, $(sort $(wildcard $(addsuffix /*.h, $(DOXYGEN_INPUT_DIRS)))) ) \
	$(foreach dir, $(DOXYGEN_INPUT_DIRS), $(wildcard $(dir)/*.cpp $(dir)/.c $(dir)/.asm))
DOXYGEN_INPUT := \
	$(DOXYGEN_INPUT_FIRST) \
	$(filter-out $(DOXYGEN_INPUT_FIRST), $(DOXYGEN_INPUT))

# And some some additional stuff.
DOXYGEN_INPUT += \
	$(PATH_ROOT)/src/recompiler/VBoxRecompiler.c \
	$(PATH_ROOT)/src/recompiler/VBoxREMWrapper.cpp


DOXYGEN_OUTPUT = $(PATH_OUT)/docs/Core

-include $(PATH_TARGET)/Doxyfile.dep

# Generate the Doxyfile
$(PATH_TARGET)/Doxyfile: Doxyfile.Core \
		$(comp-vars DOXYGEN_INPUT,DOXYGEN_INPUT_PREV,FORCE) \
		$(comp-vars DOXYGEN_OUTPUT,DOXYGEN_OUTPUT_PREV,FORCE) \
		| $(call DIRDEP, $(PATH_TARGET))
	$(RM) -f $@ $@.tmp $(PATH_TARGET)/Doxyfile.dep
	$(CP) -f Doxyfile.Core $@.tmp
	$(APPEND) $@.tmp
	$(APPEND) $@.tmp "OUTPUT_DIRECTORY = $(DOXYGEN_OUTPUT)"
	$(APPEND) $@.tmp "WARN_LOGFILE = $(DOXYGEN_OUTPUT)/errors"
	$(APPEND) $@.tmp "INCLUDE_PATH = $(PATH_ROOT)/include $(PATH_ROOT)/src/VBox/VMM $(PATH_ROOT)/src/VBox/Main/include "
	$(APPEND) $@.tmp "INCLUDE_FILE_PATTERNS = *.cpp.h"
	$(APPEND) $@.tmp
	$(APPEND) $@.tmp "INPUT = $(DOXYGEN_INPUT)"
	$(APPEND) $@.tmp
	$(APPEND) $@.tmp "PREDEFINED += $(DEFS) $(DEFS.$(KBUILD_TARGET)) $(DEFS.$(KBUILD_TARGET_ARCH)) $(ARCH_BITS_DEFS)"
	$(APPEND) $@.tmp "PREDEFINED += ARCH_BITS=HC_ARCH_BITS R3_ARCH_BITS=HC_ARCH_BITS R0_ARCH_BITS=HC_ARCH_BITS "
	$(APPEND) $@.tmp
	$(MV) -f $@.tmp $@
	@$(APPEND) $(PATH_TARGET)/Doxyfile.dep "DOXYGEN_OUTPUT_PREV = $(DOXYGEN_OUTPUT)"
	@$(APPEND) $(PATH_TARGET)/Doxyfile.dep "DOXYGEN_INPUT_PREV = $(DOXYGEN_INPUT)"

# Create the output directory.
$(call DIRDEP, $(DOXYGEN_OUTPUT)):
	$(MKDIR) -p $@

# Do the actual job.
$(PATH_TARGET)/docs.Core: $(PATH_TARGET)/Doxyfile $(DOXYGEN_INPUT) | $(call DIRDEP, $(DOXYGEN_OUTPUT))
	$(RM) -f $(wildcard $(DOXYGEN_OUTPUT)/html/*) $(PATH_TARGET)/docs.Core
	doxygen $(PATH_TARGET)/Doxyfile
	$(APPEND) $(PATH_TARGET)/docs.Core


#
# Generate x86.mac and err.mac.
#
incs:
	$(SED) -f include/VBox/err.sed include/VBox/err.h > include/VBox/err.mac
	echo '%include "iprt/err.mac"' >> include/VBox/err.mac
	$(SED) -f include/VBox/err.sed include/iprt/err.h > include/iprt/err.mac
	$(SED) -e '/__VBox_x86_h__/d' -e '/#define/!d' -e 's/#define/%define/' include/VBox/x86.h > include/VBox/x86.mac


#
# Generate Visual SlickEdit tagging #defines.
#
vslick.h: include/VBox/cdefs.h Makefile
	echo '// autogenerated' > $@.tmp
	#echo '#define __BEGIN_DECLS ' >> $@.tmp
	#echo '#define __END_DECLS ' >> $@.tmp

	echo '#define ATL_NO_VTABLE ' >> $@.tmp
	echo '#define BEGIN_COM_MAP(a) ' >> $@.tmp
	echo '#define END_COM_MAP(a) ' >> $@.tmp

	echo '#define CHECKREADY if(!isReady()) return E_UNEXPECTED; ' >> $@.tmp
	echo '#define COM_DECL_READONLY_ENUM_AND_COLLECTION(a) ' >> $@.tmp
	echo '#define COM_INTERFACE_ENTRY(a) ' >> $@.tmp
	echo '#define COMGETTER(n)                    Get##n ' >> $@.tmp
	echo '#define COMSETTER(n)                    Set##n ' >> $@.tmp
	echo '#define ComSafeArrayIn(t,a)             t a[] ' >> $@.tmp
	echo '#define ComSafeArrayOut(t,a)            t * a[] ' >> $@.tmp
	echo '#define DECLARE_NOT_AGGREGATABLE(a) ' >> $@.tmp
	echo '#define DECLARE_PROTECT_FINAL_CONSTRUCT(a) ' >> $@.tmp
	echo '#define NS_DECL_ISUPPORTS ' >> $@.tmp
	echo '#define NS_IMETHOD NS_IMETHOD_(nsresult) ' >> $@.tmp
	echo '#define NS_IMETHOD_(type) type ' >> $@.tmp
	echo '#define PARSERS_EXPORT ' >> $@.tmp
	echo '#define SAX_EXPORT ' >> $@.tmp
	echo '#define STDMETHOD(a) NS_IMETHOD a ' >> $@.tmp
	echo '#define XERCES_CPP_NAMESPACE_BEGIN ' >> $@.tmp
	echo '#define XERCES_CPP_NAMESPACE_END ' >> $@.tmp

	echo '#define CTXAllSUFF(var)                 var##R3 ' >> $@.tmp
	echo '#define CTXSUFF(var)                    var##HC ' >> $@.tmp
	echo '#define OTHERCTXSUFF(var)  	      var##GC ' >> $@.tmp
	echo '#define CTXALLMID(first, last)          first##R3##last ' >> $@.tmp
	echo '#define CTXMID(first, last)             first##HC##last ' >> $@.tmp
	echo '#define OTHERCTXMID(first, last)        first##GC##last ' >> $@.tmp
	echo '#define CTXTYPE(GCType, R3Type, R0Type) R3Type ' >> $@.tmp
	echo '#define GCPTRTYPE(GCType)               GCType ' >> $@.tmp
	echo '#define GCTYPE(GCType, HCType)          GCType ' >> $@.tmp
	echo '#define HCPTRTYPE(HCType)               HCType ' >> $@.tmp
	echo '#define R3R0PTRTYPE(HCType)             HCType ' >> $@.tmp
	echo '#define R0PTRTYPE(R3Type)               R3Type ' >> $@.tmp
	echo '#define R3PTRTYPE(R0Type)               R0Type ' >> $@.tmp
	echo '#define RT_SRC_POS                      __FILE__, __LINE__, __PRETTY_FUNCTION__ ' >> $@.tmp
	echo '#define RT_SRC_POS_DECL                 const char *pszFile, unsigned iLine, const char *pszFunction ' >> $@.tmp
	echo '#define RT_SRC_POS_ARGS                 pszFile, iLine, pszFunction ' >> $@.tmp
	echo '#define RTCALL' >> $@.tmp
	echo '#define DECLINLINE(type)                inline type ' >> $@.tmp

	echo '#define PDM_SRC_POS                     __FILE__, __LINE__, __PRETTY_FUNCTION__ ' >> $@.tmp
	echo '#define PDM_SRC_POS_DECL                const char *pszFile, unsigned iLine, const char *pszFunction ' >> $@.tmp
	echo '#define PDM_SRC_POS_ARGS                pszFile, iLine, pszFunction ' >> $@.tmp
	echo '#define PDMDEVINSINT_DECLARED           1' >> $@.tmp
	echo '#define VBOXCALL' >> $@.tmp

	$(SED)  -e '/__cdecl/d' \
		-e '/^ *# *define.*DECL/!d' \
		-e '/DECLS/d' \
		-e '/DECLARE_CLS_/d' \
		-e '/_SRC_POS_DECL/d' \
		-e '/declspec/d' \
		-e '/__attribute__/d' \
		-e 's/#  */#/g' \
		-e 's/   */ /g' \
		-e '/(type) DECLEXPORT/d' \
		-e '/ DECLEXPORT_CLASS/d' \
		-e 's/ *VBOXCALL//' \
		-e 's/ *RTCALL//' \
		-e 's/(type) DECLIMPORT(type)/(type) type/' \
		-e '/ DECLASM(type) type/d' \
		-e '/define  *DECL..CALLBACKMEMBER(type[^)]*) *RT/d' \
		-e '/define  *DECLINLINE(type)/d' \
		\
		--append $@.tmp \
		$(filter-out include/VBox/err.h, $(wildcard include/VBox/*.h)) \
		include/iprt/cdefs.h
	$(CAT_EXT) $@.tmp | sort | $(SED_EXT) -e 's/$$/\n/' --output $@.tmp2
	$(MV) -f $@.tmp2 $@
	$(RM) -f $@.tmp $@.tmp2 $@.tmp3
	$(ECHO) "TODO: Merge ./vslick.h with your ~/.slickedit/x.y.z/unxcpp.h file."


#
# Add fetching of the tools to the 'up[date][2]' targets.
#
up update up2 update2::
ifndef VBOX_OSE
	$(MAKE) -C tools fetch
else
	$(MAKE) -C tools -f Makefile-ose.kmk fetch
endif


#
# Build the additions, all of them.
#
# This is currently tailored (hardcoded) for the additions
# build box. Can make it pretty and configurable later.
#
# The fetching must be done in serial fashion, while the building
# should be more flexible wrt to -jN.
#
additions-fetch:
	+ $(KMK) -C tools fetch
	+ $(KMK) -C tools fetch KBUILD_TARGET_ARCH=x86 KBUILD_TARGET=linux   BUILD_TARGET_ARCH=x86 BUILD_TARGET=linux
#	+ $(KMK) -C tools fetch KBUILD_TARGET_ARCH=x86 KBUILD_TARGET=os2     BUILD_TARGET_ARCH=x86 BUILD_TARGET=os2
	+ $(KMK) -C tools fetch KBUILD_TARGET_ARCH=x86 KBUILD_TARGET=solaris BUILD_TARGET_ARCH=x86 BUILD_TARGET=solaris
	+ $(KMK) -C tools fetch KBUILD_TARGET_ARCH=x86 KBUILD_TARGET=win     BUILD_TARGET_ARCH=x86 BUILD_TARGET=win


additions-build: \
	additions-build-win.x86 \
	additions-build-solaris.x86 \
	additions-build-os2.x86 \
	additions-build-linux.x86

VBOX_ADDITIONS_BUILD.x86 = VBOX_ONLY_ADDITIONS=1 VBOX_WITHOUT_ADDITIONS_ISO=1 \
	KBUILD_TYPE=$(KBUILD_TYPE) BUILD_TYPE=$(KBUILD_TYPE) \
	KBUILD_TARGET_ARCH=x86 BUILD_TARGET_ARCH=x86 \
	all packing

additions-build-win.x86:
ifeq ($(KBUILD_TARGET),win)
	+ $(KMK) $(VBOX_ADDITIONS_BUILD.x86)
else
	rsync -av --delete --delete-excluded --exclude .svn/ --exclude out/ --exclude tinderclient.log . 192.168.27.5:/cygdrive/c/vbox
	ssh vbox@192.168.27.5 " cd /cygdrive/c/vbox && PATH_OUT_BASE=Z:/add/out tools/env.sh kmk $(VBOX_ADDITIONS_BUILD.x86)"
#	ssh vbox@192.168.27.5 "cmd.exe /c cd /d z:\\add && set PATH_DEVTOOLS=c:\\vbox\\tools && c:\\vbox\\tools\\env.cmd -KBUILD c:\\vbox\\kBuild && set KMK_DONT_USE_NT_QUERY_INFORMATION_FILE=1 && set USER=vbox && kmk $(VBOX_ADDITIONS_BUILD.x86)"
endif

additions-build-solaris.x86:
ifeq ($(KBUILD_TARGET),solaris)
	+ $(KMK) $(VBOX_ADDITIONS_BUILD.x86)
else
	ssh vbox@192.168.27.4 " cd /mnt/vbox/add && ./tools/env.sh --no-wine kmk $(VBOX_ADDITIONS_BUILD.x86) "
endif

additions-build-os2.x86:
#ifeq ($(KBUILD_TARGET),os2)
#	+ $(KMK) $(VBOX_ADDITIONS_BUILD.x86)
#else
#	ssh vbox@192.168.27.3 " cd /mnt/vbox/add && ./tools/env.sh --no-wine kmk $(VBOX_ADDITIONS_BUILD.x86) "
#endif

additions-build-linux.x86:
ifeq ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH),linux.x86)
	+ $(KMK) $(VBOX_ADDITIONS_BUILD.x86)
else
	ssh vbox@192.168.27.2 " cd /mnt/vbox/add && ./tools/env.sh --no-wine kmk $(VBOX_ADDITIONS_BUILD.x86) "
endif


additions-packing:
	+ $(KMK) VBOX_ONLY_ADDITIONS=1 \
		VBOX_WITH_ADDITIONS_ISO.freebsd.amd64= \
		VBOX_WITH_ADDITIONS_ISO.freebsd.x86=1 \
		VBOX_WITH_ADDITIONS_ISO.linux.amd64= \
		VBOX_WITH_ADDITIONS_ISO.linux.x86=1 \
		VBOX_WITH_ADDITIONS_ISO.solaris.amd64= \
		VBOX_WITH_ADDITIONS_ISO.solaris.x86=1 \
		VBOX_WITH_ADDITIONS_ISO.win.amd64= \
		VBOX_WITH_ADDITIONS_ISO.win.x86=1 \
		-C src/VBox/Additions \
		$(VBOX_PATH_ADDITIONS)/VBoxGuestAdditions.iso


#
# Generate VirtualBox-OSE-x.x.x.tar.bz2 tarballs for distribution
#
# - includes kBuild
# - must be executed on an OSE checkout
#

# the path where to store the tarball
TARBALLPATH ?= $(shell cd $(PATH_ROOT)/..; pwd)
#TARBALLPATH ?= $(abspath $(PATH_ROOT)/..) - this should also do the trick without spawning a shell.
# the root directory inside the tarball
TARBALLROOT ?= VirtualBox-$(VBOX_VERSION_STRING)
# the name of the tarball file
TARBALLNAME ?= VirtualBox-$(VBOX_VERSION_STRING).tar.bz2
snapshot:
	@$(call MSG_L1,Creating tarball $(TARBALLPATH)/$(TARBALLNAME))
	@if [ -d "$(PATH_ROOT)/src/VBox/Devices/USB" ]; then echo; echo "Found USB stuff, refused to build OSE tarball!"; echo; exit 1; fi
	$(QUIET)$(MKDIR) -p $(TARBALLPATH)
	$(QUIET)$(RM) -f $(wildcard $(TARBALLPATH)/VirtualBox*)
	$(QUIET)$(LN_SYMLINK) $(PATH_ROOT) $(TARBALLPATH)/$(TARBALLROOT)
	$(QUIET)tar -cjh --owner 0 --group 0 --totals \
	    --exclude=.svn \
	    --exclude=$(TARBALLROOT)/out \
	    --exclude=$(TARBALLROOT)/env.sh \
	    --exclude=$(TARBALLROOT)/configure.log \
	    --exclude=$(TARBALLROOT)/AutoConfig.kmk \
	    --exclude=$(TARBALLROOT)/LocalConfig.kmk \
	    -C $(TARBALLPATH) \
	    -f $(TARBALLPATH)/$(TARBALLNAME) \
	    $(TARBALLROOT)
	$(QUIET)$(RM) $(TARBALLPATH)/$(TARBALLROOT)
