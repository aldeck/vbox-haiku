# $Id$
## @file
#
# The global build configuration file for VBox.
#
# This file gets included by all makefiles through the
# include $(PATH_KBUILD)/header.kmk statement.
#

#
# Copyright (C) 2006 InnoTek Systemberatung GmbH
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation,
# in version 2 as it comes in the "COPYING" file of the VirtualBox OSE
# distribution. VirtualBox OSE is distributed in the hope that it will
# be useful, but WITHOUT ANY WARRANTY of any kind.
#
# If you received this file as part of a commercial VirtualBox
# distribution, then only the terms of your commercial VirtualBox
# license agreement apply instead of the previous paragraph.
#


#
# kBuild stuff
#

# Enable automatic installation of what's built.
KBUILD_DO_AUTO_INSTALL := 1
# Add the GPLExport pass.
PASSES := $(filter-out PACKING,$(PASSES)) PACKING # temporary hack
PASSES               += GPLEXPORT
# Modify the order of the INSTALLS and OTHERS passes.
DEFAULT_PASSES       := BLDPROGS LIBRARIES DLLS BINARIES INSTALLS OTHERS

## PASS: gplexport
# This pass processes custom gplexport rules listed in
# the GPLEXPORTS variable.
PASS_GPLEXPORT      := GPL and LGPL source export
PASS_GPLEXPORT_trgs :=
PASS_GPLEXPORT_vars := GPLEXPORTS
PASS_GPLEXPORT_pass := gplexport
#alias
gplexport: pass_gplexport

# Install paths.
PATH_INS            := $(PATH_OUT)
ifeq ($(BUILD_TARGET),darwin)
 INST_DIST            = dist/
 INST_SDK             = $(INST_DIST)sdk/
 INST_SDK_SAMPLES     = $(INST_SDK)samples

 # the bundles
 INST_VIRTUALBOX      = $(INST_DIST)VirtualBox.app/
 INST_VBOXDRV         = $(INST_DIST)VBoxDrv.kext/
 INST_VBOXTAP         = $(INST_DIST)VBoxTAP.kext/
 INST_VBOXUSB         = $(INST_DIST)VBoxUSB.kext/

 # put everything in the VirtualBox app bundle.
 INST_BIN             = $(INST_VIRTUALBOX)Contents/MacOS/
 INST_DLL             = $(INST_BIN)
 INST_SYS             = $(INST_BIN)
 INST_TESTCASE        = $(INST_BIN)testcase/
 INST_ADDITIONS       = $(INST_BIN)additions/

 # other paths
 INST_TESTSUITE       = testsuite/
 INST_LIB             = lib/
 INST_ADDITIONS_LIB   = $(PATH_LIB)/additions/

else

 INST_BIN             = bin/
 INST_DIST            = $(INST_BIN)
 INST_DLL             = $(INST_BIN)
 INST_SDK             = $(INST_BIN)sdk/
 INST_SDK_SAMPLES     = $(INST_SDK)samples
 INST_DLL             = $(INST_BIN)
 INST_SYS             = $(INST_BIN)
 INST_TESTCASE        = $(INST_BIN)testcase/
 INST_ADDITIONS       = $(INST_BIN)additions/

 INST_TESTSUITE       = testsuite/
 INST_LIB             = lib/
 INST_ADDITIONS_LIB   = $(INST_LIB)additions/
endif

PATH_BIN              = $(patsubst %/,%,$(PATH_INS)/$(INST_BIN))
PATH_DLL              = $(patsubst %/,%,$(PATH_INS)/$(INST_DLL))
PATH_SYS              = $(patsubst %/,%,$(PATH_INS)/$(INST_SYS))
PATH_LIB              = $(patsubst %/,%,$(PATH_INS)/$(INST_LIB))
PATH_DOC              = $(PATH_OUT)/doc
VBOX_PATH_SDK         = $(patsubst %/,%,$(PATH_INS)/$(INST_SDK))
VBOX_PATH_DIST        = $(patsubst %/,%,$(PATH_INS)/$(INST_DIST))
VBOX_PATH_TESTSUITE   = $(patsubst %/,%,$(PATH_INS)/$(INST_TESTSUITE))


# Delete targets on failure.
.DELETE_ON_ERROR:

# Notify about important kBuild updates.
ifneq ($(call int-ge,$(KMK_REVISION),890),1)
 $(error You must update kBuild!)
endif

#
# Define USERNAME early on.
#
ifndef USERNAME
 ifdef USER
  USERNAME = $(USER)
 else
  $(warning Warning: You must have USERNAME or USER in your environment.)
 endif
endif

#
# The VirtualBox version.
#

# Major version.
VBOX_VERSION_MAJOR = 1
# Minor version.
VBOX_VERSION_MINOR = 3
# This is the current build number. It should be increased every time we publish a
# new build. The define is available in every source file. Only even build numbers
# will be published, odd numbers are set during development.
VBOX_VERSION_BUILD = 99
# Full version string (may include more than just x.y.z, but no spaces or other problematic chars).
VBOX_VERSION_STRING = $(VBOX_VERSION_MAJOR).$(VBOX_VERSION_MINOR).$(VBOX_VERSION_BUILD)
# Same as VBOX_VERSION_STRING, deprecated.
VBOX_VERSION = $(VBOX_VERSION_STRING)


#
# The VirtualBox Configuration Defaults.
#

# Build linux / win32 additions.
ifeq ($(BUILD_TARGET),linux)
  VBOX_WITH_LINUX_ADDITIONS = 1
  VBOX_WITH_WIN32_ADDITIONS = 1
endif
ifeq ($(BUILD_TARGET),l4)
 VBOX_WITH_LINUX_ADDITIONS = 1
 VBOX_WITH_WIN32_ADDITIONS = 1
endif
ifeq ($(BUILD_TARGET),win)
 VBOX_WITH_WIN32_ADDITIONS = 1
endif
ifdef VBOX_WITH_LINUX_ADDITIONS
 ifeq ($(BUILD_TARGET).$(BUILD_PLATFORM_ARCH),linux.x86)
  VBOX_WITH_LINUX_ADDITIONS_32BIT_R0 = 1
 endif
endif
# Enable the building of shared folders in the windows additions.
VBOX_WITH_WIN32_ADDITIONS_SHAREDFOLDERS = 1

# build the installer
VBOX_WITH_INSTALLER = 1
# enable VRDP server
VBOX_WITH_VRDP = 1
# enable new multiconnection code
VBOX_WITH_VRDP_MC = 1
# build VRDP authentication modules
VBOX_WITH_VRDP_AUTHMOD = 1
# build enhanced version of rdesktop
VBOX_WITH_VRDP_RDESKTOP = 1
ifeq ($(filter-out darwin os2,$(BUILD_TARGET)),)
# build the support driver & library without IDT patching.
## @todo invert this!
VBOX_WITHOUT_IDT_PATCHING = 1
endif
# The kernel driver/module and related runtime libraries.
VBOX_WITH_VBOXDRV = 1
# build with secure label support
ifeq ($(filter win.amd64,$(BUILD_TARGET).$(BUILD_TARGET_ARCH)),) # too much work with freetype and all that.
VBOX_WITH_SECURELABEL = 1
endif

# the main api
VBOX_WITH_MAIN = 1
# the SDL based GUI
VBOX_WITH_VBOXSDL = 1
# the basic frontend (w/o Main)
VBOX_WITH_VBOXBFE = 1
# the Qt GUI
VBOX_WITH_QTGUI = 1
## the Direct Framebuffer GUI
#VBOX_WITH_VBOXFB = 1
# the gui debugger
ifneq ($(BUILD_TYPE),release)
VBOX_WITH_DEBUGGER_GUI = 1
endif
# the documentation
VBOX_WITH_DOCS = 1
# build the Host Guest Communication Manager component
VBOX_WITH_HGCM = 1
# Enable the USB feature.
VBOX_WITH_USB = 1
# Enable the ISCSI feature.
VBOX_WITH_ISCSI = 1
# Enable ALSA support for Linux
VBOX_WITH_ALSA = 1
# Disable WINMM support for Windows (not implemented)
VBOX_WITH_WINMM =
# Enable the kchmviewer
VBOX_WITH_KCHMVIEWER = 1
# Build the testsuite.
VBOX_WITH_TESTSUITE = 1
# Build the testcases.
VBOX_WITH_TESTCASES = 1
# Set this to not use COM or XPCOM in places where it can be avoided.
#VBOX_WITHOUT_COM = 1
# Set this to skip installing the redistributable compiler runtime.
#VBOX_WITHOUT_COMPILER_REDIST = 1
# Enabled internal networking.
VBOX_WITH_INTERNAL_NETWORKING = 1
# Enables the ffmpeg module for recording test runs.
#VBOX_WITH_FFMPEG = 1


#
# Skip stuff.
#

# VBOX_QUICK can be used by core developers to speed to the build
ifdef VBOX_QUICK
 # undefine variables by assigning blank.
 VBOX_WITH_TESTSUITE=
 VBOX_WITH_TESTCASES=
 VBOX_WITH_MAIN =
 VBOX_WITH_VBOXSDL =
 VBOX_WITH_VBOXBFE =
 VBOX_WITH_QTGUI =
 VBOX_WITH_DEBUGGER_GUI =
 VBOX_WITH_DOCS =
endif # VBOX_QUICK

# l4 have to skip a few things.
ifeq ($(BUILD_TARGET),l4)
 VBOX_WITH_VBOXDRV=
 VBOX_WITH_VRDP=
 VBOX_WITH_VBOXSDL=
 VBOX_WITH_QTGUI=
 VBOX_WITH_MAIN=
 VBOX_WITH_DOCS=
 VBOX_WITH_ISCSI=
 VBOX_WITH_INTERNAL_NETWORKING=
endif

# Darwin have to skip a few things at present.
ifeq ($(BUILD_TARGET),darwin)
 # Internal networking requires testing and possibly proper ring-3/ring0 separation.
 VBOX_WITH_INTERNAL_NETWORKING=
 # Don't bother with SDL ttf for now.
 VBOX_WITH_SECURELABEL=
 ifdef VBOX_OSE
  # Qt/Mac v3.3.x requires patching to work for us.
  VBOX_WITH_QTGUI=
 endif
 # Later:
 VBOX_WITH_USB=
 VBOX_WITH_VRDP_AUTHMOD=
 VBOX_WITH_VRDP_RDESKTOP=
endif

# Most stuff doesn't build yet on the new targets.
ifeq ($(filter-out os2 freebsd solaris,$(BUILD_TARGET)),)
 #VBOX_WITH_VBOXBFE=
 VBOX_WITH_MAIN=
 VBOX_WITH_VBOXSDL=
 VBOX_WITH_QTGUI=
 VBOX_WITH_DEBUGGER_GUI=
 VBOX_WITH_INSTALLER=
 VBOX_WITH_SECURELABEL=
 VBOX_WITH_VRDP=
 VBOX_WITH_VRDP_AUTHMOD=
 VBOX_WITH_VRDP_RDESKTOP=
 VBOX_WITH_TESTSUITE=
 VBOX_WITH_USB=
 VBOX_WITH_DOCS=
endif


#
# Include automatic and local config file to override the above settings
# and to provide defaults for the settings below this point.
#
AUTOCFG := $(wildcard $(PATH_ROOT)/AutoConfig.kmk)
ifeq ($(AUTOCFG),)
 # deprecated name. to be removed.
 AUTOCFG := $(wildcard $(PATH_ROOT)/Config.kmkconf)
 ifneq ($(AUTOCFG),)
  $(warning Config.kmkconf has been renamed. Please re-run configure.)
 endif
endif
ifneq ($(AUTOCFG),)
 include $(AUTOCFG)
endif

LOCALCFG := $(wildcard $(PATH_ROOT)/LocalConfig.kmk)
ifeq ($(LOCALCFG),)
 # deprecated name. to be removed.
 LOCALCFG := $(wildcard $(PATH_ROOT)/Config.kmklocal)
 ifneq ($(LOCALCFG),)
  $(warning Please rename your Config.kmklocal to LocalConfig.kmk.)
 endif
endif
ifneq ($(LOCALCFG),)
 include $(LOCALCFG)
endif


#
# Disable components that are not open sourced.
#
ifdef VBOX_OSE
 VBOX_WITH_VRDP=
 VBOX_WITH_USB=
 VBOX_WITH_ISCSI=
 VBOX_WITH_DEBUGGER_GUI=
 VBOX_WITH_WIN32_ADDITIONS_SHAREDFOLDERS=
 VBOX_WITH_SECURELABEL=
 VBOX_WITH_INSTALLER=
 VBOX_WITH_KCHMVIEWER=
 VBOX_WITH_DOCS=
 VBOX_WITH_TESTSUITE=
 PASSES := $(filter-out PACKING,$(PASSES))
endif

#
# Undefined VBOX_WITH_MAIN implies exclusion of a few more items.
#
ifndef VBOX_WITH_MAIN
 VBOX_WITH_VRDP=
 VBOX_WITH_VBOXSDL=
 VBOX_WITH_QTGUI=
 VBOX_WITH_DEBUGGER_GUI=
endif


#
# Image and object format config.
#
ifeq ($(filter-out linux l4 freebsd netbsd openbsd solaris,$(BUILD_TARGET)),)
 VBOX_LDR_FMT = elf
endif
ifeq ($(BUILD_TARGET),darwin)
 VBOX_LDR_FMT = macho
endif
ifeq ($(BUILD_TARGET),os2)
 VBOX_LDR_FMT = lx
 VBOX_LDR_FMT32 = lx
 VBOX_LDR_FMT64 = elf
 DONT_USE_YASM = 1 # yasm doesn't implement omf yet.
endif
ifeq ($(BUILD_TARGET),win)
 VBOX_LDR_FMT = pe
endif
VBOX_LDR_FMT32 ?= $(VBOX_LDR_FMT)
VBOX_LDR_FMT64 ?= $(VBOX_LDR_FMT)

#
# Assembler setup.
#
# This is a bit complicated since we have to support two different assmblers
# (yasm/nasm) and possibly two different formats (32-bit/64-bit).
#
ifeq ($(VBOX_LDR_FMT),elf)
 ifeq ($(BUILD_TARGET_ARCH),x86)
VBOX_ASFLAGS_FMT = -f elf32 -DASM_FORMAT_ELF
 else
VBOX_ASFLAGS_FMT = -f elf64 -DASM_FORMAT_ELF
 endif
VBOX_ASFLAGS_DBFINFO = -g dwarf2
endif
ifeq ($(VBOX_LDR_FMT),lx)
 VBOX_ASFLAGS_FMT = -f obj -DASM_FORMAT_OMF
 VBOX_ASFLAGS_DBFINFO = -g stabs
endif
ifeq ($(VBOX_LDR_FMT),macho)
 VBOX_ASFLAGS_FMT = -f macho -DASM_FORMAT_MACHO
 VBOX_ASFLAGS_DBFINFO = -g dwarf2
endif
ifeq ($(VBOX_LDR_FMT),pe)
 ifeq ($(BUILD_TARGET_ARCH),x86)
VBOX_ASFLAGS_FMT = -f win32 -DASM_FORMAT_PE
 else
VBOX_ASFLAGS_FMT = -f win64 -DASM_FORMAT_PE
 endif
endif
ifndef VBOX_ASFLAGS_FMT
 $(error VBOX_ASFLAGS_FMT is not defined. VBOX_LDR_FMT=$(VBOX_LDR_FMT))
endif

ifeq ($(VBOX_LDR_FMT32),elf)
 VBOX_ASFLAGS_FMT32 = -f elf32 -DASM_FORMAT_ELF
 VBOX_ASFLAGS_DBFINFO32 = -g dwarf2
endif
ifeq ($(VBOX_LDR_FMT32),lx)
 VBOX_ASFLAGS_FMT32 = -f obj -DASM_FORMAT_OMF
 VBOX_ASFLAGS_DBFINFO32 = -g stabs
endif
ifeq ($(VBOX_LDR_FMT32),macho)
 VBOX_ASFLAGS_FMT32 = -f macho -DASM_FORMAT_MACHO
 VBOX_ASFLAGS_DBFINFO32 = -g dwarf2
endif
ifeq ($(VBOX_LDR_FMT32),pe)
 VBOX_ASFLAGS_FMT32 = -f win32 -DASM_FORMAT_PE
endif
ifndef VBOX_ASFLAGS_FMT32
 $(error VBOX_ASFLAGS_FMT32 is not defined. VBOX_LDR_FMT32=$(VBOX_LDR_FMT32))
endif

ifeq ($(VBOX_LDR_FMT64),elf)
 VBOX_ASFLAGS_FMT64 = -f elf64 -DASM_FORMAT_ELF
 VBOX_ASFLAGS_DBFINFO64 = -g dwarf2
endif
ifeq ($(VBOX_LDR_FMT64),macho)
 VBOX_ASFLAGS_FMT64 = -f macho64 -DASM_FORMAT_MACHO
 VBOX_ASFLAGS_DBFINFO64 = -g dwarf2
endif
ifeq ($(VBOX_LDR_FMT64),pe)
 VBOX_ASFLAGS_FMT64 = -f win64 -DASM_FORMAT_PE
endif
ifndef VBOX_ASFLAGS_FMT64
 $(error VBOX_ASFLAGS_FMT64 is not defined. VBOX_LDR_FMT64=$(VBOX_LDR_FMT64))
endif

ifndef DONT_USE_YASM
 VBOX_ASTOOL    = YASM
 VBOX_LDR_FMT_2_YASM_DBGINFO.elf   = -g dwarf2
 VBOX_LDR_FMT_2_YASM_DBGINFO.lx    = -g stabs
 VBOX_LDR_FMT_2_YASM_DBGINFO.macho =
 VBOX_LDR_FMT_2_YASM_DBGINFO.pe    =
 VBOX_ASFLAGS   = $(VBOX_ASFLAGS_FMT)   -D__YASM__ -Worphan-labels $(VBOX_LDR_FMT_2_YASM_DBGINFO.$(VBOX_LDR_FMT))
 VBOX_ASFLAGS32 = $(VBOX_ASFLAGS_FMT32) -D__YASM__ -Worphan-labels $(VBOX_LDR_FMT_2_YASM_DBGINFO.$(VBOX_LDR_FMT32))
 VBOX_ASFLAGS64 = $(VBOX_ASFLAGS_FMT64) -D__YASM__ -Worphan-labels $(VBOX_LDR_FMT_2_YASM_DBGINFO.$(VBOX_LDR_FMT64))
else
 VBOX_ASTOOL    = NASM
 VBOX_ASFLAGS   = $(subst elf32,elf,$(VBOX_ASFLAGS_FMT))   -D__NASM__ -w+orphan-labels -g
 VBOX_ASFLAGS32 = $(subst elf32,elf,$(VBOX_ASFLAGS_FMT32)) -D__NASM__ -w+orphan-labels -g
 VBOX_ASFLAGS64 = $(VBOX_ASFLAGS_FMT64) -D__NASM__ -w+orphan-labels -g
endif

#
# Windows only has mingw handy. On *nix we have to deal with cross compiling
# 32-bit targets on 64-bit platforms, meaning we'll be using gcc32/g++32.
# In the latter case we'll also have to disable all the all the R0 driver related stuff.
#
ifndef VBOX_GCC_TOOL
 ifeq ($(BUILD_TARGET),win)
  VBOX_GCC_TOOL := MINGW32
  TOOL_MINGW32_CFLAGS := $(UNDEFINED) # override -g
 else ifeq ($(BUILD_TARGET),os2)
  VBOX_GCC_TOOL := GCC3OMF
 else ifeq ($(BUILD_TARGET),darwin)
  VBOX_GCC_TOOL := GCC4MACHO
 else
  VBOX_GCC_TOOL := GCC3
  ifeq ($(BUILD_TARGET),$(BUILD_PLATFORM))
   ifneq ($(BUILD_TARGET_ARCH),$(BUILD_PLATFORM_ARCH))
    VBOX_GCC_TOOL := GCC32
    VBOX_WITH_VBOXDRV=
    VBOX_WITH_LINUX_ADDITIONS=
    VBOX_WITH_WIN32_ADDITIONS=
   endif
  endif
 endif
endif
ifndef VBOX_GCC32_TOOL
 ifeq ($(BUILD_TARGET_ARCH),x86)
  VBOX_GCC32_TOOL := $(VBOX_GCC_TOOL)
 else ifeq ($(BUILD_TARGET),win)
  VBOX_GCC32_TOOL := MINGW32
 else
  VBOX_GCC32_TOOL := GCC32
 endif
endif

#
# Decide which Visual C++ compiler version we're using by default.
#
ifndef VBOX_VCC_TOOL
 ifeq ($(BUILD_TARGET).$(BUILD_TARGET_ARCH),win.amd64)
  VBOX_USE_VCC80 ?= 1 # Enforce VCC80 when targetting AMD64.
 endif
 ifdef VBOX_USE_VCC80
  ifeq ($(BUILD_TARGET_ARCH),x86)
   VBOX_VCC_TOOL := VCC80X86
  else
   VBOX_VCC_TOOL := VCC80AMD64
  endif
 else
  VBOX_VCC_TOOL := VCC70
 endif
endif

#
# The kBuild tools and SDKs are using PATH_DEVTOOLS, PATH_DEVTOOLS_BLD
# and PATH_DEVTOOLS_TRG to find things if we give them specific locations.
#
PATH_DEVTOOLS ?= $(PATH_ROOT)/tools
PATH_DEVTOOLS := $(abspath $(PATH_DEVTOOLS))
PATH_DEVTOOLS_BLD ?= $(PATH_DEVTOOLS)/$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)
PATH_DEVTOOLS_TRG ?= $(PATH_DEVTOOLS)/$(BUILD_TARGET).$(BUILD_TARGET_ARCH)

## @todo Remove the default tool crap here!
TOOL = $(VBOX_GCC_TOOL)
ifdef VBOX_USE_VCC80
 TOOL.win.x86 = VCC80X86
 TOOL.win.amd64 = VCC80AMD64
else
 TOOL.win = VCC70
endif
ASTOOL = $(VBOX_ASTOOL)

#
# L4.
#
ifdef L4_DIR
 # default CPU type
 ifeq ($(L4_CPU),)
  L4_CPU = 586
 endif
 ifeq ($(L4_API),)
  L4_API = l4v2
 endif
 L4_OBJ := $(L4_DIR)/build-x86-$(L4_CPU)-$(L4_API)
 ifeq ($(BUILD_TARGET),l4)
  L4LINUX26_INCDIR := \
  	$(L4LINUX26_DIR)/include \
	$(L4LINUX26_DIR)/include/asm-l4/i386-arch
  # support splitted Linux kernels (make O=<build directory>)
  kernelsrc := $(shell $(SED_EXT) -ne 's+^KERNELSRC.*= *\(.*\)+\1+p' $(L4LINUX26_DIR)/Makefile)
  ifneq ($(kernelsrc),)
   kernelpath := $(realpath $(kernelsrc))
   L4LINUX26_INCDIR += \
	$(L4LINUX26_DIR)/include2 \
	$(kernelpath)/include
  endif
  L4_INCDIR := \
  	$(L4_OBJ)/include/uclibc++ \
  	$(L4_OBJ)/include/x86/uclibc \
  	$(L4_OBJ)/include/uclibc \
  	$(L4LINUX26_INCDIR) \
  	$(L4_OBJ)/include/x86/$(L4_API) \
  	$(L4_OBJ)/include/x86 \
  	$(L4_OBJ)/include \
  	$(L4_DIR)/tool/dice/include
  L4_LIBDIR := \
  	$(L4_DIR)/build-x86-$(L4_CPU)-$(L4_API)/lib/x86_$(L4_CPU)/$(L4_API)
 endif # BUILD_TARGET == l4
endif # L4_DIR

# Produce debugging information that the Fiasco kernel debugger can read.
ifeq ($(BUILD_TARGET).$(BUILD_TYPE),l4.debug)
 DEBUG_L4 = -gstabs+
endif

#
# Setup the global defines and includes.
#
## @todo PATH_CURRENT has to go, fix the places where we rely on it.
INCS += $(PATH_ROOT)/include $(PATH_OUT)
DEFS += VBOX
DEFS.debug := DEBUG DEBUG_$(subst $(subst _, ,_),_,$(USERNAME)) DEBUG_USERNAME=$(subst $(subst _, ,_),_,$(USERNAME))
DEFS.profile = VBOX_WITH_STATISTICS
DEFS.x86     = __X86__
DEFS.amd64   = __AMD64__
DEFS.darwin  = __DARWIN__
DEFS.darwin.x86 = VBOX_WITH_HYBIRD_32BIT_KERNEL
DEFS.freebsd = __FREEBSD__
DEFS.l4      = __L4__ __L4ENV__ L4API_l4v2 ARCH_x86 __NO_CTYPE _FILE_OFFSET_BITS=64
ifeq ($(L4_API),l4v2onv4)
 DEFS.l4    += L4API_l4v2onv4 STATIC_L4_INLINE
endif
DEFS.linux   = __LINUX__ _FILE_OFFSET_BITS=64
DEFS.netbsd  = __NETBSD__
DEFS.openbsd = __OPENBSD__
DEFS.os2     = __OS2__
DEFS.solaris = __SOLARIS__
DEFS.win     = __WIN__
DEFS.win.x86 = __WIN32__
DEFS.win.amd64 = __WIN64__
# optional defines (use environment or make commandline)
ifdef VBOX_WITH_DEBUGGER
 DEFS += VBOX_WITH_DEBUGGER
endif
ifdef VBOX_WITH_DEBUGGER_GUI
 DEFS += VBOX_WITH_DEBUGGER_GUI
endif
ifdef VBOX_WITH_STATISTICS
 DEFS += VBOX_WITH_STATISTICS
endif
ifdef VBOX_STRICT
 DEFS += VBOX_STRICT
endif
ifdef VBOX_WITHOUT_IDT_PATCHING
 DEFS += VBOX_WITHOUT_IDT_PATCHING
endif
ifdef LOG_ENABLED
 DEFS += LOG_ENABLED
endif
ifdef VBOX_OSE
 DEFS += VBOX_OSE
endif

#
# Compiler optimization flags.
#
ifeq ($(BUILD_TYPE),debug)
 VBOX_GCC_FP  ?= -fno-omit-frame-pointer
 VBOX_GCC_OPT ?= -O0
 VBOX_VCC_FP  ?= -Oy-
 VBOX_VCC_OPT ?=
 VBOX_GCC_GC_FP  ?= -fno-omit-frame-pointer
 VBOX_GCC_GC_OPT ?= -O0
 VBOX_VCC_GC_FP  ?= -Oy-
 VBOX_VCC_GC_OPT ?=
else
 # We should use -fomit-frame-pointer for GCC / -Oy for VCC.
 # -funwind-tables provides support for backtraces in gdb then.
 VBOX_GCC_FP  ?= -fno-omit-frame-pointer
 VBOX_GCC_OPT ?= -O2
 VBOX_VCC_FP  ?= -Oy-
 ifdef VBOX_USE_VCC80
 VBOX_VCC_OPT ?= -O2 -GS-
 else
 VBOX_VCC_OPT ?= -Ogitb2
 endif
 VBOX_GCC_GC_FP  ?= -fno-omit-frame-pointer
 VBOX_GCC_GC_OPT ?= -O2
 VBOX_VCC_GC_FP  ?= -Oy-
 ifdef VBOX_USE_VCC80
 VBOX_VCC_GC_OPT ?= -O2
 else
 VBOX_VCC_GC_OPT ?= -Ogitb2
 endif
endif

#
# ARCH_BITS_DEFS.
#
ifeq ($(BUILD_TARGET_ARCH),amd64)
 ARCH_BITS_DEFS := HC_ARCH_BITS=64 GC_ARCH_BITS=32
else ifeq ($(BUILD_TARGET_ARCH),x86)
 ARCH_BITS_DEFS := HC_ARCH_BITS=32 GC_ARCH_BITS=32
else
 error BUILD_TARGET_ARCH=$(BUILD_TARGET_ARCH)
endif

#
# Add the output dir(s) to the dynamic loader search path.
#
ifeq ($(filter-out linux l4 freebsd netbsd openbsd solaris,$(BUILD_TARGET)),)
 export LD_LIBRARY_PATH:=$(PATH_BIN):$(PATH_LIB):$(LD_LIBRARY_PATH)
endif
ifeq ($(BUILD_TARGET),os2)
 #fixme! export BEGINLIBPATH:=$(PATH_BIN);$(PATH_LIB);$(BEGINLIBPATH)
endif
ifeq ($(BUILD_TARGET),win)
 export PATH:=$(PATH_BIN);$(PATH_LIB);$(PATH)
endif

#
# Common libraries and tools.
#
ifeq ($(BUILD_TARGET),darwin)
 LIB_RUNTIME     = $(PATH_BIN)/VBoxRT.dylib
 LIB_RUNTIME_EF  = #$(PATH_LIB)/RuntimeEFCPP.a
 LIB_KPROFILE    = $(PATH_BIN)/kPrf2.dylib
 LIB_VMM         = $(PATH_BIN)/VBoxVMM.dylib
 LIB_VMMGC       = $(PATH_BIN)/VMMGC.gc
 LIB_REM         = $(PATH_LIB)/VBoxREMImp.dylib
endif
ifeq ($(BUILD_TARGET),l4)
 LIB_RUNTIME     = $(PATH_BIN)/VBoxRT.s.so
 LIB_RUNTIME_EF  = #$(PATH_LIB)/RuntimeEFCPP.a
 LIB_KPROFILE    = $(PATH_BIN)/kPrf2.s.so
 LIB_VMM         = $(PATH_BIN)/VBoxVMM.s.so
 LIB_VMMGC       = $(PATH_BIN)/VMMGC.gc
 LIB_REM         = $(PATH_BIN)/VBoxREMImp.s.so
endif
ifeq ($(filter-out linux freebsd netbsd openbsd solaris,$(BUILD_TARGET)),)
 LIB_RUNTIME     = $(PATH_BIN)/VBoxRT.so
 LIB_RUNTIME_EF  = $(PATH_LIB)/RuntimeEFCPP.a
 LIB_KPROFILE    = $(PATH_BIN)/kPrf2.so
 LIB_VMM         = $(PATH_BIN)/VBoxVMM.so
 LIB_VMMGC       = $(PATH_BIN)/VMMGC.gc
 LIB_REM         = $(PATH_BIN)/VBoxREMImp.so
endif
ifeq ($(BUILD_TARGET),os2)
 LIB_RUNTIME     = $(PATH_BIN)/VBoxRT.dll
 LIB_RUNTIME_EF  = #$(PATH_LIB)/RuntimeEFCPP.a
 LIB_KPROFILE    = $(PATH_BIN)/kPrf2.dll
 LIB_VMM         = $(PATH_BIN)/VBoxVMM.dll
 LIB_VMMGC       = $(PATH_LIB)/VMMGCImp.lib
 LIB_REM         = $(PATH_LIB)/VBoxREMImp.lib
 OBJ_SYS0        = $(PATH_OBJ)/src/VBox/Runtime/RuntimeR0/os2/sys0.obj
endif
ifeq ($(BUILD_TARGET),win)
 LIB_RUNTIME     = $(PATH_LIB)/VBoxRT.lib
 LIB_RUNTIME_EF  = #$(PATH_LIB)/RuntimeEFCPP.lib
 LIB_KPROFILE    = $(PATH_LIB)/kPrf2.lib
 LIB_VMM         = $(PATH_LIB)/VBoxVMM.lib
 LIB_VMMGC       = $(PATH_OUT)/obj/src/VBox/VMM/VMMGC/VMMGC.lib
 LIB_REM         = $(PATH_LIB)/VBoxREMImp.lib
endif

# The kprofile build automagically links with kProfile.
ifeq ($(BUILD_TYPE),kprofile)
 LIB_RUNTIME    += $(LIB_KPROFILE)
endif

# Overridable libraries (unix).
LIB_PTHREAD      ?= pthread
LIB_XCURSOR      ?= Xcursor

## Enable C++ electric fence heap.
#LIB_RUNTIME += $(LIB_RUNTIME_EF) $(LIB_RUNTIME)

# Intel ASL compiler for ACPI
VBOX_IASLCMD   ?= $(firstword $(wildcard $(PATH_DEVTOOLS_BLD)/bin/iasl$(HOSTSUFF_EXE)) iasl$(HOSTSUFF_EXE))

# Bruce's C compile is a C-compiler for BIOS-related 8086 code
VBOX_BCC       ?= $(PATH_DEVTOOLS_BLD)/bin/bcc$(HOSTSUFF_EXE) -B $(PATH_DEVTOOLS_BLD)/bin/

# Assembler for BIOS-related 8086 code
VBOX_AS86      ?= $(PATH_DEVTOOLS_BLD)/bin/as86$(HOSTSUFF_EXE)

# libxslt XSLT processor. (see PATH_TOOL_YASM for explanation why it's temporarily located in bin.)
ifeq ($(BUILD_PLATFORM),win)
# VBOX_XSLTPROC ?= $(PATH_DEVTOOLS)/win.x86/libxslt/10114/xsltproc.exe
 VBOX_XSLTPROC ?= $(PATH_DEVTOOLS)/win.x86/bin/xsltproc.exe
else
 VBOX_XSLTPROC ?= xsltproc$(HOSTSUFF_EXE)
endif

# bin2c (convert binary files into C arrays)
VBOX_BIN2C     ?= $(PATH_OBJ)/src/bldprogs/bin2c/bin2c$(HOSTSUFF_EXE)

# mkisofs
ifeq ($(BUILD_PLATFORM),win)
 VBOX_MKISOFS  ?= $(PATH_DEVTOOLS_BLD)/bin/mkisofs.exe
else
 VBOX_MKISOFS  ?= mkisofs
endif

# Makeself for the linux installers.
VBOX_MAKESELF  ?= $(PATH_DEVTOOLS)/common/makeself/v2.1.4_1/makeself.sh

# Microsoft HTML Help Workshop.
VBOX_PATH_HTML_HELP_WORKSHOP ?= $(PATH_DEVTOOLS)/win.x86/HTML_Help_Workshop/v1.3/

# Path to the null soft installer.
VBOX_PATH_NSIS ?= $(PATH_DEVTOOLS)/win.x86/nsis/v2.22

# Windows install tools...
VBOX_PATH_WIX  ?= $(PATH_DEVTOOLS)/win.x86/wix/v2.0.4611.0
VBOX_PATH_DIFX ?= $(PATH_DEVTOOLS)/win.x86/DIFx/v2.1

# We need to export YASM for OSE, but since it was converted to .zip we need to
# allow for the location used by the zip to be properly cleaned up first.
ifeq ($(filter-out win.x86 linux.x86, $(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)),)
 PATH_TOOL_YASM ?= $(PATH_DEVTOOLS_BLD)/bin
endif

# XPCOM setup for all but win32.
ifneq ($(BUILD_TARGET),win)
 VBOX_WITH_XPCOM      = 1
 VBOX_XPIDL          ?= $(PATH_OBJ)/src/libs/xpcom18a4/xpidl/xpidl$(HOSTSUFF_EXE)
 VBOX_PATH_XPCOM_IDL ?= $(VBOX_PATH_SDK)/idl
 VBOX_XPCOM_INCS     ?= \
 	$(VBOX_PATH_SDK)/include \
 	$(VBOX_PATH_SDK)/include/xpcom \
 	$(VBOX_PATH_SDK)/include/xpcom/nsprpub \
 	$(VBOX_PATH_SDK)/include/xpcom/string \
 	$(VBOX_PATH_SDK)/include/xpcom/xpcom \
 	$(VBOX_PATH_SDK)/include/xpcom/ipcd
 # libIDL-config (for xpcom18a4)
 ifeq ($(origin VBOX_LIBIDL_CONFIG),undefined)
  export VBOX_LIBIDL_CONFIG := $(firstword $(shell which libIDL-config-2 libIDL-config 2> /dev/null))
 endif
endif

# The X11 LIBPATH. (The amd64 hack is for RHEL4.)
ifeq ($(BUILD_TARGET_ARCH),amd64)
 VBOX_LIBPATH_X11 ?= /usr/X11R6/lib64 /usr/X11R6/lib
else
 VBOX_LIBPATH_X11 ?= /usr/X11R6/lib
endif

# 32bit X11 LIBPATH for building 32bit guest additions
VBOX_LIBPATH32_X11 ?= /usr/X11R6/lib32 /usr/X11R6/lib

#
# Mac OS X SDK paths.
#
VBOX_PATH_MACOSX_SDK ?= /Developer/SDKs/MacOSX10.4u.sdk
VBOX_PATH_MACOSX_SDK_INCS ?= $(VBOX_PATH_MACOSX_SDK)/Developer/Headers


#
# GCC stuff properties.
# Most of this is resolved on first kmk invocation and cached in PATH_OUT.
#
# Note! That a harmless warning is printed if the file doesn't exist.
# Note! Changes in GCC are not detected automatically (yet).
#
include $(PATH_KBUILD)/tools/$(VBOX_GCC_TOOL).kmk
ifneq ($(VBOX_GCC_TOOL),$(VBOX_GCC32_TOOL))
 include $(PATH_KBUILD)/tools/$(VBOX_GCC32_TOOL).kmk
endif

VBOX_GCC_CHECK_CC = $(shell \
   if $(TOOL_$(VBOX_GCC_TOOL)_CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
   then echo "$(1)"; \
   else echo "$(2)"; fi; )

VBOX_GCC_CHECK_CXX = $(shell \
   if $(TOOL_$(VBOX_GCC_TOOL)_CXX) $(1) -S -o /dev/null -xc++ /dev/null > /dev/null 2>&1; \
   then echo "$(1)"; \
   else echo "$(2)"; fi; )

VBOX_GCC32_CHECK_CXX = $(shell \
   if $(TOOL_$(VBOX_GCC32_TOOL)_CXX) $(1) -S -o /dev/null -xc++ /dev/null > /dev/null 2>&1; \
   then echo "$(1)"; \
   else echo "$(2)"; fi; )

# This is kind of bad, the returned string needs to be re-evaluated before use.
# The reason for this hack is that the windows kmk_ash cannot deal with $((1+1)). 
VBOX_GCC_VERSION = $(shell \
  $(1) -dumpversion | $(SED_EXT) 's|\([0-9]\)\.\([0-9]\)\.\([0-9]\)|$$(int-add $$(int-mul 10000, \1), $$(int-mul 100, \2), \3)|' )

# No $(QUIET) here as it's interesting to see what goes into the file.
$(PATH_OUT)/GCCConfig.kmk: $(PATH_ROOT)/Config.kmk $(LOCALCFG) $(AUTOCFG)
	$(call MSG_GENERATE,,$@,)
	$(QUIET)$(RM) -f "$@"
	$(QUIET)$(MKDIR) -p $(@D)

	@# HC compiler switch detction.
	$(APPEND) "$@" "VBOX_GCC_VERSION_CC            ?= $(call VBOX_GCC_VERSION,$(TOOL_$(VBOX_GCC_TOOL)_CC))"
	$(APPEND) "$@" "VBOX_GCC_VERSION_CXX           ?= $(call VBOX_GCC_VERSION,$(TOOL_$(VBOX_GCC_TOOL)_CXX))"
	$(APPEND) "$@" "VBOX_GCC_LIBGCC                ?= $(shell $(TOOL_$(VBOX_GCC_TOOL)_CC) -print-libgcc-file-name)"
	$(APPEND) "$@" "VBOX_GCC_Wno-pointer-sign      ?= $(call VBOX_GCC_CHECK_CC,-Wno-pointer-sign,)"
	$(APPEND) "$@" "VBOX_GCC_Wno-variadic-macros   ?= $(call VBOX_GCC_CHECK_CXX,-Wno-variadic-macros,)"
	$(APPEND) "$@" "VBOX_GCC_Wno-invalid-offsetof  ?= $(call VBOX_GCC_CHECK_CXX,-Wno-invalid-offsetof,)"
	$(APPEND) "$@" "VBOX_GCC_Wno-extra             ?= $(call VBOX_GCC_CHECK_CXX,-Wno-extra)"
	$(APPEND) "$@" "VBOX_GCC_fno-stack-protector   ?= $(call VBOX_GCC_CHECK_CC,-fno-stack-protector,)"
ifneq ($(BUILD_TARGET),l4)
	@# Set default attribute for ELF and MACH-O symbols to ``hidden'' to reduce the number
	@# of relocation entries and PLT indirections in shared libraries. Don't allow for gcc version < 4.
	$(APPEND) "$@" "ifneq ($$(int-ge $$(VBOX_GCC_VERSION_CC),40000),)"
	$(APPEND) "$@" " VBOX_GCC_fvisibility-hidden    ?= $(call VBOX_GCC_CHECK_CC,-fvisibility=hidden -DVBOX_HAVE_VISIBILITY_HIDDEN,)"
	$(APPEND) "$@" "endif"
endif
ifneq ($(BUILD_TARGET),l4)
	@# Set default attribute for inline functions to ``hidden'' to reduce the number
	@# of relocation entries and PLT indirections in shared libraries. Don't allow for gcc version < 4.
	$(APPEND) "$@" "ifneq ($$(int-ge $$(VBOX_GCC_VERSION_CXX),40000),)"
	$(APPEND) "$@" " VBOX_GCC_fvisibility-inlines-hidden ?= $(call VBOX_GCC_CHECK_CXX,-fvisibility-inlines-hidden,)"
	$(APPEND) "$@" "endif"
endif
	@# Find the compiler includes for IPRT no-crt.
	$(APPEND) "$@" "VBOX_PATH_GCC_INCS             ?= $(abspath $(dir $(shell LC_ALL=C $(TOOL_$(VBOX_GCC_TOOL)_CC) -print-libgcc-file-name)))/include"

	@# 32-bit (GC) compiler switch detection.
	$(APPEND) "$@" "VBOX_GCC32_VERSION_CC          ?= $(call VBOX_GCC_VERSION,$(TOOL_$(VBOX_GCC32_TOOL)_CC))"
	$(APPEND) "$@" "VBOX_GCC32_VERSION_CXX         ?= $(call VBOX_GCC_VERSION,$(TOOL_$(VBOX_GCC32_TOOL)_CXX))"
	$(APPEND) "$@" "VBOX_GCC32_LIBGCC              ?= $(shell $(TOOL_$(VBOX_GCC32_TOOL)_CC) -print-libgcc-file-name)"
	$(APPEND) "$@" "VBOX_GCC32_Wno-variadic-macros ?= $(call VBOX_GCC32_CHECK_CXX,-Wno-variadic-macros,)"

ifeq ($(BUILD_TARGET),l4)
	@# L4
	$(APPEND) "$@" "VBOX_PATH_L4_GCC3_INSTALL      ?= $(shell LANG=C $(TOOL_$(VBOX_GCC_TOOL)_CC) -print-search-dirs|$(SED_EXT) -ne 's+^install: \(.*[^/][^/]*\)/\?+\1+p')"
endif

include $(PATH_OUT)/GCCConfig.kmk

ifeq ($(BUILD_TARGET),l4)
 VBOX_L4_GCC3_INCS := $(VBOX_PATH_L4_GCC3_INSTALL)/include
 # L4_GPP3_INCS := \
 #         $(VBOX_PATH_L4_GCC3_INSTALL)/include/g++-v3/ \
 #         $(VBOX_PATH_L4_GCC3_INSTALL)/include/g++-v3/i386-pc-linux-gnu/
endif

#
# Coding Signing.
#
ifdef VBOX_SIGNING_MODE
 ifeq ($(BUILD_PLATFORM),win)
  # VBOX_PATH_SELFSIGN points to the Vista WDK bin/SelfSign directory.
  ifndef VBOX_PATH_SELFSIGN
   VBOX_PATH_SELFSIGN := $(lastword $(sort $(wildcard $(PATH_DEVTOOLS)/win.x86/selfsign/*)))
   ifeq ($(VBOX_PATH_SELFSIGN),)
    VBOX_PATH_SELFSIGN := $(PATH_DEVTOOLS)/win.x86/selfsign/r1
   endif
  endif
  VBOX_SIGNTOOL ?= $(VBOX_PATH_SELFSIGN)/SignTool.exe

  # There are two signing modes; 'self' and 'release'.
  ifeq ($(VBOX_SIGNING_MODE),self)
   ## @todo
  else ifeq ($(VBOX_SIGNING_MODE),release)
   VBOX_CROSS_CERTIFICATE_FILE ?= $(VBOX_PATH_SELFSIGN)/MSCV-GlobalSign.cer
   VBOX_CERTIFICATE_STORE ?= my
   VBOX_CERTIFICATE_SUBJECT_NAME ?= InnoTek Systemberatung GmbH
   VBOX_TSA_URL ?= http://timestamp.verisign.com/scripts/timestamp.dll
   VBOX_SIGN_DRIVER_CMDS = $(if $(eq $(tool_do),LINK_LIBRARY),,$(VBOX_SIGNTOOL) sign \
		/ac "$(VBOX_CROSS_CERTIFICATE_FILE)" \
		/s "$(VBOX_CERTIFICATE_STORE)" \
		/n "$(VBOX_CERTIFICATE_SUBJECT_NAME)" \
		/t "$(VBOX_TSA_URL)" \
		$(out))
   VBOX_SIGN_IMAGE_CMDS  = $(if $(eq $(tool_do),LINK_LIBRARY),,$(VBOX_SIGNTOOL) sign \
		/ac "$(VBOX_CROSS_CERTIFICATE_FILE)" \
		/s "$(VBOX_CERTIFICATE_STORE)" \
		/n "$(VBOX_CERTIFICATE_SUBJECT_NAME)" \
		$(out))
  else
   $(error Unknown VBOX_SIGNING_MODE: $(VBOX_SIGNING_MODE))
  endif
 else
  VBOX_SIGNING_MODE :=
 endif
endif

#
# Default prefixes and suffixes.
#
VBOX_PREF_LIB =
ifeq ($(filter-out win os2,$(BUILD_TARGET)),)
VBOX_SUFF_LIB = .lib
else
VBOX_SUFF_LIB = .a
endif
VBOX_SUFF_DLL = $(SUFF_DLL)
VBOXW32GUEST_SUFF_LIB = .lib
VBOXLNX32GUEST_SUFF_LIB = .a

#
# SDKs for external libraries.
#
SDK_VBOX_XERCES       = .
SDK_VBOX_XERCES_INCS ?= $(PATH_ROOT)/src/libs/xerces-2.6.0/src
SDK_VBOX_XERCES_LIBS ?= $(PATH_LIB)/VBox-xerces$(VBOX_SUFF_LIB)

SDK_VBOX_XALAN        = .
SDK_VBOX_XALAN_INCS  ?= $(PATH_ROOT)/src/libs/xalan-1.10.0
SDK_VBOX_XALAN_LIBS  ?= $(PATH_LIB)/VBox-xalan$(VBOX_SUFF_LIB)

SDK_VBOX_LIBPNG       = .
SDK_VBOX_LIBPNG_INCS ?= $(PATH_ROOT)/src/libs/libpng-1.2.8
SDK_VBOX_LIBPNG_LIBS ?= $(PATH_LIB)/VBox-libpng$(VBOX_SUFF_LIB)

SDK_VBOX_ZLIB         = .
ifeq ($(filter-out win os2,$(BUILD_TARGET)),)
 SDK_VBOX_ZLIB_INCS  ?= $(PATH_ROOT)/src/libs/zlib-1.2.1
 SDK_VBOX_ZLIB_LIBS  ?= $(PATH_LIB)/VBox-zlib$(VBOX_SUFF_LIB)
else
 SDK_VBOX_ZLIB_INCS  ?=
 SDK_VBOX_ZLIB_LIBS  ?= z
endif

SDK_VBOX_OPENSSL      = .
SDK_VBOX_OPENSSL_INCS?= $(PATH_ROOT)/src/libs/openssl-0.9.7e/include
SDK_VBOX_OPENSSL_LIBS?= $(PATH_LIB)/VBox-libcrypto$(VBOX_SUFF_LIB)

SDK_VBOX_FFMPEG       = .
ifeq ($(filter-out win os2 darwin,$(BUILD_TARGET)),)
 SDK_VBOX_FFMPEG_INCS ?= \
 	$(PATH_ROOT)/src/libs/ffmpeg-20060710/libavutil \
	$(PATH_ROOT)/src/libs/ffmpeg-20060710/libavcodec \
	$(PATH_ROOT)/src/libs/ffmpeg-20060710/libavformat
 ifeq ($(BUILD_TARGET),win)
  ## @todo Michael! Where is $(PATH_LIB)/VBoxFFmpegImp$(VBOX_SUFF_LIB) supposed to come from?
  #SDK_VBOX_FFMPEG_LIBS ?= $(PATH_LIB)/VBoxFFmpeg.a
  SDK_VBOX_FFMPEG_LIBS ?= $(PATH_LIB)/VBoxFFmpegImp.lib
 else
  SDK_VBOX_FFMPEG_LIBS ?= $(PATH_BIN)/VBoxFFmpeg$(SUFF_DLL)
 endif
else
 SDK_VBOX_FFMPEG_INCS ?= /usr/include/ffmpeg /usr/include/libpng
 SDK_VBOX_FFMPEG_LIBS ?= avutil avcodec avformat
endif

#
# Special SDK for the problematic NTDLL.LIB.
#
SDK_VBOX_NTDLL = Requires W2K3DDK
SDK_VBOX_NTDLL_LIBS ?= $(PATH_SDK_W2K3DDK_LIB)/ntdll.lib


#
# Qt build tools and libraries.
# For *NIX we require it to be present on the system.
#
## @todo convert this into SDK and integrate the Qt stuff into kBuild.
ifeq ($(BUILD_TARGET),win)
 ifeq ($(BUILD_TARGET_ARCH),x86)
  VBOX_PATH_QT ?= $(PATH_DEVTOOLS_TRG)/qt/v3.3.3
  LIB_QT ?= $(VBOX_PATH_QT)/lib/dynamic/qt-mt333.lib
 else
  VBOX_PATH_QT ?= $(PATH_DEVTOOLS_TRG)/qt/v3.3.6
  LIB_QT ?= $(VBOX_PATH_QT)/lib/dynamic/qt-mt336.lib
 endif
  LIB_QTMAIN ?= $(VBOX_PATH_QT)/lib/dynamic/qtmain.lib
 ifndef QTDIR
  QTDIR := $(sort $(wildcard $(PATH_DEVTOOLS_BLD)/v*))
  QTDIR := $(call lastword,$(QTDIR))
 endif

else ifeq ($(BUILD_TARGET),darwin)
 ifndef VBOX_PATH_QT
  VBOX_PATH_QT := $(lastword $(sort $(wildcard $(PATH_DEVTOOLS_TRG)/qt/v3.*)))
  VBOX_PATH_QT ?= $(PATH_DEVTOOLS_TRG)/qt/v3.3.8-r1
 endif
 LIB_QT ?= $(VBOX_PATH_QT)/lib/libqt-mt.3.dylib
 LIB_QTMAIN ?= $(NO_SUCH_VARIABLE)
 ifndef QTDIR
  QTDIR := $(sort $(wildcard $(PATH_DEVTOOLS_BLD)/v*))
  QTDIR := $(call lastword,$(QTDIR))
 endif
else
 ifndef QTDIR
  # This is a pretty safe shot.
  export QTDIR := $(wildcard /usr/share/qt3)
 endif
endif
ifndef VBOX_PATH_QT
 VBOX_PATH_QT ?= $(QTDIR)
 LIB_QT ?= qt-mt
endif
ifeq ($(BUILD_PLATFORM),$(BUILD_TARGET))
 VBOX_PATH_QT_HOST ?= $(VBOX_PATH_QT)
else
 VBOX_PATH_QT_HOST ?= $(QTDIR)
endif
VBOX_UIC      ?= $(VBOX_PATH_QT_HOST)/bin/uic$(HOSTSUFF_EXE)
VBOX_MOC      ?= $(VBOX_PATH_QT_HOST)/bin/moc$(HOSTSUFF_EXE)
VBOX_LUPDATE  ?= $(VBOX_PATH_QT_HOST)/bin/lupdate$(HOSTSUFF_EXE)
VBOX_LRELEASE ?= $(VBOX_PATH_QT_HOST)/bin/lrelease$(HOSTSUFF_EXE)

#
# The linux kernel headers(/sources).
#
ifneq ($(filter linux l4,$(BUILD_TARGET)),)
 ifeq ($(origin VBOX_LINUX_SRC),undefined)
  ifneq ($(wildcard /lib/modules/$(shell uname -r)/build/include/linux/autoconf.h),)
   export VBOX_LINUX_SRC           := /lib/modules/$(shell uname -r)/build
  else
   export VBOX_LINUX_SRC           := /usr/src/linux
  endif
 endif
 ifeq ($(origin VBOX_LINUX_INCS),undefined)
  export VBOX_LINUX_INCS           := $(VBOX_LINUX_SRC)/include
  # support splitted Linux kernels (make O=<build directory>)
  kernelsrc := $(shell $(SED_EXT) -ne 's+^KERNELSRC.*= *\(.*\)+\1+p' $(VBOX_LINUX_SRC)/Makefile)
  ifneq ($(kernelsrc),)
   kernelpath := $(realpath $(VBOX_LINUX_SRC)/$(kernelsrc))
   VBOX_LINUX_INCS                 += $(VBOX_LINUX_SRC)/include2 $(kernelpath)/include
  else
   kernelpath := $(VBOX_LINUX_SRC)
  endif
  ifeq ($(BUILD_TARGET_ARCH),x86)
    VBOX_LINUX_INCS                += $(kernelpath)/include/asm-i386/mach-default
  endif
 endif
endif


#
# Template for building GC things.
#
TEMPLATE_VBOXGC = VBox GC
TEMPLATE_VBOXGC_ASTOOL              = $(VBOX_ASTOOL)
TEMPLATE_VBOXGC_ASFLAGS             = $(VBOX_ASFLAGS32)
TEMPLATE_VBOXGC_DEFS                = IN_GC $(ARCH_BITS_DEFS)
TEMPLATE_VBOXGC_SYSSUFF             = .gc
TEMPLATE_VBOXGC_BLD_TRG_ARCH        = x86

ifeq ($(VBOX_LDR_FMT32),pe)
ifdef VBOX_USE_VCC80
 TEMPLATE_VBOXGC_TOOL               = VCC80X86
 TEMPLATE_VBOXGC_CXXFLAGS           = -Zi -Zl -GR- -GS- -EHs-c- -GF- -W3 -wd4244 -wd4996 -Zc:wchar_t- -Gs8192 $(VBOX_VCC_GC_OPT) $(VBOX_VCC_GC_FP)
else
 TEMPLATE_VBOXGC_TOOL               = VCC70
 TEMPLATE_VBOXGC_CXXFLAGS           = -Zi -Zl -GR- -GX- -GF- -W3 -wd4244 $(VBOX_VCC_GC_OPT) $(VBOX_VCC_GC_FP)
endif
TEMPLATE_VBOXGC_CFLAGS              = $(TEMPLATE_VBOXGC_CXXFLAGS)
TEMPLATE_VBOXGC_LDFLAGS             = -Driver -Subsystem:NATIVE -Incremental:NO -Align:32 -MapInfo:Lines -MapInfo:Exports -NoD
ifdef VBOX_USE_VCC80
 include $(PATH_KBUILD)/sdks/W2K3DDKX86.kmk
 TEMPLATE_VBOXGC_LIBS                = \
	$(PATH_SDK_W2K3DDKX86_LIB)/int64.lib
else
 TEMPLATE_VBOXGC_LIBS                = \
	$(PATH_TOOL_VCC70_LIB)/libcmt.lib  # for 64-bit int
endif
endif

ifeq ($(VBOX_LDR_FMT32),elf)
TEMPLATE_VBOXGC_TOOL                = $(VBOX_GCC32_TOOL)
TEMPLATE_VBOXGC_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC32_Wno-variadic-macros) -pipe -fno-exceptions -fno-rtti $(VBOX_GCC_GC_OPT) $(VBOX_GCC_GC_FP) -fno-strict-aliasing $(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_fvisibility-hidden) $(VBOX_GCC_fvisibility-inlines-hidden)
TEMPLATE_VBOXGC_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC32_Wno-variadic-macros) -pipe -Wmissing-prototypes -Wstrict-prototypes $(VBOX_GCC_GC_OPT) $(VBOX_GCC_GC_FP) -fno-strict-aliasing $(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_fvisibility-hidden)
TEMPLATE_VBOXGC_LDFLAGS             = -nostdlib -Bsymbolic
# temporarily, must fix the loader.
TEMPLATE_VBOXGC_LDFLAGS            += -S
TEMPLATE_VBOXGC_LDFLAGS.release     = -S
TEMPLATE_VBOXGC_LIBS                = \
	$(VBOX_GCC32_LIBGCC) # instricts
endif

ifeq ($(VBOX_LDR_FMT32),macho)
TEMPLATE_VBOXGC_TOOL                = GCC4MACHO
TEMPLATE_VBOXGC_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC32_Wno-variadic-macros) -pipe -fno-common -msoft-float -static -fno-exceptions -fno-rtti $(VBOX_GCC_GC_OPT) $(VBOX_GCC_GC_FP) -fno-strict-aliasing
TEMPLATE_VBOXGC_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC32_Wno-variadic-macros) -pipe -fno-common -msoft-float -static -Wno-trigraphs -Wmissing-prototypes -Wstrict-prototypes $(VBOX_GCC_GC_OPT) $(VBOX_GCC_GC_FP) -fno-strict-aliasing
TEMPLATE_VBOXGC_LDFLAGS             = -nostdlib
#TEMPLATE_VBOXGC_LDFLAGS.release     = -Wl,-S ???
endif

ifeq ($(VBOX_LDR_FMT32),lx)
TEMPLATE_VBOXGC_TOOL                = GCC3OMF
TEMPLATE_VBOXGC_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC32_Wno-variadic-macros) -pipe -fno-exceptions -fno-rtti $(VBOX_GCC_GC_OPT) $(VBOX_GCC_GC_FP) -fno-strict-aliasing
TEMPLATE_VBOXGC_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC32_Wno-variadic-macros) -pipe -Wmissing-prototypes -Wstrict-prototypes $(VBOX_GCC_GC_OPT) $(VBOX_GCC_GC_FP) -fno-strict-aliasing
TEMPLATE_VBOXGC_LDFLAGS             = -Zdll -nostdlib
TEMPLATE_VBOXGC_LIBS                = \
	$(VBOX_GCC32_LIBGCC) \
	$(OBJ_SYS0) \
	end
endif


#
# Template for building a GC ring-3 testcase (tstVMStructGC, tstDevStructGC).
#
TEMPLATE_VBOXGCEXE = VBox GC as ring-3 testcase
TEMPLATE_VBOXGCEXE_EXTENDS = VBOXGC

ifeq ($(VBOX_LDR_FMT32),pe)
 TEMPLATE_VBOXGCEXE_LDFLAGS = -Incremental:NO -MapInfo:Exports -NoD -Debug
 TEMPLATE_VBOXGCEXE_SDKS    = WIN32SDK
 ifdef VBOX_USE_VCC80
  TEMPLATE_VBOXGCEXE_LIBS   = \
	$(PATH_TOOL_VCC80X86_LIB)/libcmt.lib \
	$(PATH_TOOL_VCC80X86_LIB)/oldnames.lib
 else
  TEMPLATE_VBOXGCEXE_LIBS   = \
	$(PATH_TOOL_VCC70_LIB)/libcmt.lib \
	$(PATH_TOOL_VCC70_LIB)/oldnames.lib
 endif
endif

ifeq ($(VBOX_LDR_FMT32),elf)
 TEMPLATE_VBOXGCEXE_LDFLAGS = -g
 TEMPLATE_VBOXGCEXE_LDFLAGS.release = -g
endif

ifeq ($(VBOX_LDR_FMT32),macho)
 TEMPLATE_VBOXGCEXE_CFLAGS   = $(filter-out -static,$(TEMPLATE_VBOXGC_CFLAGS))
 TEMPLATE_VBOXGCEXE_CXXFLAGS = $(filter-out -static,$(TEMPLATE_VBOXGC_CXXFLAGS))
 TEMPLATE_VBOXGCEXE_LDFLAGS  = -g
endif

ifeq ($(VBOX_LDR_FMT32),lx)
 TEMPLATE_VBOXGCEXE_LDFLAGS = -g
 TEMPLATE_VBOXGCEXE_LIBS    = $(NO_SUCH_VARIABLE)
endif


#
# Template for building R0 things.
#
TEMPLATE_VBOXR0 = VBox Ring 0
TEMPLATE_VBOXR0_ASTOOL              = $(VBOX_ASTOOL)
TEMPLATE_VBOXR0_ASFLAGS             = $(VBOX_ASFLAGS)
TEMPLATE_VBOXR0_DEFS                = IN_RING0 $(ARCH_BITS_DEFS)

ifeq ($(VBOX_LDR_FMT),pe)
TEMPLATE_VBOXR0_TOOL                = $(VBOX_VCC_TOOL)
ifdef VBOX_USE_VCC80
 TEMPLATE_VBOXR0_CXXFLAGS           = -Zi -Zl -GR- -GS- -EHs-c- -GF- -W3 -wd4244 -wd4996 -Zc:wchar_t- $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
else
 TEMPLATE_VBOXR0_CXXFLAGS           = -Zi -Zl -GR- -GX- -GF- -W3 -wd4244 $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
endif
TEMPLATE_VBOXR0_CFLAGS              = $(TEMPLATE_VBOXR0_CXXFLAGS)
TEMPLATE_VBOXR0_LDFLAGS             = -Driver -Subsystem:NATIVE -Incremental:NO -Align:32 -MapInfo:Exports -NoD
ifdef VBOX_USE_VCC80
 TEMPLATE_VBOXR0_LIBS.x86           = \
	$(PATH_SDK_W2K3DDKX86_LIB)/int64.lib
else
 TEMPLATE_VBOXR0_LIBS.x86           = \
	$(PATH_TOOL_VCC70_LIB)/libcmt.lib  # for 64-bit int
endif
endif # pe

ifeq ($(VBOX_LDR_FMT),elf)
TEMPLATE_VBOXR0_TOOL                = $(VBOX_GCC_TOOL)
TEMPLATE_VBOXR0_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -Wmissing-prototypes -Wstrict-prototypes $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_fvisibility-hidden)
TEMPLATE_VBOXR0_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -fno-rtti -fno-exceptions $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_fvisibility-inlines-hidden) $(VBOX_GCC_fvisibility-hidden)
TEMPLATE_VBOXR0_CFLAGS.amd64        = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fno-asynchronous-unwind-tables -ffreestanding
TEMPLATE_VBOXR0_CXXFLAGS.amd64      = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fno-asynchronous-unwind-tables
TEMPLATE_VBOXR0_LDFLAGS             = -nostdlib -Bsymbolic
# temporarily, must fix the loader.
TEMPLATE_VBOXR0_LDFLAGS            += -S
TEMPLATE_VBOXR0_LDFLAGS.release     = -S
TEMPLATE_VBOXR0_LIBS                = \
	$(VBOX_GCC_LIBGCC) # instricts
endif

ifeq ($(VBOX_LDR_FMT),macho)
TEMPLATE_VBOXR0_TOOL                = GCC4MACHO
TEMPLATE_VBOXR0_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -fno-common -msoft-float -static -fno-rtti -fno-exceptions $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing
TEMPLATE_VBOXR0_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -fno-common -msoft-float -static -Wmissing-prototypes -Wstrict-prototypes $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing
TEMPLATE_VBOXR0_LDFLAGS             = -nostdlib
#TEMPLATE_VBOXR0_LDFLAGS.release     = -Wl,-S ???
endif

ifeq ($(VBOX_LDR_FMT),lx)
TEMPLATE_VBOXR0_TOOL                = GCC3OMF
TEMPLATE_VBOXR0_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -Wmissing-prototypes -Wstrict-prototypes $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing
TEMPLATE_VBOXR0_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -fno-rtti -fno-exceptions $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing
TEMPLATE_VBOXR0_LDFLAGS             = -Zdll -nostdlib
TEMPLATE_VBOXR0_LIBS                = \
	$(VBOX_GCC_LIBGCC) \
	$(OBJ_SYS0) \
	end
endif


#
# Template for building SUPDRV R0 things.
#
TEMPLATE_VBOXR0DRV                     = VBox SUPDRV Ring 0
TEMPLATE_VBOXR0DRV_ASTOOL              = $(VBOX_ASTOOL)
TEMPLATE_VBOXR0DRV_ASFLAGS             = $(VBOX_ASFLAGS)
TEMPLATE_VBOXR0DRV_DEFS                = IN_RING0 IN_RT_R0 $(ARCH_BITS_DEFS)

ifeq ($(BUILD_TARGET),win)
 TEMPLATE_VBOXR0DRV_TOOL               = $(VBOX_VCC_TOOL)
 TEMPLATE_VBOXR0DRV_RCDEFS             = \
	VBOX_VERSION_MAJOR=\"$(VBOX_VERSION_MAJOR)\" \
	VBOX_VERSION_MINOR=\"$(VBOX_VERSION_MINOR)\" \
	VBOX_VERSION_BUILD=\"$(VBOX_VERSION_BUILD)\" \
	VBOX_VERSION_MAJOR_NR=$(VBOX_VERSION_MAJOR) \
	VBOX_VERSION_MINOR_NR=$(VBOX_VERSION_MINOR) \
	VBOX_VERSION_BUILD_NR=$(VBOX_VERSION_BUILD)
 TEMPLATE_VBOXR0DRV_DEFS.x86           = _X86_
 TEMPLATE_VBOXR0DRV_DEFS.amd64         = _AMD64_
 ifdef VBOX_USE_VCC80
  TEMPLATE_VBOXR0DRV_CXXFLAGS          = -Zi -Zl -GR- -GS- -EHs-c- -GF- -Gz -W3 -wd4996 -Zc:wchar_t- $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
 else
  TEMPLATE_VBOXR0DRV_CXXFLAGS          = -Zi -Zl -GR- -GX- -GF- -Gz -W3 $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
 endif
 TEMPLATE_VBOXR0DRV_CFLAGS             = $(TEMPLATE_VBOXR0DRV_CXXFLAGS)
 TEMPLATE_VBOXR0DRV_LDFLAGS            = -Driver -Subsystem:NATIVE -Incremental:NO -Align:32 -MapInfo:Exports -NoD -Debug
 TEMPLATE_VBOXR0DRV_POST_CMDS          = $(VBOX_SIGN_DRIVER_CMDS)
endif

ifeq ($(BUILD_TARGET),linux)
TEMPLATE_VBOXR0DRV_TOOL                = $(VBOX_GCC_TOOL)
TEMPLATE_VBOXR0DRV_DEFS                = __KERNEL__ MODULE IN_RING0 IN_RT_R0
TEMPLATE_VBOXR0DRV_INCS                = $(VBOX_LINUX_INCS)
TEMPLATE_VBOXR0DRV_CFLAGS              = -nostdinc -iwithprefix include \
	-Wall -Wstrict-prototypes -Wno-trigraphs $(VBOX_GCC_Wno-pointer-sign) \
	$(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing -fno-common
TEMPLATE_VBOXR0DRV_CFLAGS.x86          = -mpreferred-stack-boundary=2 -msoft-float
TEMPLATE_VBOXR0DRV_CFLAGS.amd64        = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow \
	-fno-reorder-blocks -ffreestanding -fno-asynchronous-unwind-tables -funit-at-a-time \
	-Wno-sign-compare -Wdeclaration-after-statement
TEMPLATE_VBOXR0DRV_CXXFLAGS            = $(filter-out -Wstrict-prototypes -Wno-pointer-sign,$(TEMPLATE_VBOXR0DRV_CFLAGS)) -fno-exceptions -fno-rtti
  ifndef VBOX_LINUX_VERSION_2_4
# 2.6
TEMPLATE_VBOXR0DRV_SYSSUFF             = .ko
TEMPLATE_VBOXR0DRV_LDFLAGS.x86         = -m elf_i386 -r
TEMPLATE_VBOXR0DRV_LDFLAGS.amd64       = -m elf_x86_64 -r
  else
# 2.4
TEMPLATE_VBOXR0DRV_SYSSUFF             = .o
TEMPLATE_VBOXR0DRV_LDFLAGS             = -r -s
  endif
endif

ifeq ($(BUILD_TARGET),os2)
TEMPLATE_VBOXR0DRV_TOOL                = GCC3OMF
TEMPLATE_VBOXR0DRV_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing -fno-rtti -fno-exceptions
TEMPLATE_VBOXR0DRV_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing
TEMPLATE_VBOXR0DRV_LIBS                = $(VBOX_GCC_LIBGCC)
# wlink thinks physdevice doesn't need fixups and should have a stack - stupid!
TEMPLATE_VBOXR0DRV_LDFLAGS             = -Zlinker Option -Zlinker internalrelocs, -Zlinker togglerelocs
endif

ifeq ($(BUILD_TARGET),darwin)
TEMPLATE_VBOXR0DRV_TOOL                = GCC4MACHO
TEMPLATE_VBOXR0DRV_DEFS               += KERNEL KERNEL_PRIVATE DRIVER_PRIVATE APPLE NeXT
TEMPLATE_VBOXR0DRV_INCS               += \
	/System/Library/Frameworks/Kernel.framework/PrivateHeaders \
	/Developer/SDKs/MacOSX10.4u.sdk/System/Library/Frameworks/Kernel.framework/Headers
TEMPLATE_VBOXR0DRV_CXXFLAGS            = \
	-g -Wall -Wno-long-long -Wno-trigraphs -pipe -fno-common -nostdinc -fno-builtin -finline \
	-fno-keep-inline-functions -force_cpusubtype_ALL -fno-exceptions -msoft-float -static \
	-mmacosx-version-min=10.4 -isysroot /Developer/SDKs/MacOSX10.4u.sdk \
	-fapple-kext -fno-rtti -fcheck-new
TEMPLATE_VBOXR0DRV_CXXFLAGS.release    = $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing -fasm-blocks
TEMPLATE_VBOXR0DRV_CXXFLAGS.profile    = $(TEMPLATE_VBOXR0DRV_CXXFLAGS.release)
TEMPLATE_VBOXR0DRV_CXXFLAGS.kprofile   = $(TEMPLATE_VBOXR0DRV_CXXFLAGS.release)
TEMPLATE_VBOXR0DRV_CFLAGS              = \
	-g -Wall -Wno-long-long -Wno-trigraphs -pipe -fno-common -nostdinc -fno-builtin -finline \
	-fno-keep-inline-functions -force_cpusubtype_ALL -fno-exceptions -msoft-float -static \
	-mmacosx-version-min=10.4 -isysroot /Developer/SDKs/MacOSX10.4u.sdk \
	-Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations
TEMPLATE_VBOXR0DRV_CFLAGS.release      = $(TEMPLATE_VBOXR0DRV_CXXFLAGS.release)
TEMPLATE_VBOXR0DRV_CFLAGS.profile      = $(TEMPLATE_VBOXR0DRV_CXXFLAGS.profile)
TEMPLATE_VBOXR0DRV_CFLAGS.kprofile     = $(TEMPLATE_VBOXR0DRV_CXXFLAGS.kprofile)
TEMPLATE_VBOXR0DRV_LDFLAGS             = -static -nostdlib -r -Wl,-Y,1455 \
	-mmacosx-version-min=10.4 -isysroot /Developer/SDKs/MacOSX10.4u.sdk
TEMPLATE_VBOXR0DRV_LIBS                = kmodc++ kmod cc_kext cpp_kext $(VBOX_GCC_LIBGCC)
endif

ifeq ($(filter-out freebsd netbsd openbsd,$(BUILD_TARGET)),)  # pure guess work just to avoid the warning below
TEMPLATE_VBOXR0DRV_TOOL                = $(VBOX_GCC_TOOL)
TEMPLATE_VBOXR0DRV_DEFS                = __KERNEL__ IN_RING0 IN_RT_R0
TEMPLATE_VBOXR0DRV_CFLAGS              = \
	-Wall -Wstrict-prototypes -Wno-trigraphs $(VBOX_GCC_Wno-pointer-sign) \
	$(VBOX_GCC_fno-stack-protector) $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing -fno-common
TEMPLATE_VBOXR0DRV_CFLAGS.x86          = -msoft-float
TEMPLATE_VBOXR0DRV_CFLAGS.amd64        = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow \
	-fno-reorder-blocks -ffreestanding -fno-asynchronous-unwind-tables -funit-at-a-time \
	-Wno-sign-compare -Wdeclaration-after-statement
TEMPLATE_VBOXR0DRV_CXXFLAGS            = $(filter-out -Wstrict-prototypes -Wno-pointer-sign,$(TEMPLATE_VBOXR0DRV_CFLAGS)) -fno-exceptions -fno-rtti
TEMPLATE_VBOXR0DRV_SYSSUFF             = .ko
TEMPLATE_VBOXR0DRV_LDFLAGS.x86         = -m elf_i386 -r
TEMPLATE_VBOXR0DRV_LDFLAGS.amd64       = -m elf_x86_64 -r
endif

ifdef VBOX_WITH_VBOXDRV
 ifndef TEMPLATE_VBOXR0DRV_TOOL
  $(warning Warning: VBox Build: Target $(BUILD_PLATFORM) is not officially supported!)
 endif
endif



#
# Template for building R3 executables and static libraries which are linked into executables.
#
TEMPLATE_VBOXR3EXE                     = VBox Ring 3 Exe
TEMPLATE_VBOXR3EXE_ASTOOL              = $(VBOX_ASTOOL)
TEMPLATE_VBOXR3EXE_ASFLAGS             = $(VBOX_ASFLAGS)
TEMPLATE_VBOXR3EXE_DEFS                = IN_RING3 $(ARCH_BITS_DEFS)
TEMPLATE_VBOXR3EXE_LIBS.kprofile       = $(LIB_KPROFILE)
ifeq ($(BUILD_TARGET),win)
 TEMPLATE_VBOXR3EXE_TOOL               = $(VBOX_VCC_TOOL)
 TEMPLATE_VBOXR3EXE_RCDEFS             = \
	VBOX_VERSION_MAJOR=\"$(VBOX_VERSION_MAJOR)\" \
	VBOX_VERSION_MINOR=\"$(VBOX_VERSION_MINOR)\" \
	VBOX_VERSION_BUILD=\"$(VBOX_VERSION_BUILD)\" \
	VBOX_VERSION_MAJOR_NR=$(VBOX_VERSION_MAJOR) \
	VBOX_VERSION_MINOR_NR=$(VBOX_VERSION_MINOR) \
	VBOX_VERSION_BUILD_NR=$(VBOX_VERSION_BUILD)
 TEMPLATE_VBOXR3EXE_SDKS               = WINPSDK
 ifdef VBOX_USE_VCC80
  TEMPLATE_VBOXR3EXE_CXXFLAGS          = -Zi -Zl -GR- -EHs-c- -GF- -MD -W3 -wd4065 -wd4244 -wd4996 -Zc:wchar_t- $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
  TEMPLATE_VBOXR3EXE_CXXFLAGS.debug    = -RTCsu
 else
  TEMPLATE_VBOXR3EXE_CXXFLAGS          = -Zi -Zl -GR- -GX- -GF- -MD -W3 -wd4065 -wd4244 $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
  TEMPLATE_VBOXR3EXE_CXXFLAGS.debug    = -GZ
 endif
 TEMPLATE_VBOXR3EXE_CXXFLAGS.kprofile  = -Gh -GH
 TEMPLATE_VBOXR3EXE_CFLAGS             = $(TEMPLATE_VBOXR3EXE_CXXFLAGS)
 TEMPLATE_VBOXR3EXE_CFLAGS.debug       = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.debug)
 TEMPLATE_VBOXR3EXE_CFLAGS.kprofile    = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.kprofile)
 TEMPLATE_VBOXR3EXE_LDFLAGS            = \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LARGEADDRESSAWARE /DEBUG \
	/DISALLOWLIB:libc.lib \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:libcmt.lib \
	/DISALLOWLIB:libcmtd.lib \
	/DISALLOWLIB:msvcrtd.lib
 TEMPLATE_VBOXR3EXE_LIBS               = \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcrt.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcprt.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/oldnames.lib
 TEMPLATE_VBOXR3EXE_POST_CMDS          = $(VBOX_SIGN_IMAGE_CMDS)

else # the gcc guys
TEMPLATE_VBOXR3EXE_TOOL                = $(VBOX_GCC_TOOL)
TEMPLATE_VBOXR3EXE_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fvisibility-inlines-hidden) $(VBOX_GCC_fvisibility-hidden)
# L4 currently can't handle exception handling.
TEMPLATE_VBOXR3EXE_CXXFLAGS.l4         = -fno-exceptions -nostdinc \
	$(addprefix -I,$(VBOX_L4_GCC3_INCS) $(L4_INCDIR) $(FILE_TOOL_GPP3_INCDIR)) \
	$(DEBUG_L4)
TEMPLATE_VBOXR3EXE_CXXFLAGS.kprofile   = -finstrument-functions
TEMPLATE_VBOXR3EXE_CFLAGS.debug        = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.debug)
TEMPLATE_VBOXR3EXE_CFLAGS.kprofile     = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.kprofile)
TEMPLATE_VBOXR3EXE_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fvisibility-hidden)
TEMPLATE_VBOXR3EXE_CFLAGS.darwin       = -fno-common
TEMPLATE_VBOXR3EXE_CFLAGS.l4           = -nostdinc \
	$(addprefix -I,$(VBOX_L4_GCC3_INCS) $(L4_INCDIR)) $(DEBUG_L4)
TEMPLATE_VBOXR3EXE_DEFS.l4             = L4_THREAD_SAFE
TEMPLATE_VBOXR3EXE_LDFLAGS.l4          = \
	$(L4_LIBDIR)/../crt0.o \
	-T$(L4_LIBDIR)/../main_dyn.ld -nostdlib \
	-Wl,--export-dynamic,--dynamic-linker=libld-l4.s.so \
	-Wl,--rpath-link,$(L4_LIBDIR)
TEMPLATE_VBOXR3EXE_LDFLAGS.linux       = -Wl,-z,noexecstack
 ifeq ($(BUILD_TARGET),linux)
TEMPLATE_VBOXR3EXE_LIBS                = pthread m rt dl
 else ifeq ($(BUILD_TARGET),l4)
TEMPLATE_VBOXR3EXE_LIBS                = \
	$(L4_LIBDIR)/libvboxserver.s.so \
	$(L4_LIBDIR)/libuc++.0.s.so \
	supc++ gcc_eh gcc \
	$(L4_LIBDIR)/libdl.s.so \
	$(L4_LIBDIR)/libuc.0.s.so
 else ifeq ($(BUILD_TARGET),os2)
TEMPLATE_VBOXR3EXE_TOOL                = GCC3OMF
TEMPLATE_VBOXR3EXE_LIBS                = socket iconv
 else ifeq ($(BUILD_TARGET),darwin)
TEMPLATE_VBOXR3EXE_TOOL                = GCC4MACHO
TEMPLATE_VBOXR3EXE_LIBS                =
TEMPLATE_VBOXR3EXE_LDFLAGS             = -read_only_relocs suppress
TEMPLATE_VBOXR3EXE_INCS               += $(VBOX_PATH_MACOSX_SDK_INCS)
 else ifeq ($(filter-out freebsd netbsd openbsd,$(BUILD_TARGET)),)
TEMPLATE_VBOXR3EXE_TOOL                = GCC3
TEMPLATE_VBOXR3EXE_LIBS                = pthread
 else ifeq ($(BUILD_TARGET),solaris)
$(warning Warning: VBOX Build: Target $(BUILD_TARGET) is not officially supported!)
TEMPLATE_VBOXR3EXE_TOOL                = GCC3PLAIN
TEMPLATE_VBOXR3EXE_LIBS                = rt
 else
$(warning Warning: VBOX Build: Target $(BUILD_TARGET) is not officially supported!)
TEMPLATE_VBOXR3EXE_CXXFLAGS.profile    = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.release)
TEMPLATE_VBOXR3EXE_CXXFLAGS.kprofile   = $(TEMPLATE_VBOXR3EXE_CXXFLAGS.krelease)
 endif
endif

#
# Template for building R3 shared objects / DLLs.
# This is mostly identical to the VBOXR3EXE template. (Avoid PIC if possible!)
#
TEMPLATE_VBOXR3  = VBox Ring 3 SO/DLLs
TEMPLATE_VBOXR3_EXTENDS = VBOXR3EXE
TEMPLATE_VBOXR3_LDFLAGS.l4 = $(L4_LIBDIR)/../crt0.s.o -T$(L4_LIBDIR)/../main_rel.ld -nostdlib
TEMPLATE_VBOXR3_DEFS.l4     = $(TEMPLATE_VBOXR3EXE_DEFS.l4) __PIC__
TEMPLATE_VBOXR3_DEFS.darwin = $(TEMPLATE_VBOXR3EXE_DEFS.darwin) PIC
ifeq ($(BUILD_TARGET_ARCH),amd64)
 ifneq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXR3_DEFS = $(TEMPLATE_VBOXR3EXE_DEFS) PIC
  TEMPLATE_VBOXR3_CFLAGS = $(TEMPLATE_VBOXR3EXE_CFLAGS) -fPIC
  TEMPLATE_VBOXR3_CXXFLAGS = $(TEMPLATE_VBOXR3EXE_CXXFLAGS) -fPIC
  TEMPLATE_VBOXR3_LDFLAGS = $(TEMPLATE_VBOXR3EXE_LDFLAGS) -fPIC
 endif
endif

#
# Ring-3 testcase.
# This is the VBOXR3EXE template only with a different install dir.
#
TEMPLATE_VBOXR3TSTEXE  = VBox Ring 3 Testcase Exe
TEMPLATE_VBOXR3TSTEXE_EXTENDS = VBOXR3EXE
TEMPLATE_VBOXR3TSTEXE_INST    = $(INST_TESTCASE)
TEMPLATE_VBOXR3TSTEXE_LIBS    = $(LIB_RUNTIME) $(TEMPLATE_VBOXR3EXE_LIBS)

#
# Template for building bad C/C++ style R3 executables (no -pedantic).
#
TEMPLATE_VBOXR3NPEXE                     = VBox Ring 3 Non-pedantic
TEMPLATE_VBOXR3NPEXE_EXTENDS             = VBOXR3EXE
ifneq ($(BUILD_TARGET),win)
 # (only gcc)
 TEMPLATE_VBOXR3NPEXE_TOOL                = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXR3NPEXE_CXXFLAGS            = $(filter-out -pedantic,$(TEMPLATE_VBOXR3EXE_CXXFLAGS))
 TEMPLATE_VBOXR3NPEXE_CFLAGS              = $(filter-out -pedantic -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations,$(TEMPLATE_VBOXR3EXE_CFLAGS))
endif

#
# Template for building bad C/C++ style R3 shared libraries / Dlls (no -pedantic).
# This is mostly identical to the VBOXR3NPEXE template.
#
TEMPLATE_VBOXR3NP= VBox Ring 3 Non-pedantic
TEMPLATE_VBOXR3NP_EXTENDS = VBOXR3NPEXE
TEMPLATE_VBOXR3NP_LDFLAGS.l4 = \
	$(L4_LIBDIR)/../crt0.s.o \
	-T$(L4_LIBDIR)/../main_rel.ld \
	-nostdlib
TEMPLATE_VBOXR3NP_DEFS.l4 = __PIC__
ifeq ($(BUILD_TARGET_ARCH),amd64)
 ifneq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXR3NP_DEFS = $(TEMPLATE_VBOXR3NPEXE_DEFS) PIC
  TEMPLATE_VBOXR3NP_CFLAGS = $(TEMPLATE_VBOXR3NPEXE_CFLAGS) -fPIC
  TEMPLATE_VBOXR3NP_CXXFLAGS = $(TEMPLATE_VBOXR3NPEXE_CXXFLAGS) -fPIC
  TEMPLATE_VBOXR3NP_LDFLAGS = $(TEMPLATE_VBOXR3NPEXE_LDFLAGS) -fPIC
 endif
endif


#
# Template for building libraries, shared libraries / modules
# which only depends on IPRT for crt.
#
TEMPLATE_VBOXNOCRTGCC = VBox no-crt GCC libraries and modules, yasm/nasm.
TEMPLATE_VBOXNOCRTGCC_DEFS              = IN_RING3 IPRT_NO_CRT $(ARCH_BITS_DEFS)
TEMPLATE_VBOXNOCRTGCC_ASDEFS            = ASM_CALL64_GCC
## @todo C++
TEMPLATE_VBOXNOCRTGCC_CFLAGS            = -nostdinc -fno-strict-aliasing -fno-math-errno -Wall
TEMPLATE_VBOXNOCRTGCC_CFLAGS.amd64      = -mcmodel=medium -fno-common
#TEMPLATE_VBOXNOCRTGCC_CFLAGS.release    = -O0 -fno-math-errno -fno-peephole2 -fno-strict-aliasing - for win64.
TEMPLATE_VBOXNOCRTGCC_CFLAGS.release    = -O2 -fno-strict-aliasing
TEMPLATE_VBOXNOCRTGCC_CFLAGS.profile    = $(TEMPLATE_VBOXNOCRTGCC_CFLAGS.release)
TEMPLATE_VBOXNOCRTGCC_CFLAGS.kprofile   = $(TEMPLATE_VBOXNOCRTGCC_CFLAGS.release)
TEMPLATE_VBOXNOCRTGCC_CFLAGS.darwin     = -mdynamic-no-pic
TEMPLATE_VBOXNOCRTGCC_INCS              = $(PATH_ROOT)/include/iprt/nocrt

ifeq ($(BUILD_TARGET).$(BUILD_TARGET_ARCH),win.amd64)
 # cross compile to 64-bit ELF (linux).
 TEMPLATE_VBOXNOCRTGCC_TOOL             = XGCCAMD64LINUX
 TEMPLATE_VBOXNOCRTGCC_ASTOOL           = YASM
 TEMPLATE_VBOXNOCRTGCC_ASFLAGS          = -f elf64 -DASM_FORMAT_ELF -D__YASM__ -w+orphan-labels -g dwarf2
 TEMPLATE_VBOXNOCRTGCC_LIBS             = $(PATH_DEVTOOLS)/win.x86/x86_64-unknown-linux-gnu/20060701-r2/lib/gcc/x86_64-unknown-linux-gnu/3.4.6/libgcc.a
 TEMPLATE_VBOXNOCRTGCC_LDFLAGS          = -nostdlib

else ifeq ($(BUILD_TARGET).$(BUILD_TARGET_ARCH),win.x86)
 # Use the default GCC (MinGW) with the Microsoft linker.
 # (Drop all '-g' options as we're unable to strip the debug info.)
 TEMPLATE_VBOXNOCRTGCC_TOOL             = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXNOCRTGCC_ASTOOL           = $(VBOX_ASTOOL)
 TEMPLATE_VBOXNOCRTGCC_ASFLAGS          = $(VBOX_ASFLAGS)
 TEMPLATE_VBOXNOCRTGCC_LDTOOL           = $(VBOX_VCC_TOOL)
 TEMPLATE_VBOXNOCRTGCC_LDFLAGS          = -Incremental:NO -MapInfo:Exports -NoD
 TEMPLATE_VBOXNOCRTGCC_LIBS             = $(VBOX_GCC_LIBGCC)
 TEMPLATE_VBOXNOCRTGCC_CFLAGS          := $(filter-out -g,$(TEMPLATE_VBOXNOCRTGCC_CFLAGS)) -s

else
 # Use the default GCC.
 # The use of --exclude-libs ALL is to avoid confusing the linux ld.so.
 TEMPLATE_VBOXNOCRTGCC_TOOL             = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXNOCRTGCC_ASTOOL           = $(VBOX_ASTOOL)
 TEMPLATE_VBOXNOCRTGCC_ASFLAGS          = $(VBOX_ASFLAGS)
 TEMPLATE_VBOXNOCRTGCC_CFLAGS          += $(VBOX_GCC_fno-stack-protector)
 TEMPLATE_VBOXNOCRTGCC_CXXFLAGS        += $(VBOX_GCC_fno-stack-protector)
 TEMPLATE_VBOXNOCRTGCC_LDFLAGS          = -nostdlib
 ifneq ($(filter-out os2 darwin solaris,$(BUILD_TARGET)),)
  ifneq ($(BUILD_TARGET_ARCH),amd64)
   TEMPLATE_VBOXNOCRTGCC_LDFLAGS        += -Wl,--no-undefined
  endif
 endif
 ifneq ($(filter-out freebsd,$(BUILD_TARGET)),)
  TEMPLATE_VBOXNOCRTGCC_LIBS            = # FIXME - has unwind mess.
 else
  TEMPLATE_VBOXNOCRTGCC_LIBS            = $(VBOX_GCC_LIBGCC)
 endif
endif


#
# Same as VBOXNOCRTGCC only it uses GAS as the assembler instead of yasm/nasm.
#
TEMPLATE_VBOXNOCRTGAS = VBox no-crt GCC libraries and modules, gas.
TEMPLATE_VBOXNOCRTGAS_EXTENDS = VBOXNOCRTGCC
TEMPLATE_VBOXNOCRTGAS_ASTOOL = $(TEMPLATE_VBOXNOCRTGCC_TOOL)
ifeq ($(BUILD_TARGET).$(BUILD_TARGET_ARCH),win.x86)
 TEMPLATE_VBOXNOCRTGAS_ASFLAGS = -s
else
 TEMPLATE_VBOXNOCRTGAS_ASFLAGS = -g
endif


#
# Template for building executables that is part of the VBox MAIN component.
#
TEMPLATE_VBOXMAINEXE         = VBox Main Executables
TEMPLATE_VBOXMAINEXE_ASTOOL              = $(VBOX_ASTOOL)
TEMPLATE_VBOXMAINEXE_ASFLAGS             = $(VBOX_ASFLAGS)
TEMPLATE_VBOXMAINEXE_DEFS                = IN_RING3 UNICODE NDEBUG=1
TEMPLATE_VBOXMAINEXE_LIBS.kprofile       = $(LIB_KPROFILE)
TEMPLATE_VBOXMAINEXE_INCS                = \
	$(VBOX_PATH_SDK)/include
ifdef VBOX_WITH_XPCOM
 TEMPLATE_VBOXMAINEXE_INCS              += \
	$(VBOX_XPCOM_INCS)
endif

ifeq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXMAINEXE_SDKS              = WINPSDK W2K3DDK
 ifdef VBOX_USE_VCC80
  TEMPLATE_VBOXMAINEXE_TOOL              = $(VBOX_VCC_TOOL)
  TEMPLATE_VBOXMAINEXE_CXXFLAGS          = -Zi -Zl -GR -GF- -MD -EHsc -W3 -wd4065 -wd4996 -Zc:wchar_t- $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
  TEMPLATE_VBOXMAINEXE_CXXFLAGS.debug    = -RTCsu
 else
  TEMPLATE_VBOXMAINEXE_TOOL              = VCC70
  TEMPLATE_VBOXMAINEXE_CXXFLAGS          = -Zi -Zl -GR -GX- -GF- -MD -EHsc -W3 -wd4065 $(VBOX_VCC_OPT) $(VBOX_VCC_FP)
  TEMPLATE_VBOXMAINEXE_CXXFLAGS.debug    = -GZ
 endif
 TEMPLATE_VBOXMAINEXE_CXXFLAGS.kprofile  = -Gh -GH
 TEMPLATE_VBOXMAINEXE_CFLAGS             = $(TEMPLATE_VBOXMAINEXE_CXXFLAGS)
 TEMPLATE_VBOXMAINEXE_CFLAGS.debug       = $(TEMPLATE_VBOXMAINEXE_CXXFLAGS.debug)
 TEMPLATE_VBOXMAINEXE_CFLAGS.kprofile    = $(TEMPLATE_VBOXMAINEXE_CXXFLAGS.kprofile)
 TEMPLATE_VBOXMAINEXE_INCS              += \
 	$(PATH_TOOL_$(VBOX_VCC_TOOL)_ATLMFC_INC)
 TEMPLATE_VBOXMAINEXE_LDFLAGS            = \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LARGEADDRESSAWARE /DEBUG\
	/DISALLOWLIB:libc.lib \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:msvcrt.lib \
	/DISALLOWLIB:msvcrtd.lib \
	/DISALLOWLIB:libcmtd.lib \
	/DISALLOWLIB:libcmt.lib
 TEMPLATE_VBOXMAINEXE_LIBS               = \
	$(LIB_RUNTIME) \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcrt.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcprt.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/oldnames.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_ATLMFC_LIB)/atls.lib
 TEMPLATE_VBOXMAINEXE_POST_CMDS          = $(VBOX_SIGN_IMAGE_CMDS)

else # the GCC guys:

TEMPLATE_VBOXMAINEXE_DEFS               += VBOX_WITH_XPCOM
TEMPLATE_VBOXMAINEXE_TOOL                = $(VBOX_GCC_TOOL)
TEMPLATE_VBOXMAINEXE_CXXFLAGS            = -g -Wall -Wno-long-long -Wno-trigraphs -pipe  -Wno-non-virtual-dtor -fshort-wchar -fpermissive $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fvisibility-inlines-hidden) $(VBOX_GCC_fvisibility-hidden)
TEMPLATE_VBOXMAINEXE_CXXFLAGS.debug      = -fno-inline
TEMPLATE_VBOXMAINEXE_CXXFLAGS.kprofile   = -finstrument-functions
TEMPLATE_VBOXMAINEXE_CFLAGS              = -g -Wall -Wno-long-long -Wno-trigraphs -pipe  -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations $(VBOX_GCC_OPT) $(VBOX_GCC_FP) -fno-strict-aliasing $(VBOX_GCC_fvisibility-hidden)
TEMPLATE_VBOXMAINEXE_CFLAGS.debug        = -fno-inline
TEMPLATE_VBOXMAINEXE_CFLAGS.kprofile     = $(TEMPLATE_VBOXMAINEXE_CXXFLAGS.kprofile)
TEMPLATE_VBOXMAINEXE_INCS               += $(VBOX_XPCOM_INCS)
 ifeq ($(BUILD_TARGET),linux)
TEMPLATE_VBOXMAINEXE_LIBS                = pthread m rt
 else ifeq ($(BUILD_TARGET),l4)
TEMPLATE_VBOXMAINEXE_LIBS                = $(LIB_RUNTIME)
# no libs as yet in l4 target - must be added later
 else ifeq ($(BUILD_TARGET),os2)
TEMPLATE_VBOXMAINEXE_TOOL                = GCC3OMF
TEMPLATE_VBOXMAINEXE_LIBS                = $(LIB_RUNTIME)
 else ifeq ($(BUILD_TARGET),darwin)
TEMPLATE_VBOXMAINEXE_TOOL                = GCC4MACHO
TEMPLATE_VBOXMAINEXE_LIBS                = $(LIB_RUNTIME)
TEMPLATE_VBOXMAINEXE_LDFLAGS.darwin      = -bind_at_load -framework Carbon
 else ifeq ($(filter-out freebsd netbsd openbsd,$(BUILD_TARGET)),)
TEMPLATE_VBOXMAINEXE_TOOL                = GCC3
TEMPLATE_VBOXMAINEXE_LIBS                = $(LIB_RUNTIME)
TEMPLATE_VBOXMAINEXE_INCS               += $(VBOX_PATH_MACOSX_SDK_INCS)
 else ifeq ($(BUILD_TARGET),solaris)
$(warning Warning: VBOX Build: Target $(BUILD_TARGET) is not officially supported!)
TEMPLATE_VBOXMAINEXE_TOOL                = GCC3PLAIN
TEMPLATE_VBOXMAINEXE_LIBS                = $(LIB_RUNTIME) rt
 else
$(warning Warning: VBOX Build: Target $(BUILD_TARGET) is not officially supported!)
TEMPLATE_VBOXMAINEXE_LIBS                =
 endif

endif # !win

#
# Template for building the Main (+GUI) components
# This differ from VBOXMAINEXE only in PIC handling and similar DLL stuff.
#
TEMPLATE_VBOXMAIN  = VBox MAIN
TEMPLATE_VBOXMAIN_EXTENDS = VBOXMAINEXE
ifeq ($(BUILD_TARGET_ARCH),amd64)
 ifneq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXMAIN_DEFS     = PIC $(TEMPLATE_VBOXMAINEXE_DEFS)
  TEMPLATE_VBOXMAIN_CFLAGS   = -fPIC $(TEMPLATE_VBOXMAINEXE_CFLAGS)
  TEMPLATE_VBOXMAIN_CXXFLAGS = -fPIC $(TEMPLATE_VBOXMAINEXE_CXXFLAGS)
  TEMPLATE_VBOXMAIN_LDFLAGS  = -fPIC $(TEMPLATE_VBOXMAINEXE_LDFLAGS)
 endif
endif
TEMPLATE_VBOXMAIN_LDFLAGS.darwin = $(filter-out -bind_at_load,$(TEMPLATE_VBOXMAINEXE_LDFLAGS.darwin))

#
# Template for building executables that is part of the VBox MAIN component.
# This is (pretty much) identical to VBOXMAIN except for PIC handling (which will be fixed later).
#
TEMPLATE_VBOXMAIN         = VBox Main
TEMPLATE_VBOXMAIN_EXTENDS = VBOXMAINEXE


#
# Template for building executables that use the VBox MAIN component (COM stuff etc.).
#
TEMPLATE_VBOXMAINCLIENTEXE             = VBox MAIN Client (executable)
TEMPLATE_VBOXMAINCLIENTEXE_EXTENDS     = VBOXMAINCLIENT

## @todo Cleanup the EXE/DLL usage of this template. In the mean time, don't use this template.
TEMPLATE_VBOXMAINCLIENT             = VBox MAIN Client (executrable)
TEMPLATE_VBOXMAINCLIENT_EXTENDS     = VBOXMAINEXE
ifeq ($(BUILD_TARGET),win)
 TEMPLATE_VBOXMAINCLIENT_LIBS.win   = $(TEMPLATE_VBOXMAINEXE_LIBS.win) \
   $(PATH_LIB)/VBoxCOM$(VBOX_SUFF_LIB) \
   $(PATH_SDK_WINPSDK_LIB)/User32.Lib \
   $(PATH_SDK_WINPSDK_LIB)/Shell32.Lib \
   $(PATH_SDK_WINPSDK_LIB)/ShLwApi.Lib \
   $(PATH_SDK_WINPSDK_LIB)/Ole32.Lib \
   $(PATH_SDK_WINPSDK_LIB)/OleAut32.Lib \
   $(PATH_SDK_WINPSDK_LIB)/Uuid.Lib
else
 TEMPLATE_VBOXMAINCLIENT_LIBS = $(TEMPLATE_VBOXMAINEXE_LIBS) \
	$(PATH_LIB)/VBoxXPCOM$(VBOX_SUFF_LIB) \
	$(PATH_LIB)/VBoxXPCOMGlue$(VBOX_SUFF_LIB) \
	$(PATH_BIN)/VBoxXPCOM$(VBOX_SUFF_DLL) \
	$(LIB_RUNTIME)

 TEMPLATE_VBOXMAINCLIENT_DEFS = $(TEMPLATE_VBOXMAINEXE_DEFS) \
	NDEBUG TRIMMED
 ## Wonder why we compile main with defaults for these two and then drops it in the client executables...
 TEMPLATE_VBOXMAINCLIENT_CXXFLAGS = $(TEMPLATE_VBOXMAINEXE_CXXFLAGS) \
	-fno-rtti -fno-exceptions
 TEMPLATE_VBOXMAINCLIENT_CXXFLAGS.linux = $(TEMPLATE_VBOXMAINEXE_CXXFLAGS.linux) \
	-pthread
 TEMPLATE_VBOXMAINCLIENT_LDFLAGS.darwin = $(TEMPLATE_VBOXMAINEXE_LDFLAGS.darwin) \
   	-bind_at_load -framework Carbon
endif

#
# Template for building shared libraries / DLLs that use the VBox MAIN component (COM stuff etc.).
# This differ from VBOXMAINCLIENTEXE only in PIC handling and similar DLL stuff.
#
TEMPLATE_VBOXMAINCLIENTDLL              = VBox MAIN Client Shared Libraries
TEMPLATE_VBOXMAINCLIENTDLL_EXTENDS      = VBOXMAINCLIENTEXE
ifeq ($(BUILD_TARGET_ARCH),amd64)
 ifneq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXMAINCLIENTDLL_DEFS       = PIC $(TEMPLATE_VBOXMAINCLIENTEXE_DEFS)
  TEMPLATE_VBOXMAINCLIENTDLL_CFLAGS     = -fPIC $(TEMPLATE_VBOXMAINCLIENTEXE_CFLAGS)
  TEMPLATE_VBOXMAINCLIENTDLL_CXXFLAGS   = -fPIC $(TEMPLATE_VBOXMAINCLIENTEXE_CXXFLAGS)
  TEMPLATE_VBOXMAINCLIENTDLL_LDFLAGS    = -fPIC $(TEMPLATE_VBOXMAINCLIENTEXE_LDFLAGS)
 endif
endif
TEMPLATE_VBOXMAINCLIENTDLL_LDFLAGS.darwin = $(filter-out -bind_at_load,$(TEMPLATE_VBOXMAINCLIENTEXE_LDFLAGS.darwin))


#
# Template for building Qt GUI executables.
#
TEMPLATE_VBOXQTGUIEXE = VBox Qt GUI Executable
TEMPLATE_VBOXQTGUIEXE_DEFS = IN_RING3 QT_NO_DEBUG QT_THREAD_SUPPORT $(ARCH_BITS_DEFS)
TEMPLATE_VBOXQTGUIEXE_INCS = \
	$(VBOX_PATH_SDK)/include \
	$(VBOX_PATH_QT)/include

ifeq ($(BUILD_TARGET),win)
 TEMPLATE_VBOXQTGUIEXE_TOOL = $(VBOX_VCC_TOOL)
 TEMPLATE_VBOXQTGUIEXE_DEFS += _WIN32_WINNT=0x0500 UNICODE QT_DLL _CRT_SECURE_NO_DEPRECATE
 ## @todo VCC70 flags?
 ifdef VBOX_USE_VCC80
  TEMPLATE_VBOXQTGUIEXE_CXXFLAGS = \
 	-nologo -Zm200 -W3 -MD -EHsc -Zc:wchar_t-
  TEMPLATE_VBOXQTGUIEXE_CXXFLAGS.debug = -RTCsu
 else
  TEMPLATE_VBOXQTGUIEXE_CXXFLAGS = \
	-nologo -Zm200 -W3 -MD -GX
  TEMPLATE_VBOXQTGUIEXE_CXXFLAGS.debug = -GZ
 endif
 TEMPLATE_VBOXQTGUIEXE_INCS += \
  	$(PATH_TOOL_$(VBOX_VCC_TOOL)_ATLMFC_INC)
 TEMPLATE_VBOXQTGUIEXE_LDFLAGS = \
 	/NOD /NOLOGO /INCREMENTAL:NO /MAPINFO:EXPORTS /DEBUG \
 	/DELAYLOAD:oleaut32.dll
 TEMPLATE_VBOXQTGUIEXE_SDKS = WINPSDK
 TEMPLATE_VBOXQTGUIEXE_LIBS = \
 	$(LIB_QT) \
	$(LIB_QTMAIN) \
 	$(PATH_LIB)/VBoxCOM$(VBOX_SUFF_LIB) \
 	$(LIB_RUNTIME) \
 	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcprt.lib \
 	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/msvcrt.lib \
 	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/oldnames.lib \
 	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/delayimp.lib \
 	$(PATH_TOOL_$(VBOX_VCC_TOOL)_ATLMFC_LIB)/atls.lib
 TEMPLATE_VBOXQTGUIEXE_POST_CMDS = $(VBOX_SIGN_IMAGE_CMDS)

else # the gcc guys:
 TEMPLATE_VBOXQTGUIEXE_TOOL = $(VBOX_GCC_TOOL)
 TEMPLATE_VBOXQTGUIEXE_DEFS += VBOX_WITH_XPCOM
 TEMPLATE_VBOXQTGUIEXE_DEFS.linux = _REENTRANT

 TEMPLATE_VBOXQTGUIEXE_INCS += \
 	$(LIB_SDL_INC) \
 	$(VBOX_XPCOM_INCS)
 TEMPLATE_VBOXQTGUIEXE_CXXFLAGS = \
 	-pipe -Wall -W -frtti -fno-exceptions -Wno-non-virtual-dtor \
 	-Wno-long-long -fshort-wchar -fno-strict-aliasing \
	$(VBOX_GCC_fvisibility-hidden) $(VBOX_GCC_fvisibility-inlines-hidden)
 TEMPLATE_VBOXQTGUIEXE_CXXFLAGS.linux = -pthread
 ## @todo no $(LIB_QTMAIN) here?
 TEMPLATE_VBOXQTGUIEXE_LIBS = \
 	$(LIB_QT) \
	$(LIB_SDL) \
 	$(PATH_LIB)/VBoxXPCOM$(VBOX_SUFF_LIB) \
 	$(LIB_RUNTIME) \
 	$(LIB_REM) \
 	$(LIB_VMM) \
 	$(PATH_LIB)/VBoxXPCOMGlue$(VBOX_SUFF_LIB) \
 	$(PATH_BIN)/VBoxXPCOM$(VBOX_SUFF_DLL)

 TEMPLATE_VBOXQTGUIEXE_LIBPATH = \
 	$(VBOX_PATH_QT)/lib

 ifeq ($(BUILD_TARGET),darwin)
  TEMPLATE_VBOXQTGUIEXE_INCS += $(VBOX_PATH_MACOSX_SDK_INCS)
  TEMPLATE_VBOXQTGUIEXE_LDFLAGS += -framework Carbon -framework QuickTime -bind_at_load
  TEMPLATE_VBOXQTGUIEXE_LIBS +=
  TEMPLATE_VBOXQTGUIEXE_LIBPATH +=
 else ifeq ($(BUILD_TARGET),os2)
  TEMPLATE_VBOXQTGUIEXE_LIBS +=
  TEMPLATE_VBOXQTGUIEXE_LIBPATH +=
 else
  TEMPLATE_VBOXQTGUIEXE_LIBS += \
 	Xext \
 	X11 \
 	m \
	$(LIB_PTHREAD)
  TEMPLATE_VBOXQTGUIEXE_LIBPATH += \
	$(VBOX_LIBPATH_X11)
 endif

endif

#
# Template for building Qt GUI components.
#
TEMPLATE_VBOXQTGUI = VBox Qt GUI Components
TEMPLATE_VBOXQTGUI_EXTENDS = VBOXQTGUIEXE
TEMPLATE_VBOXQTGUI_LIBS = $(filter-out $(QTMAIN) $(PATH_BIN)/VBoxXML$(VBOX_SUFF_DLL),$(TEMPLATE_VBOXQTGUIEXE_LIBS))
ifeq ($(BUILD_TARGET),darwin)
 TEMPLATE_VBOXQTGUI_LDFLAGS = $(filter-out -framework Carbon -framework QuickTime -bind_at_load,$(TEMPLATE_VBOXQTGUIEXE_LDFLAGS))
endif
ifeq ($(BUILD_TARGET_ARCH),amd64)
 ifneq ($(BUILD_TARGET),win)
  TEMPLATE_VBOXQTGUI_DEFS     = PIC $(TEMPLATE_VBOXQTGUIEXE_DEFS)
  TEMPLATE_VBOXQTGUI_CFLAGS   = -fPIC $(TEMPLATE_VBOXQTGUIEXE_CFLAGS)
  TEMPLATE_VBOXQTGUI_CXXFLAGS = -fPIC $(TEMPLATE_VBOXQTGUIEXE_CXXFLAGS)
  TEMPLATE_VBOXQTGUI_LDFLAGS  = -fPIC $(TEMPLATE_VBOXQTGUIEXE_LDFLAGS)
 endif
endif


#
# Template for building build bldprogs.
#
TEMPLATE_VBOXBLDPROG  = VBox Build Program
TEMPLATE_VBOXBLDPROG_DEFS                = IN_RING3
ifeq ($(BUILD_PLATFORM),win)
 ifeq ($(BUILD_PLATFORM_ARCH),x86)
  ifdef VBOX_USE_VCC80
   TEMPLATE_VBOXBLDPROG_TOOL             = VCC80X86
  else
   TEMPLATE_VBOXBLDPROG_TOOL             = VCC70
  endif
   TEMPLATE_VBOXBLDPROG_SDKS             = WIN32SDK
 else
  TEMPLATE_VBOXBLDPROG_TOOL              = VCC80AMD64
  TEMPLATE_VBOXBLDPROG_SDKS              = WIN64SDK
 endif
 ifneq ($(TEMPLATE_VBOXBLDPROG_TOOL),VCC70)
  TEMPLATE_VBOXBLDPROG_CXXFLAGS          = -Zi -Zl -GR- -EHs-c- -GF- -MT -W3 -wd4996 -Zc:wchar_t-
  TEMPLATE_VBOXBLDPROG_CXXFLAGS.debug    = -RTCsu
  TEMPLATE_VBOXBLDPROG_CXXFLAGS.release  = -O2 -Oy- -GS-
 else
  TEMPLATE_VBOXBLDPROG_CXXFLAGS          = -Zi -Zl -GR- -GX- -GF- -MT -W3
  TEMPLATE_VBOXBLDPROG_CXXFLAGS.debug    = -GZ
  TEMPLATE_VBOXBLDPROG_CXXFLAGS.release  = -Ogitb2 -Oy-
 endif
 TEMPLATE_VBOXBLDPROG_CXXFLAGS.profile   = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.release)
 TEMPLATE_VBOXBLDPROG_CXXFLAGS.kprofile  = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.release)
 TEMPLATE_VBOXBLDPROG_CFLAGS             = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS)
 TEMPLATE_VBOXBLDPROG_CFLAGS.debug       = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.debug)
 TEMPLATE_VBOXBLDPROG_CFLAGS.release     = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.release)
 TEMPLATE_VBOXBLDPROG_CFLAGS.profile     = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.profile)
 TEMPLATE_VBOXBLDPROG_CFLAGS.kprofile    = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.kprofile)
 TEMPLATE_VBOXBLDPROG_LDFLAGS            = \
  	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LARGEADDRESSAWARE /DEBUG \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:libcmtd.lib \
	/DISALLOWLIB:msvcrt.lib \
	/DISALLOWLIB:msvcrtd.lib \
	/DISALLOWLIB:msvcprt.lib \
	/DISALLOWLIB:msvcprtd.lib
 TEMPLATE_VBOXBLDPROG_LIBS               = \
 	$(PATH_TOOL_$(TEMPLATE_VBOXBLDPROG_TOOL)_LIB)/oldnames.lib \
 	$(PATH_TOOL_$(TEMPLATE_VBOXBLDPROG_TOOL)_LIB)/libcmt.lib \
 	$(PATH_TOOL_$(TEMPLATE_VBOXBLDPROG_TOOL)_LIB)/libcpmt.lib

else
# (gcc of some kind )
TEMPLATE_VBOXBLDPROG_TOOL                = GCC3
TEMPLATE_VBOXBLDPROG_CFLAGS              = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs $(VBOX_GCC_Wno-variadic-macros) -pipe  -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations
TEMPLATE_VBOXBLDPROG_CFLAGS.debug        = -fno-inline
TEMPLATE_VBOXBLDPROG_CFLAGS.release      = -O2 -fno-omit-frame-pointer -fno-strict-aliasing
TEMPLATE_VBOXBLDPROG_CFLAGS.profile      = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.profile)
TEMPLATE_VBOXBLDPROG_CFLAGS.kprofile     = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.kprofile)
TEMPLATE_VBOXBLDPROG_CXXFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs -pipe
TEMPLATE_VBOXBLDPROG_CXXFLAGS.debug      = -fno-inline
TEMPLATE_VBOXBLDPROG_CXXFLAGS.release    = -O2 -fno-omit-frame-pointer -fno-strict-aliasing
TEMPLATE_VBOXBLDPROG_CXXFLAGS.profile    = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.release)
TEMPLATE_VBOXBLDPROG_CXXFLAGS.kprofile   = $(TEMPLATE_VBOXBLDPROG_CXXFLAGS.release)
 ifeq ($(BUILD_PLATFORM),linux)
TEMPLATE_VBOXBLDPROG_LIBS                = pthread m rt dl
 else ifeq ($(BUILD_PLATFORM),os2)
TEMPLATE_VBOXBLDPROG_TOOL                = GCC3OMF
TEMPLATE_VBOXBLDPROG_LIBS                = socket iconv
 else ifeq ($(BUILD_PLATFORM),darwin)
TEMPLATE_VBOXBLDPROG_TOOL                = GCC4MACHO
TEMPLATE_VBOXBLDPROG_LIBS                =
TEMPLATE_VBOXBLDPROG_INCS               += $(VBOX_PATH_MACOSX_SDK_INCS)
 else ifeq ($(filter-out freebsd netbsd openbsd,$(BUILD_PLATFORM)),)
TEMPLATE_VBOXBLDPROG_TOOL                = GCC3
TEMPLATE_VBOXBLDPROG_LIBS                =
 else ifeq ($(BUILD_PLATFORM),solaris)
$(warning Warning: VBOX Build: Target $(BUILD_PLATFORM) is not officially supported!)
TEMPLATE_VBOXBLDPROG_TOOL                = GCC3PLAIN
TEMPLATE_VBOXBLDPROG_LIBS                = rt
 else
$(warning Warning: VBOX Build: Target $(BUILD_PLATFORM) is not officially supported!)
 endif

endif # !win



#
# Template for building R3 win32 guest additions.
#
TEMPLATE_VBOXW32GUESTR3  = VBox Win32 Guest Program
TEMPLATE_VBOXW32GUESTR3_INST                = $(INST_ADDITIONS)
TEMPLATE_VBOXW32GUESTR3_BLD_TRG             = win
TEMPLATE_VBOXW32GUESTR3_BLD_TRG_ARCH        = x86
TEMPLATE_VBOXW32GUESTR3_BLD_TRG_CPU         = i386
TEMPLATE_VBOXW32GUESTR3_DEFS                = IN_GUEST IN_GUEST_R3 IN_RING3 IN_RT_R3 __WIN32__ __WIN__ HC_ARCH_BITS=32 GC_ARCH_BITS=32
TEMPLATE_VBOXW32GUESTR3_RCDEFS              = \
	VBOX_VERSION_MAJOR=\"$(VBOX_VERSION_MAJOR)\" \
	VBOX_VERSION_MINOR=\"$(VBOX_VERSION_MINOR)\" \
	VBOX_VERSION_BUILD=\"$(VBOX_VERSION_BUILD)\" \
	VBOX_VERSION_MAJOR_NR=$(VBOX_VERSION_MAJOR) \
	VBOX_VERSION_MINOR_NR=$(VBOX_VERSION_MINOR) \
	VBOX_VERSION_BUILD_NR=$(VBOX_VERSION_BUILD)
TEMPLATE_VBOXW32GUESTR3_ASTOOL              = YASM
TEMPLATE_VBOXW32GUESTR3_ASFLAGS             = -f win -DASM_FORMAT_PE -D__YASM__ -w+orphan-labels
TEMPLATE_VBOXW32GUESTR3_DLLSUFF             = .dll
TEMPLATE_VBOXW32GUESTR3_EXESUFF             = .exe
TEMPLATE_VBOXW32GUESTR3_LIBSUFF             = .lib
TEMPLATE_VBOXW32GUESTR3_ARLIBSUFF           = .lib
TEMPLATE_VBOXW32GUESTR3_SDKS                = WIN32SDK W2K3DDKX86
ifdef VBOX_USE_VCC80
 TEMPLATE_VBOXW32GUESTR3_TOOL               = VCC80X86
 TEMPLATE_VBOXW32GUESTR3_CXXFLAGS           = -Zi -Zl -GR- -EHs-c- -GF- -MT -U__LINUX__ -U__OS2__ -W3 -wd4996 -Zc:wchar_t-
 TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.debug     = -RTCsu
 TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.release   = -O2 -Oy- -GS-
else
 TEMPLATE_VBOXW32GUESTR3_TOOL               = VCC70
 TEMPLATE_VBOXW32GUESTR3_CXXFLAGS           = -Zi -Zl -GR- -GX- -GF- -MT -U__LINUX__ -U__OS2__ -W3
 TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.debug     = -GZ
 TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.release   = -Ogitb2 -Oy-
endif
TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.profile    = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.release)
TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.kprofile   = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.release)
TEMPLATE_VBOXW32GUESTR3_CFLAGS              = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS)
TEMPLATE_VBOXW32GUESTR3_CFLAGS.debug        = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.debug)
TEMPLATE_VBOXW32GUESTR3_CFLAGS.release      = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.release)
TEMPLATE_VBOXW32GUESTR3_CFLAGS.profile      = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.profile)
TEMPLATE_VBOXW32GUESTR3_CFLAGS.kprofile     = $(TEMPLATE_VBOXW32GUESTR3_CXXFLAGS.kprofile)
TEMPLATE_VBOXW32GUESTR3_INCS                = \
	$(VBOX_PATH_SDK)/include
TEMPLATE_VBOXW32GUESTR3_LDFLAGS             = \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LARGEADDRESSAWARE \
	/DISALLOWLIB:libc.lib \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:msvcrt.lib \
	/DISALLOWLIB:libcmtd.lib \
	/DISALLOWLIB:msvcrtd.lib
ifdef VBOX_USE_VCC80
 TEMPLATE_VBOXW32GUESTR3_LIBS               = \
	$(PATH_TOOL_VCC80X86_LIB)/oldnames.lib \
	$(PATH_TOOL_VCC80X86_LIB)/libcmt.lib \
	$(PATH_SDK_W2K3DDKX86_LIB)/ntdll.lib
else
 TEMPLATE_VBOXW32GUESTR3_LIBS               = \
	$(PATH_TOOL_VCC70_LIB)/oldnames.lib \
	$(PATH_TOOL_VCC70_LIB)/libcmt.lib \
	$(PATH_SDK_W2K3DDKX86_LIB)/ntdll.lib
endif
TEMPLATE_VBOXW32GUESTR3_POST_CMDS           = $(VBOX_SIGN_IMAGE_CMDS)

#
# R3 win32 guest libraries
#
TEMPLATE_VBOXW32GUESTR3LIB         = VBox Win32 Guest User Libraries
TEMPLATE_VBOXW32GUESTR3LIB_EXTENDS = VBOXW32GUESTR3
TEMPLATE_VBOXW32GUESTR3LIB_INST    = $(INST_ADDITIONS_LIB)


#
# Template for building R0 win32 guest tools.
#
TEMPLATE_VBOXW32GUESTR0  = VBox Win32 Guest Driver
TEMPLATE_VBOXW32GUESTR0_INST                = $(INST_ADDITIONS)
TEMPLATE_VBOXW32GUESTR0_BLD_TRG             = win
TEMPLATE_VBOXW32GUESTR0_BLD_TRG_ARCH        = x86
TEMPLATE_VBOXW32GUESTR0_BLD_TRG_CPU         = i386
TEMPLATE_VBOXW32GUESTR0_DEFS                = _X86_ IN_GUEST IN_GUEST_R0 IN_RING0 IN_RT_R0 __WIN32__ __WIN__ HC_ARCH_BITS=32 GC_ARCH_BITS=32
TEMPLATE_VBOXW32GUESTR0_RCDEFS              = \
	VBOX_VERSION_MAJOR=\"$(VBOX_VERSION_MAJOR)\" \
	VBOX_VERSION_MINOR=\"$(VBOX_VERSION_MINOR)\" \
	VBOX_VERSION_BUILD=\"$(VBOX_VERSION_BUILD)\" \
	VBOX_VERSION_MAJOR_NR=$(VBOX_VERSION_MAJOR) \
	VBOX_VERSION_MINOR_NR=$(VBOX_VERSION_MINOR) \
	VBOX_VERSION_BUILD_NR=$(VBOX_VERSION_BUILD)
TEMPLATE_VBOXW32GUESTR0_ASTOOL              = YASM
TEMPLATE_VBOXW32GUESTR0_ASFLAGS             = -f win32 -DASM_FORMAT_PE -D__YASM__ -w+orphan-labels
TEMPLATE_VBOXW32GUESTR0_SYSSUFF             = .sys
ifdef VBOX_USE_VCC80
 TEMPLATE_VBOXW32GUESTR0_TOOL               = VCC80X86
 TEMPLATE_VBOXW32GUESTR0_CXXFLAGS           = -Zi -Zl -GR- -GS- -EHs-c- -GF- -Gz -U__LINUX__ -U__OS2__ -W3 -wd4996 -Zc:wchar_t-
 TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.debug     = -GR- -EHs-c- -Zl
 TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.release   = -O2 -Oy-
else
 TEMPLATE_VBOXW32GUESTR0_TOOL               = VCC70
 TEMPLATE_VBOXW32GUESTR0_CXXFLAGS           = -Zi -Zl -GR- -GX- -GF- -Gz -U__LINUX__ -U__OS2__ -W3
 TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.debug     = -GR- -GX- -Zl
 TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.release   = -Ogitb2 -Oy-
endif
TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.profile    = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.release)
TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.kprofile   = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.release)
TEMPLATE_VBOXW32GUESTR0_CFLAGS              = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS)
TEMPLATE_VBOXW32GUESTR0_CFLAGS.debug        = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.debug)
TEMPLATE_VBOXW32GUESTR0_CFLAGS.release      = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.release)
TEMPLATE_VBOXW32GUESTR0_CFLAGS.profile      = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.profile)
TEMPLATE_VBOXW32GUESTR0_CFLAGS.kprofile     = $(TEMPLATE_VBOXW32GUESTR0_CXXFLAGS.kprofile)
TEMPLATE_VBOXW32GUESTR0_LDFLAGS             = \
	-Driver -Subsystem:NATIVE -Incremental:NO -Align:32 -MapInfo:Exports -NoD -Machine:X86 -Debug \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:msvcrt.lib \
	/DISALLOWLIB:msvcrtd.lib \
	/DISALLOWLIB:libcmtd.lib
TEMPLATE_VBOXW32GUESTR0_POST_CMDS           = $(VBOX_SIGN_DRIVER_CMDS)

#
# R0 win32 guest libraries
#
TEMPLATE_VBOXW32GUESTR0LIB         = VBox Win32 Guest Driver
TEMPLATE_VBOXW32GUESTR0LIB_EXTENDS = VBOXW32GUESTR0
TEMPLATE_VBOXW32GUESTR0LIB_INST    = $(INST_ADDITIONS_LIB)


#
# Windows rc workaround for crosscompiling.
# (Some (old) Wine versions fails loading msvcrt.dll from the VCC bin directory.)
#
ifneq ($(BUILD_PLATFORM),win)
 TOOL_VCC80X86_RC   := $(EXEC_X86_WIN32) $(PATH_DEVTOOLS)/win.x86/bin/rc.exe
 TOOL_VCC80AMD64_RC := $(EXEC_X86_WIN32) $(PATH_DEVTOOLS)/win.x86/bin/rc.exe
 TOOL_VCC70_RC      := $(EXEC_X86_WIN32) $(PATH_DEVTOOLS)/win.x86/bin/rc.exe
 WIN32_MC = $(EXEC_X86_WIN32) $(PATH_DEVTOOLS)/win.x86/bin/mc.exe
else
 WIN32_MC = $(EXEC_X86_WIN32) $(firstword $(wildcard \
	$(PATH_SDK_WINPSDK_BIN)/MC.Exe\
	$(PATH_SDK_WINPSDK)/Bin/MC.Exe\
	$(PATH_SDK_WIN32SDK_BIN)/MC.Exe\
	$(PATH_SDK_WIN64SDK_BIN)/MC.Exe\
	$(PATH_DEVTOOLS)/win.x86/bin/mc.exe\
	) Sorry_Cannot_find_mc_in_the_PSDK)
endif


#
# Template for syntax checking the linux guest additions.
# Not properly realized yet.
#
TEMPLATE_VBOXLNX32GUESTR0         = Template for *syntax checking* linux guest additions kernel modules
TEMPLATE_VBOXLNX32GUESTR0_TOOL    = $(VBOX_GCC_TOOL)
TEMPLATE_VBOXLNX32GUESTR0_BLD_TRG = linux
TEMPLATE_VBOXLNX32GUESTR0_DEFS    = __KERNEL__ MODULE IN_GUEST IN_GUEST_R0 IN_RING0 IN_RT_R0
TEMPLATE_VBOXLNX32GUESTR0_INCS    = $(VBOX_LINUX_INCS)
TEMPLATE_VBOXLNX32GUESTR0_CFLAGS  = -nostdinc -iwithprefix include \
	-O2 -Wall -Wstrict-prototypes -Wno-trigraphs $(VBOX_GCC_Wno-pointer-sign) \
	$(VBOX_GCC_fno-stack-protector) -fno-strict-aliasing -fno-common \
	-mpreferred-stack-boundary=2 -msoft-float
TEMPLATE_VBOXLNX32GUESTR0_CXXFLAGS = $(filter-out -Wstrict-prototypes -Wno-pointer-sign,$(TEMPLATE_VBOXLNX32GUESTR0_CFLAGS)) -fno-exceptions -fno-rtti
ifndef VBOX_LINUX_VERSION_2_4
# 2.6
TEMPLATE_VBOXLNX32GUESTR0_SYSSUFF = .ko
TEMPLATE_VBOXLNX32GUESTR0_LDFLAGS = -m elf_i386 -r
else
# 2.4
TEMPLATE_VBOXLNX32GUESTR0_SYSSUFF = .o
TEMPLATE_VBOXLNX32GUESTR0_LDFLAGS = -r -s
endif


#
# Tools and templates for building 32-bit linux guest additions.
#
TOOL_VBOXLNX32NOCPPLD = Linker tool replacing the VBOX_GCC32_TOOL linker (g++).
TOOL_VBOXLNX32NOCPPLD_LINK_PROGRAM_OUTPUT = $(outbase).map
TOOL_VBOXLNX32NOCPPLD_LINK_PROGRAM_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))
TOOL_VBOXLNX32NOCPPLD_LINK_PROGRAM_DEPORD =
define TOOL_VBOXLNX32NOCPPLD_LINK_PROGRAM_CMDS
	$(QUIET)$(TOOL_$(VBOX_GCC32_TOOL)_CC) $(flags) -o $(out) $(objs)\
		$(foreach p,$(libpath), -L$(p))\
		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(basename $(lib))), $(lib)))\
		$(call TOOL_$(VBOX_GCC32_TOOL)_LD_MAP,$(outbase).map)
endef
TOOL_VBOXLNX32NOCPPLD_LINK_DLL_OUTPUT = $(outbase).map
TOOL_VBOXLNX32NOCPPLD_LINK_DLL_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))
TOOL_VBOXLNX32NOCPPLD_LINK_DLL_DEPORD =
# (no SONAME for now)
define TOOL_VBOXLNX32NOCPPLD_LINK_DLL_CMDS
	$(QUIET)$(TOOL_$(VBOX_GCC32_TOOL)_CC) $(TOOL_$(VBOX_GCC32_TOOL)_LDFLAGS.dll) $(flags) -o $(out)\
		$(objs)\
		$(foreach p,$(libpath), -L$(p))\
		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(basename $(lib))), $(lib)))\
		$(call TOOL_$(VBOX_GCC32_TOOL)_LD_MAP,$(outbase).map)
endef
TOOL_VBOXLNX32NOCPPLD_LINK_SYSMOD_OUTPUT = $(outbase).map
TOOL_VBOXLNX32NOCPPLD_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))
TOOL_VBOXLNX32NOCPPLD_LINK_SYSMOD_DEPORD =
define TOOL_VBOXLNX32NOCPPLD_LINK_SYSMOD_CMDS
	$(QUIET)$(TOOL_$(VBOX_GCC32_TOOL)_LD_SYSMOD) $(TOOL_VBOXLNX32NOCPPLD_LDFLAGS.sysmod) $(flags) -o $(out) $(objs)\
		$(foreach p,$(libpath), -L$(p))\
		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(basename $(lib))), $(lib)))\
		$(call TOOL_$(VBOX_GCC32_TOOL)_LD_SYSMOD_MAP,$(outbase).map)
endef

TEMPLATE_VBOXLNX32GUESTR3EXE                   = Template for building 32-bit linux guest additions programs.
TEMPLATE_VBOXLNX32GUESTR3EXE_INST              = $(INST_ADDITIONS)
TEMPLATE_VBOXLNX32GUESTR3EXE_BLD_TRG           = linux
TEMPLATE_VBOXLNX32GUESTR3EXE_BLD_TRG_ARCH      = x86
TEMPLATE_VBOXLNX32GUESTR3EXE_BLD_TRG_CPU       = i386
TEMPLATE_VBOXLNX32GUESTR3EXE_TOOL              = $(VBOX_GCC32_TOOL)
TEMPLATE_VBOXLNX32GUESTR3EXE_ASTOOL            = YASM
TEMPLATE_VBOXLNX32GUESTR3EXE_ASFLAGS           = -f elf32 -DASM_FORMAT_ELF -D__YASM__ -w+orphan-labels
TEMPLATE_VBOXLNX32GUESTR3EXE_DEFS              = IN_GUEST IN_GUEST_R3 IN_RING3 HC_ARCH_BITS=32 GC_ARCH_BITS=32
TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS          = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs -pipe $(VBOX_GCC_fno-stack-protector)
TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.debug    = -fno-inline
TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.release  = -O2 -fno-omit-frame-pointer -fno-strict-aliasing
TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.profile  = $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.release)
TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.kprofile = $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.release)
TEMPLATE_VBOXLNX32GUESTR3EXE_CFLAGS.release    = $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.release)
TEMPLATE_VBOXLNX32GUESTR3EXE_CFLAGS.debug      = $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.debug)
TEMPLATE_VBOXLNX32GUESTR3EXE_CFLAGS.profile    = $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.profile)
TEMPLATE_VBOXLNX32GUESTR3EXE_CFLAGS.kprofile   = $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS.kprofile)
TEMPLATE_VBOXLNX32GUESTR3EXE_CFLAGS            = -g -Wall -pedantic -Wno-long-long -Wno-trigraphs -pipe -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations $(VBOX_GCC_fno-stack-protector)
# No LDFLAGS nor LIBS!

TEMPLATE_VBOXLNX32GUESTR3EXENOCPP              = Template for building 32-bit linux guest additions programs without any C++.
TEMPLATE_VBOXLNX32GUESTR3EXENOCPP_EXTENDS      = VBOXLNX32GUESTR3EXE
TEMPLATE_VBOXLNX32GUESTR3EXENOCPP_LDTOOL       = VBOXLNX32NOCPPLD
# No LDFLAGS nor LIBS!

TEMPLATE_VBOXLNX32GUESTR3DLLNOCPP              = Template for building 32-bit linux guest additions shared objects without any C++.
TEMPLATE_VBOXLNX32GUESTR3DLLNOCPP_EXTENDS      = VBOXLNX32GUESTR3EXE
TEMPLATE_VBOXLNX32GUESTR3DLLNOCPP_LDTOOL       = VBOXLNX32NOCPPLD
TEMPLATE_VBOXLNX32GUESTR3DLLNOCPP_CFLAGS       = -fPIC $(TEMPLATE_VBOXLNX32GUESTR3EXE_CFLAGS)
TEMPLATE_VBOXLNX32GUESTR3DLLNOCPP_CXXFLAGS     = -fPIC $(TEMPLATE_VBOXLNX32GUESTR3EXE_CXXFLAGS)
TEMPLATE_VBOXLNX32GUESTR3DLLNOCPP_LDFLAGS      = -fPIC

TEMPLATE_VBOXLNX32GUESTR3LIB                   = Template for building 32-bit linux guest additions libraries.
TEMPLATE_VBOXLNX32GUESTR3LIB_EXTENDS           = VBOXLNX32GUESTR3EXE
TEMPLATE_VBOXLNX32GUESTR3LIB_INST              = $(INST_ADDITION_LIB)


#
# Two targets to coordinate version number changes properly. Note that the
# only way to get a really consistent build is to run 'kmk' in the top-level
# directory. If you don't run it there, you get a consistent sub-tree only.
#
VBOX_VERSION_STAMP = $(PATH_OUT)/version-stamp-$(VBOX_VERSION_STRING)
VBOX_VERSION_HEADER = $(PATH_OUT)/version-generated.h
VBOX_VERSION_MK     = $(PATH_OUT)/version-generated.mk

$(VBOX_VERSION_STAMP): | $(PATH_ROOT)/Config.kmk
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $(filter-out $@,$(wildcard $(PATH_OUT)/version-stamp-*))
	$(QUIET)$(ECHO_EXT) > $@

$(VBOX_VERSION_HEADER): $(VBOX_VERSION_STAMP)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(APPEND) $@.tmp "#ifndef __version_generated_h__"
	$(QUIET)$(APPEND) $@.tmp "#define __version_generated_h__"
	$(QUIET)$(APPEND) $@.tmp ""
	$(QUIET)$(APPEND) $@.tmp "#define VBOX_VERSION_MAJOR $(VBOX_VERSION_MAJOR)"
	$(QUIET)$(APPEND) $@.tmp "#define VBOX_VERSION_MINOR $(VBOX_VERSION_MINOR)"
	$(QUIET)$(APPEND) $@.tmp "#define VBOX_VERSION_BUILD $(VBOX_VERSION_BUILD)"
	$(QUIET)$(APPEND) $@.tmp '#define VBOX_VERSION_STRING "$(VBOX_VERSION_STRING)"'
	$(QUIET)$(APPEND) $@.tmp ""
	$(QUIET)$(APPEND) $@.tmp "#endif"
	$(QUIET)$(MV) -f $@.tmp $@

#
# Used for external makefiles which cannot include Config.kmk
#
$(VBOX_VERSION_MK): $(VBOX_VERSION_STAMP)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(APPEND) $@.tmp "VBOX_VERSION_MAJOR = $(VBOX_VERSION_MAJOR)"
	$(QUIET)$(APPEND) $@.tmp "VBOX_VERSION_MINOR = $(VBOX_VERSION_MINOR)"
	$(QUIET)$(APPEND) $@.tmp "VBOX_VERSION_BUILD = $(VBOX_VERSION_BUILD)"
	$(QUIET)$(APPEND) $@.tmp "VBOX_VERSION_STRING = $(VBOX_VERSION_STRING)"
	$(QUIET)$(MV) -f $@.tmp $@


# Force building of the version header file as the first thing anywhere in
# the tree. This eliminates the need for manual dependencies on it.
Makefile.kmk: | $(VBOX_VERSION_HEADER) $(VBOX_VERSION_MK)
Makefile: | $(VBOX_VERSION_HEADER) $(VBOX_VERSION_MK)
makefile: | $(VBOX_VERSION_HEADER) $(VBOX_VERSION_MK)


#
# Legacy.
#
ifneq ($(LOCALCFG),)
 include $(LOCALCFG)
endif


#
# Some extra goals.
#
.PHONY: up update st stat status
up update::
	svn$(HOSTSUFF_EXE) up

st stat status:
	svn$(HOSTSUFF_EXE) status

quick:
	$(MAKE) VBOX_QUICK=1

